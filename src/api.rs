// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct HelloRequest {
    // message fields
    pub client_info: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloRequest {
    fn default() -> &'a HelloRequest {
        <HelloRequest as ::protobuf::Message>::default_instance()
    }
}

impl HelloRequest {
    pub fn new() -> HelloRequest {
        ::std::default::Default::default()
    }

    // string client_info = 1;


    pub fn get_client_info(&self) -> &str {
        &self.client_info
    }
    pub fn clear_client_info(&mut self) {
        self.client_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_info(&mut self, v: ::std::string::String) {
        self.client_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_info(&mut self) -> &mut ::std::string::String {
        &mut self.client_info
    }

    // Take field
    pub fn take_client_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_info, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.client_info.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_info);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.client_info.is_empty() {
            os.write_string(1, &self.client_info)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloRequest {
        HelloRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_info",
                |m: &HelloRequest| { &m.client_info },
                |m: &mut HelloRequest| { &mut m.client_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloRequest>(
                "HelloRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloRequest {
        static instance: ::protobuf::rt::LazyV2<HelloRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloRequest::new)
    }
}

impl ::protobuf::Clear for HelloRequest {
    fn clear(&mut self) {
        self.client_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelloResponse {
    // message fields
    pub api_version_major: u32,
    pub api_version_minor: u32,
    pub server_info: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloResponse {
    fn default() -> &'a HelloResponse {
        <HelloResponse as ::protobuf::Message>::default_instance()
    }
}

impl HelloResponse {
    pub fn new() -> HelloResponse {
        ::std::default::Default::default()
    }

    // uint32 api_version_major = 1;


    pub fn get_api_version_major(&self) -> u32 {
        self.api_version_major
    }
    pub fn clear_api_version_major(&mut self) {
        self.api_version_major = 0;
    }

    // Param is passed by value, moved
    pub fn set_api_version_major(&mut self, v: u32) {
        self.api_version_major = v;
    }

    // uint32 api_version_minor = 2;


    pub fn get_api_version_minor(&self) -> u32 {
        self.api_version_minor
    }
    pub fn clear_api_version_minor(&mut self) {
        self.api_version_minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_api_version_minor(&mut self, v: u32) {
        self.api_version_minor = v;
    }

    // string server_info = 3;


    pub fn get_server_info(&self) -> &str {
        &self.server_info
    }
    pub fn clear_server_info(&mut self) {
        self.server_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_info(&mut self, v: ::std::string::String) {
        self.server_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_info(&mut self) -> &mut ::std::string::String {
        &mut self.server_info
    }

    // Take field
    pub fn take_server_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server_info, ::std::string::String::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.api_version_major = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.api_version_minor = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server_info)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.api_version_major != 0 {
            my_size += ::protobuf::rt::value_size(1, self.api_version_major, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.api_version_minor != 0 {
            my_size += ::protobuf::rt::value_size(2, self.api_version_minor, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.server_info.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.server_info);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.api_version_major != 0 {
            os.write_uint32(1, self.api_version_major)?;
        }
        if self.api_version_minor != 0 {
            os.write_uint32(2, self.api_version_minor)?;
        }
        if !self.server_info.is_empty() {
            os.write_string(3, &self.server_info)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloResponse {
        HelloResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "api_version_major",
                |m: &HelloResponse| { &m.api_version_major },
                |m: &mut HelloResponse| { &mut m.api_version_major },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "api_version_minor",
                |m: &HelloResponse| { &m.api_version_minor },
                |m: &mut HelloResponse| { &mut m.api_version_minor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server_info",
                |m: &HelloResponse| { &m.server_info },
                |m: &mut HelloResponse| { &mut m.server_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HelloResponse| { &m.name },
                |m: &mut HelloResponse| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloResponse>(
                "HelloResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloResponse {
        static instance: ::protobuf::rt::LazyV2<HelloResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloResponse::new)
    }
}

impl ::protobuf::Clear for HelloResponse {
    fn clear(&mut self) {
        self.api_version_major = 0;
        self.api_version_minor = 0;
        self.server_info.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectRequest {
    // message fields
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectRequest {
    fn default() -> &'a ConnectRequest {
        <ConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectRequest {
    pub fn new() -> ConnectRequest {
        ::std::default::Default::default()
    }

    // string password = 1;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConnectRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.password.is_empty() {
            os.write_string(1, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectRequest {
        ConnectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &ConnectRequest| { &m.password },
                |m: &mut ConnectRequest| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectRequest>(
                "ConnectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectRequest {
        static instance: ::protobuf::rt::LazyV2<ConnectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectRequest::new)
    }
}

impl ::protobuf::Clear for ConnectRequest {
    fn clear(&mut self) {
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectResponse {
    // message fields
    pub invalid_password: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectResponse {
    fn default() -> &'a ConnectResponse {
        <ConnectResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnectResponse {
    pub fn new() -> ConnectResponse {
        ::std::default::Default::default()
    }

    // bool invalid_password = 1;


    pub fn get_invalid_password(&self) -> bool {
        self.invalid_password
    }
    pub fn clear_invalid_password(&mut self) {
        self.invalid_password = false;
    }

    // Param is passed by value, moved
    pub fn set_invalid_password(&mut self, v: bool) {
        self.invalid_password = v;
    }
}

impl ::protobuf::Message for ConnectResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.invalid_password = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.invalid_password != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.invalid_password != false {
            os.write_bool(1, self.invalid_password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectResponse {
        ConnectResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "invalid_password",
                |m: &ConnectResponse| { &m.invalid_password },
                |m: &mut ConnectResponse| { &mut m.invalid_password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectResponse>(
                "ConnectResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectResponse {
        static instance: ::protobuf::rt::LazyV2<ConnectResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectResponse::new)
    }
}

impl ::protobuf::Clear for ConnectResponse {
    fn clear(&mut self) {
        self.invalid_password = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectRequest {
    fn default() -> &'a DisconnectRequest {
        <DisconnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectRequest {
    pub fn new() -> DisconnectRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisconnectRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectRequest {
        DisconnectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisconnectRequest>(
                "DisconnectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisconnectRequest {
        static instance: ::protobuf::rt::LazyV2<DisconnectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisconnectRequest::new)
    }
}

impl ::protobuf::Clear for DisconnectRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectResponse {
    fn default() -> &'a DisconnectResponse {
        <DisconnectResponse as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectResponse {
    pub fn new() -> DisconnectResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisconnectResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectResponse {
        DisconnectResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisconnectResponse>(
                "DisconnectResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisconnectResponse {
        static instance: ::protobuf::rt::LazyV2<DisconnectResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisconnectResponse::new)
    }
}

impl ::protobuf::Clear for DisconnectResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PingRequest>(
                "PingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PingRequest {
        static instance: ::protobuf::rt::LazyV2<PingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PingRequest::new)
    }
}

impl ::protobuf::Clear for PingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PingResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PingResponse>(
                "PingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PingResponse {
        static instance: ::protobuf::rt::LazyV2<PingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PingResponse::new)
    }
}

impl ::protobuf::Clear for PingResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceInfoRequest {
    fn default() -> &'a DeviceInfoRequest {
        <DeviceInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfoRequest {
    pub fn new() -> DeviceInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeviceInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceInfoRequest {
        DeviceInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceInfoRequest>(
                "DeviceInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceInfoRequest {
        static instance: ::protobuf::rt::LazyV2<DeviceInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceInfoRequest::new)
    }
}

impl ::protobuf::Clear for DeviceInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceInfoResponse {
    // message fields
    pub uses_password: bool,
    pub name: ::std::string::String,
    pub mac_address: ::std::string::String,
    pub esphome_version: ::std::string::String,
    pub compilation_time: ::std::string::String,
    pub model: ::std::string::String,
    pub has_deep_sleep: bool,
    pub project_name: ::std::string::String,
    pub project_version: ::std::string::String,
    pub webserver_port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceInfoResponse {
    fn default() -> &'a DeviceInfoResponse {
        <DeviceInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfoResponse {
    pub fn new() -> DeviceInfoResponse {
        ::std::default::Default::default()
    }

    // bool uses_password = 1;


    pub fn get_uses_password(&self) -> bool {
        self.uses_password
    }
    pub fn clear_uses_password(&mut self) {
        self.uses_password = false;
    }

    // Param is passed by value, moved
    pub fn set_uses_password(&mut self, v: bool) {
        self.uses_password = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string mac_address = 3;


    pub fn get_mac_address(&self) -> &str {
        &self.mac_address
    }
    pub fn clear_mac_address(&mut self) {
        self.mac_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_address(&mut self, v: ::std::string::String) {
        self.mac_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_address(&mut self) -> &mut ::std::string::String {
        &mut self.mac_address
    }

    // Take field
    pub fn take_mac_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_address, ::std::string::String::new())
    }

    // string esphome_version = 4;


    pub fn get_esphome_version(&self) -> &str {
        &self.esphome_version
    }
    pub fn clear_esphome_version(&mut self) {
        self.esphome_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_esphome_version(&mut self, v: ::std::string::String) {
        self.esphome_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_esphome_version(&mut self) -> &mut ::std::string::String {
        &mut self.esphome_version
    }

    // Take field
    pub fn take_esphome_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.esphome_version, ::std::string::String::new())
    }

    // string compilation_time = 5;


    pub fn get_compilation_time(&self) -> &str {
        &self.compilation_time
    }
    pub fn clear_compilation_time(&mut self) {
        self.compilation_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_compilation_time(&mut self, v: ::std::string::String) {
        self.compilation_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compilation_time(&mut self) -> &mut ::std::string::String {
        &mut self.compilation_time
    }

    // Take field
    pub fn take_compilation_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compilation_time, ::std::string::String::new())
    }

    // string model = 6;


    pub fn get_model(&self) -> &str {
        &self.model
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        &mut self.model
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model, ::std::string::String::new())
    }

    // bool has_deep_sleep = 7;


    pub fn get_has_deep_sleep(&self) -> bool {
        self.has_deep_sleep
    }
    pub fn clear_has_deep_sleep(&mut self) {
        self.has_deep_sleep = false;
    }

    // Param is passed by value, moved
    pub fn set_has_deep_sleep(&mut self, v: bool) {
        self.has_deep_sleep = v;
    }

    // string project_name = 8;


    pub fn get_project_name(&self) -> &str {
        &self.project_name
    }
    pub fn clear_project_name(&mut self) {
        self.project_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_name(&mut self, v: ::std::string::String) {
        self.project_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_name(&mut self) -> &mut ::std::string::String {
        &mut self.project_name
    }

    // Take field
    pub fn take_project_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_name, ::std::string::String::new())
    }

    // string project_version = 9;


    pub fn get_project_version(&self) -> &str {
        &self.project_version
    }
    pub fn clear_project_version(&mut self) {
        self.project_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_version(&mut self, v: ::std::string::String) {
        self.project_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_version(&mut self) -> &mut ::std::string::String {
        &mut self.project_version
    }

    // Take field
    pub fn take_project_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_version, ::std::string::String::new())
    }

    // uint32 webserver_port = 10;


    pub fn get_webserver_port(&self) -> u32 {
        self.webserver_port
    }
    pub fn clear_webserver_port(&mut self) {
        self.webserver_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_webserver_port(&mut self, v: u32) {
        self.webserver_port = v;
    }
}

impl ::protobuf::Message for DeviceInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.uses_password = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mac_address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.esphome_version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compilation_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_deep_sleep = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_version)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.webserver_port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.uses_password != false {
            my_size += 2;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.mac_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mac_address);
        }
        if !self.esphome_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.esphome_version);
        }
        if !self.compilation_time.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.compilation_time);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model);
        }
        if self.has_deep_sleep != false {
            my_size += 2;
        }
        if !self.project_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.project_name);
        }
        if !self.project_version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.project_version);
        }
        if self.webserver_port != 0 {
            my_size += ::protobuf::rt::value_size(10, self.webserver_port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.uses_password != false {
            os.write_bool(1, self.uses_password)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.mac_address.is_empty() {
            os.write_string(3, &self.mac_address)?;
        }
        if !self.esphome_version.is_empty() {
            os.write_string(4, &self.esphome_version)?;
        }
        if !self.compilation_time.is_empty() {
            os.write_string(5, &self.compilation_time)?;
        }
        if !self.model.is_empty() {
            os.write_string(6, &self.model)?;
        }
        if self.has_deep_sleep != false {
            os.write_bool(7, self.has_deep_sleep)?;
        }
        if !self.project_name.is_empty() {
            os.write_string(8, &self.project_name)?;
        }
        if !self.project_version.is_empty() {
            os.write_string(9, &self.project_version)?;
        }
        if self.webserver_port != 0 {
            os.write_uint32(10, self.webserver_port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceInfoResponse {
        DeviceInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "uses_password",
                |m: &DeviceInfoResponse| { &m.uses_password },
                |m: &mut DeviceInfoResponse| { &mut m.uses_password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeviceInfoResponse| { &m.name },
                |m: &mut DeviceInfoResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mac_address",
                |m: &DeviceInfoResponse| { &m.mac_address },
                |m: &mut DeviceInfoResponse| { &mut m.mac_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "esphome_version",
                |m: &DeviceInfoResponse| { &m.esphome_version },
                |m: &mut DeviceInfoResponse| { &mut m.esphome_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "compilation_time",
                |m: &DeviceInfoResponse| { &m.compilation_time },
                |m: &mut DeviceInfoResponse| { &mut m.compilation_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &DeviceInfoResponse| { &m.model },
                |m: &mut DeviceInfoResponse| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_deep_sleep",
                |m: &DeviceInfoResponse| { &m.has_deep_sleep },
                |m: &mut DeviceInfoResponse| { &mut m.has_deep_sleep },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_name",
                |m: &DeviceInfoResponse| { &m.project_name },
                |m: &mut DeviceInfoResponse| { &mut m.project_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_version",
                |m: &DeviceInfoResponse| { &m.project_version },
                |m: &mut DeviceInfoResponse| { &mut m.project_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "webserver_port",
                |m: &DeviceInfoResponse| { &m.webserver_port },
                |m: &mut DeviceInfoResponse| { &mut m.webserver_port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceInfoResponse>(
                "DeviceInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceInfoResponse {
        static instance: ::protobuf::rt::LazyV2<DeviceInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceInfoResponse::new)
    }
}

impl ::protobuf::Clear for DeviceInfoResponse {
    fn clear(&mut self) {
        self.uses_password = false;
        self.name.clear();
        self.mac_address.clear();
        self.esphome_version.clear();
        self.compilation_time.clear();
        self.model.clear();
        self.has_deep_sleep = false;
        self.project_name.clear();
        self.project_version.clear();
        self.webserver_port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesRequest {
    fn default() -> &'a ListEntitiesRequest {
        <ListEntitiesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesRequest {
    pub fn new() -> ListEntitiesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListEntitiesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesRequest {
        ListEntitiesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesRequest>(
                "ListEntitiesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesRequest {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesRequest::new)
    }
}

impl ::protobuf::Clear for ListEntitiesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesDoneResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesDoneResponse {
    fn default() -> &'a ListEntitiesDoneResponse {
        <ListEntitiesDoneResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesDoneResponse {
    pub fn new() -> ListEntitiesDoneResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListEntitiesDoneResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesDoneResponse {
        ListEntitiesDoneResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesDoneResponse>(
                "ListEntitiesDoneResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesDoneResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesDoneResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesDoneResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesDoneResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesDoneResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesDoneResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeStatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeStatesRequest {
    fn default() -> &'a SubscribeStatesRequest {
        <SubscribeStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeStatesRequest {
    pub fn new() -> SubscribeStatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeStatesRequest {
        SubscribeStatesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeStatesRequest>(
                "SubscribeStatesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeStatesRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeStatesRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeStatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeStatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesBinarySensorResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub device_class: ::std::string::String,
    pub is_status_binary_sensor: bool,
    pub disabled_by_default: bool,
    pub icon: ::std::string::String,
    pub entity_category: EntityCategory,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesBinarySensorResponse {
    fn default() -> &'a ListEntitiesBinarySensorResponse {
        <ListEntitiesBinarySensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesBinarySensorResponse {
    pub fn new() -> ListEntitiesBinarySensorResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string device_class = 5;


    pub fn get_device_class(&self) -> &str {
        &self.device_class
    }
    pub fn clear_device_class(&mut self) {
        self.device_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_class(&mut self, v: ::std::string::String) {
        self.device_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_class(&mut self) -> &mut ::std::string::String {
        &mut self.device_class
    }

    // Take field
    pub fn take_device_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_class, ::std::string::String::new())
    }

    // bool is_status_binary_sensor = 6;


    pub fn get_is_status_binary_sensor(&self) -> bool {
        self.is_status_binary_sensor
    }
    pub fn clear_is_status_binary_sensor(&mut self) {
        self.is_status_binary_sensor = false;
    }

    // Param is passed by value, moved
    pub fn set_is_status_binary_sensor(&mut self, v: bool) {
        self.is_status_binary_sensor = v;
    }

    // bool disabled_by_default = 7;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // string icon = 8;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // .EntityCategory entity_category = 9;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }
}

impl ::protobuf::Message for ListEntitiesBinarySensorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_class)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_status_binary_sensor = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.device_class);
        }
        if self.is_status_binary_sensor != false {
            my_size += 2;
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.icon);
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(9, self.entity_category);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(5, &self.device_class)?;
        }
        if self.is_status_binary_sensor != false {
            os.write_bool(6, self.is_status_binary_sensor)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(8, &self.icon)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesBinarySensorResponse {
        ListEntitiesBinarySensorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesBinarySensorResponse| { &m.object_id },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesBinarySensorResponse| { &m.key },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesBinarySensorResponse| { &m.name },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesBinarySensorResponse| { &m.unique_id },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_class",
                |m: &ListEntitiesBinarySensorResponse| { &m.device_class },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.device_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_status_binary_sensor",
                |m: &ListEntitiesBinarySensorResponse| { &m.is_status_binary_sensor },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.is_status_binary_sensor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesBinarySensorResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesBinarySensorResponse| { &m.icon },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesBinarySensorResponse| { &m.entity_category },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.entity_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesBinarySensorResponse>(
                "ListEntitiesBinarySensorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesBinarySensorResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesBinarySensorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesBinarySensorResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesBinarySensorResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.device_class.clear();
        self.is_status_binary_sensor = false;
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesBinarySensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesBinarySensorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BinarySensorStateResponse {
    // message fields
    pub key: u32,
    pub state: bool,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinarySensorStateResponse {
    fn default() -> &'a BinarySensorStateResponse {
        <BinarySensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl BinarySensorStateResponse {
    pub fn new() -> BinarySensorStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for BinarySensorStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinarySensorStateResponse {
        BinarySensorStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &BinarySensorStateResponse| { &m.key },
                |m: &mut BinarySensorStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &BinarySensorStateResponse| { &m.state },
                |m: &mut BinarySensorStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &BinarySensorStateResponse| { &m.missing_state },
                |m: &mut BinarySensorStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BinarySensorStateResponse>(
                "BinarySensorStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BinarySensorStateResponse {
        static instance: ::protobuf::rt::LazyV2<BinarySensorStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinarySensorStateResponse::new)
    }
}

impl ::protobuf::Clear for BinarySensorStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BinarySensorStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinarySensorStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesCoverResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub assumed_state: bool,
    pub supports_position: bool,
    pub supports_tilt: bool,
    pub device_class: ::std::string::String,
    pub disabled_by_default: bool,
    pub icon: ::std::string::String,
    pub entity_category: EntityCategory,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesCoverResponse {
    fn default() -> &'a ListEntitiesCoverResponse {
        <ListEntitiesCoverResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesCoverResponse {
    pub fn new() -> ListEntitiesCoverResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // bool assumed_state = 5;


    pub fn get_assumed_state(&self) -> bool {
        self.assumed_state
    }
    pub fn clear_assumed_state(&mut self) {
        self.assumed_state = false;
    }

    // Param is passed by value, moved
    pub fn set_assumed_state(&mut self, v: bool) {
        self.assumed_state = v;
    }

    // bool supports_position = 6;


    pub fn get_supports_position(&self) -> bool {
        self.supports_position
    }
    pub fn clear_supports_position(&mut self) {
        self.supports_position = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_position(&mut self, v: bool) {
        self.supports_position = v;
    }

    // bool supports_tilt = 7;


    pub fn get_supports_tilt(&self) -> bool {
        self.supports_tilt
    }
    pub fn clear_supports_tilt(&mut self) {
        self.supports_tilt = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_tilt(&mut self, v: bool) {
        self.supports_tilt = v;
    }

    // string device_class = 8;


    pub fn get_device_class(&self) -> &str {
        &self.device_class
    }
    pub fn clear_device_class(&mut self) {
        self.device_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_class(&mut self, v: ::std::string::String) {
        self.device_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_class(&mut self) -> &mut ::std::string::String {
        &mut self.device_class
    }

    // Take field
    pub fn take_device_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_class, ::std::string::String::new())
    }

    // bool disabled_by_default = 9;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // string icon = 10;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // .EntityCategory entity_category = 11;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }
}

impl ::protobuf::Message for ListEntitiesCoverResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.assumed_state = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_position = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_tilt = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_class)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.assumed_state != false {
            my_size += 2;
        }
        if self.supports_position != false {
            my_size += 2;
        }
        if self.supports_tilt != false {
            my_size += 2;
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.icon);
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(11, self.entity_category);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.assumed_state != false {
            os.write_bool(5, self.assumed_state)?;
        }
        if self.supports_position != false {
            os.write_bool(6, self.supports_position)?;
        }
        if self.supports_tilt != false {
            os.write_bool(7, self.supports_tilt)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(10, &self.icon)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesCoverResponse {
        ListEntitiesCoverResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesCoverResponse| { &m.object_id },
                |m: &mut ListEntitiesCoverResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesCoverResponse| { &m.key },
                |m: &mut ListEntitiesCoverResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesCoverResponse| { &m.name },
                |m: &mut ListEntitiesCoverResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesCoverResponse| { &m.unique_id },
                |m: &mut ListEntitiesCoverResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "assumed_state",
                |m: &ListEntitiesCoverResponse| { &m.assumed_state },
                |m: &mut ListEntitiesCoverResponse| { &mut m.assumed_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_position",
                |m: &ListEntitiesCoverResponse| { &m.supports_position },
                |m: &mut ListEntitiesCoverResponse| { &mut m.supports_position },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_tilt",
                |m: &ListEntitiesCoverResponse| { &m.supports_tilt },
                |m: &mut ListEntitiesCoverResponse| { &mut m.supports_tilt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_class",
                |m: &ListEntitiesCoverResponse| { &m.device_class },
                |m: &mut ListEntitiesCoverResponse| { &mut m.device_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesCoverResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesCoverResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesCoverResponse| { &m.icon },
                |m: &mut ListEntitiesCoverResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesCoverResponse| { &m.entity_category },
                |m: &mut ListEntitiesCoverResponse| { &mut m.entity_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesCoverResponse>(
                "ListEntitiesCoverResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesCoverResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesCoverResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesCoverResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesCoverResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.assumed_state = false;
        self.supports_position = false;
        self.supports_tilt = false;
        self.device_class.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesCoverResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesCoverResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CoverStateResponse {
    // message fields
    pub key: u32,
    pub legacy_state: LegacyCoverState,
    pub position: f32,
    pub tilt: f32,
    pub current_operation: CoverOperation,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoverStateResponse {
    fn default() -> &'a CoverStateResponse {
        <CoverStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CoverStateResponse {
    pub fn new() -> CoverStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // .LegacyCoverState legacy_state = 2;


    pub fn get_legacy_state(&self) -> LegacyCoverState {
        self.legacy_state
    }
    pub fn clear_legacy_state(&mut self) {
        self.legacy_state = LegacyCoverState::LEGACY_COVER_STATE_OPEN;
    }

    // Param is passed by value, moved
    pub fn set_legacy_state(&mut self, v: LegacyCoverState) {
        self.legacy_state = v;
    }

    // float position = 3;


    pub fn get_position(&self) -> f32 {
        self.position
    }
    pub fn clear_position(&mut self) {
        self.position = 0.;
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: f32) {
        self.position = v;
    }

    // float tilt = 4;


    pub fn get_tilt(&self) -> f32 {
        self.tilt
    }
    pub fn clear_tilt(&mut self) {
        self.tilt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tilt(&mut self, v: f32) {
        self.tilt = v;
    }

    // .CoverOperation current_operation = 5;


    pub fn get_current_operation(&self) -> CoverOperation {
        self.current_operation
    }
    pub fn clear_current_operation(&mut self) {
        self.current_operation = CoverOperation::COVER_OPERATION_IDLE;
    }

    // Param is passed by value, moved
    pub fn set_current_operation(&mut self, v: CoverOperation) {
        self.current_operation = v;
    }
}

impl ::protobuf::Message for CoverStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.legacy_state, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.position = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tilt = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.current_operation, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.legacy_state != LegacyCoverState::LEGACY_COVER_STATE_OPEN {
            my_size += ::protobuf::rt::enum_size(2, self.legacy_state);
        }
        if self.position != 0. {
            my_size += 5;
        }
        if self.tilt != 0. {
            my_size += 5;
        }
        if self.current_operation != CoverOperation::COVER_OPERATION_IDLE {
            my_size += ::protobuf::rt::enum_size(5, self.current_operation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.legacy_state != LegacyCoverState::LEGACY_COVER_STATE_OPEN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.legacy_state))?;
        }
        if self.position != 0. {
            os.write_float(3, self.position)?;
        }
        if self.tilt != 0. {
            os.write_float(4, self.tilt)?;
        }
        if self.current_operation != CoverOperation::COVER_OPERATION_IDLE {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.current_operation))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoverStateResponse {
        CoverStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &CoverStateResponse| { &m.key },
                |m: &mut CoverStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LegacyCoverState>>(
                "legacy_state",
                |m: &CoverStateResponse| { &m.legacy_state },
                |m: &mut CoverStateResponse| { &mut m.legacy_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "position",
                |m: &CoverStateResponse| { &m.position },
                |m: &mut CoverStateResponse| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tilt",
                |m: &CoverStateResponse| { &m.tilt },
                |m: &mut CoverStateResponse| { &mut m.tilt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CoverOperation>>(
                "current_operation",
                |m: &CoverStateResponse| { &m.current_operation },
                |m: &mut CoverStateResponse| { &mut m.current_operation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoverStateResponse>(
                "CoverStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoverStateResponse {
        static instance: ::protobuf::rt::LazyV2<CoverStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoverStateResponse::new)
    }
}

impl ::protobuf::Clear for CoverStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.legacy_state = LegacyCoverState::LEGACY_COVER_STATE_OPEN;
        self.position = 0.;
        self.tilt = 0.;
        self.current_operation = CoverOperation::COVER_OPERATION_IDLE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoverStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CoverCommandRequest {
    // message fields
    pub key: u32,
    pub has_legacy_command: bool,
    pub legacy_command: LegacyCoverCommand,
    pub has_position: bool,
    pub position: f32,
    pub has_tilt: bool,
    pub tilt: f32,
    pub stop: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoverCommandRequest {
    fn default() -> &'a CoverCommandRequest {
        <CoverCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl CoverCommandRequest {
    pub fn new() -> CoverCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool has_legacy_command = 2;


    pub fn get_has_legacy_command(&self) -> bool {
        self.has_legacy_command
    }
    pub fn clear_has_legacy_command(&mut self) {
        self.has_legacy_command = false;
    }

    // Param is passed by value, moved
    pub fn set_has_legacy_command(&mut self, v: bool) {
        self.has_legacy_command = v;
    }

    // .LegacyCoverCommand legacy_command = 3;


    pub fn get_legacy_command(&self) -> LegacyCoverCommand {
        self.legacy_command
    }
    pub fn clear_legacy_command(&mut self) {
        self.legacy_command = LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN;
    }

    // Param is passed by value, moved
    pub fn set_legacy_command(&mut self, v: LegacyCoverCommand) {
        self.legacy_command = v;
    }

    // bool has_position = 4;


    pub fn get_has_position(&self) -> bool {
        self.has_position
    }
    pub fn clear_has_position(&mut self) {
        self.has_position = false;
    }

    // Param is passed by value, moved
    pub fn set_has_position(&mut self, v: bool) {
        self.has_position = v;
    }

    // float position = 5;


    pub fn get_position(&self) -> f32 {
        self.position
    }
    pub fn clear_position(&mut self) {
        self.position = 0.;
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: f32) {
        self.position = v;
    }

    // bool has_tilt = 6;


    pub fn get_has_tilt(&self) -> bool {
        self.has_tilt
    }
    pub fn clear_has_tilt(&mut self) {
        self.has_tilt = false;
    }

    // Param is passed by value, moved
    pub fn set_has_tilt(&mut self, v: bool) {
        self.has_tilt = v;
    }

    // float tilt = 7;


    pub fn get_tilt(&self) -> f32 {
        self.tilt
    }
    pub fn clear_tilt(&mut self) {
        self.tilt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tilt(&mut self, v: f32) {
        self.tilt = v;
    }

    // bool stop = 8;


    pub fn get_stop(&self) -> bool {
        self.stop
    }
    pub fn clear_stop(&mut self) {
        self.stop = false;
    }

    // Param is passed by value, moved
    pub fn set_stop(&mut self, v: bool) {
        self.stop = v;
    }
}

impl ::protobuf::Message for CoverCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_legacy_command = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.legacy_command, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_position = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.position = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_tilt = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tilt = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stop = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.has_legacy_command != false {
            my_size += 2;
        }
        if self.legacy_command != LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN {
            my_size += ::protobuf::rt::enum_size(3, self.legacy_command);
        }
        if self.has_position != false {
            my_size += 2;
        }
        if self.position != 0. {
            my_size += 5;
        }
        if self.has_tilt != false {
            my_size += 2;
        }
        if self.tilt != 0. {
            my_size += 5;
        }
        if self.stop != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_legacy_command != false {
            os.write_bool(2, self.has_legacy_command)?;
        }
        if self.legacy_command != LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.legacy_command))?;
        }
        if self.has_position != false {
            os.write_bool(4, self.has_position)?;
        }
        if self.position != 0. {
            os.write_float(5, self.position)?;
        }
        if self.has_tilt != false {
            os.write_bool(6, self.has_tilt)?;
        }
        if self.tilt != 0. {
            os.write_float(7, self.tilt)?;
        }
        if self.stop != false {
            os.write_bool(8, self.stop)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoverCommandRequest {
        CoverCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &CoverCommandRequest| { &m.key },
                |m: &mut CoverCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_legacy_command",
                |m: &CoverCommandRequest| { &m.has_legacy_command },
                |m: &mut CoverCommandRequest| { &mut m.has_legacy_command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LegacyCoverCommand>>(
                "legacy_command",
                |m: &CoverCommandRequest| { &m.legacy_command },
                |m: &mut CoverCommandRequest| { &mut m.legacy_command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_position",
                |m: &CoverCommandRequest| { &m.has_position },
                |m: &mut CoverCommandRequest| { &mut m.has_position },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "position",
                |m: &CoverCommandRequest| { &m.position },
                |m: &mut CoverCommandRequest| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_tilt",
                |m: &CoverCommandRequest| { &m.has_tilt },
                |m: &mut CoverCommandRequest| { &mut m.has_tilt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tilt",
                |m: &CoverCommandRequest| { &m.tilt },
                |m: &mut CoverCommandRequest| { &mut m.tilt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stop",
                |m: &CoverCommandRequest| { &m.stop },
                |m: &mut CoverCommandRequest| { &mut m.stop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoverCommandRequest>(
                "CoverCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoverCommandRequest {
        static instance: ::protobuf::rt::LazyV2<CoverCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoverCommandRequest::new)
    }
}

impl ::protobuf::Clear for CoverCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.has_legacy_command = false;
        self.legacy_command = LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN;
        self.has_position = false;
        self.position = 0.;
        self.has_tilt = false;
        self.tilt = 0.;
        self.stop = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoverCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesFanResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub supports_oscillation: bool,
    pub supports_speed: bool,
    pub supports_direction: bool,
    pub supported_speed_count: i32,
    pub disabled_by_default: bool,
    pub icon: ::std::string::String,
    pub entity_category: EntityCategory,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesFanResponse {
    fn default() -> &'a ListEntitiesFanResponse {
        <ListEntitiesFanResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesFanResponse {
    pub fn new() -> ListEntitiesFanResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // bool supports_oscillation = 5;


    pub fn get_supports_oscillation(&self) -> bool {
        self.supports_oscillation
    }
    pub fn clear_supports_oscillation(&mut self) {
        self.supports_oscillation = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_oscillation(&mut self, v: bool) {
        self.supports_oscillation = v;
    }

    // bool supports_speed = 6;


    pub fn get_supports_speed(&self) -> bool {
        self.supports_speed
    }
    pub fn clear_supports_speed(&mut self) {
        self.supports_speed = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_speed(&mut self, v: bool) {
        self.supports_speed = v;
    }

    // bool supports_direction = 7;


    pub fn get_supports_direction(&self) -> bool {
        self.supports_direction
    }
    pub fn clear_supports_direction(&mut self) {
        self.supports_direction = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_direction(&mut self, v: bool) {
        self.supports_direction = v;
    }

    // int32 supported_speed_count = 8;


    pub fn get_supported_speed_count(&self) -> i32 {
        self.supported_speed_count
    }
    pub fn clear_supported_speed_count(&mut self) {
        self.supported_speed_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_supported_speed_count(&mut self, v: i32) {
        self.supported_speed_count = v;
    }

    // bool disabled_by_default = 9;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // string icon = 10;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // .EntityCategory entity_category = 11;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }
}

impl ::protobuf::Message for ListEntitiesFanResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_oscillation = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_speed = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_direction = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.supported_speed_count = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.supports_oscillation != false {
            my_size += 2;
        }
        if self.supports_speed != false {
            my_size += 2;
        }
        if self.supports_direction != false {
            my_size += 2;
        }
        if self.supported_speed_count != 0 {
            my_size += ::protobuf::rt::value_size(8, self.supported_speed_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.icon);
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(11, self.entity_category);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.supports_oscillation != false {
            os.write_bool(5, self.supports_oscillation)?;
        }
        if self.supports_speed != false {
            os.write_bool(6, self.supports_speed)?;
        }
        if self.supports_direction != false {
            os.write_bool(7, self.supports_direction)?;
        }
        if self.supported_speed_count != 0 {
            os.write_int32(8, self.supported_speed_count)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(10, &self.icon)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesFanResponse {
        ListEntitiesFanResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesFanResponse| { &m.object_id },
                |m: &mut ListEntitiesFanResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesFanResponse| { &m.key },
                |m: &mut ListEntitiesFanResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesFanResponse| { &m.name },
                |m: &mut ListEntitiesFanResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesFanResponse| { &m.unique_id },
                |m: &mut ListEntitiesFanResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_oscillation",
                |m: &ListEntitiesFanResponse| { &m.supports_oscillation },
                |m: &mut ListEntitiesFanResponse| { &mut m.supports_oscillation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_speed",
                |m: &ListEntitiesFanResponse| { &m.supports_speed },
                |m: &mut ListEntitiesFanResponse| { &mut m.supports_speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_direction",
                |m: &ListEntitiesFanResponse| { &m.supports_direction },
                |m: &mut ListEntitiesFanResponse| { &mut m.supports_direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "supported_speed_count",
                |m: &ListEntitiesFanResponse| { &m.supported_speed_count },
                |m: &mut ListEntitiesFanResponse| { &mut m.supported_speed_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesFanResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesFanResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesFanResponse| { &m.icon },
                |m: &mut ListEntitiesFanResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesFanResponse| { &m.entity_category },
                |m: &mut ListEntitiesFanResponse| { &mut m.entity_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesFanResponse>(
                "ListEntitiesFanResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesFanResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesFanResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesFanResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesFanResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supports_oscillation = false;
        self.supports_speed = false;
        self.supports_direction = false;
        self.supported_speed_count = 0;
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesFanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesFanResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FanStateResponse {
    // message fields
    pub key: u32,
    pub state: bool,
    pub oscillating: bool,
    pub speed: FanSpeed,
    pub direction: FanDirection,
    pub speed_level: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FanStateResponse {
    fn default() -> &'a FanStateResponse {
        <FanStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl FanStateResponse {
    pub fn new() -> FanStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // bool oscillating = 3;


    pub fn get_oscillating(&self) -> bool {
        self.oscillating
    }
    pub fn clear_oscillating(&mut self) {
        self.oscillating = false;
    }

    // Param is passed by value, moved
    pub fn set_oscillating(&mut self, v: bool) {
        self.oscillating = v;
    }

    // .FanSpeed speed = 4;


    pub fn get_speed(&self) -> FanSpeed {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = FanSpeed::FAN_SPEED_LOW;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: FanSpeed) {
        self.speed = v;
    }

    // .FanDirection direction = 5;


    pub fn get_direction(&self) -> FanDirection {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = FanDirection::FAN_DIRECTION_FORWARD;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: FanDirection) {
        self.direction = v;
    }

    // int32 speed_level = 6;


    pub fn get_speed_level(&self) -> i32 {
        self.speed_level
    }
    pub fn clear_speed_level(&mut self) {
        self.speed_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_speed_level(&mut self, v: i32) {
        self.speed_level = v;
    }
}

impl ::protobuf::Message for FanStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.oscillating = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.speed, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.speed_level = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.oscillating != false {
            my_size += 2;
        }
        if self.speed != FanSpeed::FAN_SPEED_LOW {
            my_size += ::protobuf::rt::enum_size(4, self.speed);
        }
        if self.direction != FanDirection::FAN_DIRECTION_FORWARD {
            my_size += ::protobuf::rt::enum_size(5, self.direction);
        }
        if self.speed_level != 0 {
            my_size += ::protobuf::rt::value_size(6, self.speed_level, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.oscillating != false {
            os.write_bool(3, self.oscillating)?;
        }
        if self.speed != FanSpeed::FAN_SPEED_LOW {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.speed))?;
        }
        if self.direction != FanDirection::FAN_DIRECTION_FORWARD {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.direction))?;
        }
        if self.speed_level != 0 {
            os.write_int32(6, self.speed_level)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FanStateResponse {
        FanStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &FanStateResponse| { &m.key },
                |m: &mut FanStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &FanStateResponse| { &m.state },
                |m: &mut FanStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "oscillating",
                |m: &FanStateResponse| { &m.oscillating },
                |m: &mut FanStateResponse| { &mut m.oscillating },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FanSpeed>>(
                "speed",
                |m: &FanStateResponse| { &m.speed },
                |m: &mut FanStateResponse| { &mut m.speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FanDirection>>(
                "direction",
                |m: &FanStateResponse| { &m.direction },
                |m: &mut FanStateResponse| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "speed_level",
                |m: &FanStateResponse| { &m.speed_level },
                |m: &mut FanStateResponse| { &mut m.speed_level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FanStateResponse>(
                "FanStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FanStateResponse {
        static instance: ::protobuf::rt::LazyV2<FanStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FanStateResponse::new)
    }
}

impl ::protobuf::Clear for FanStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.oscillating = false;
        self.speed = FanSpeed::FAN_SPEED_LOW;
        self.direction = FanDirection::FAN_DIRECTION_FORWARD;
        self.speed_level = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FanStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FanStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FanCommandRequest {
    // message fields
    pub key: u32,
    pub has_state: bool,
    pub state: bool,
    pub has_speed: bool,
    pub speed: FanSpeed,
    pub has_oscillating: bool,
    pub oscillating: bool,
    pub has_direction: bool,
    pub direction: FanDirection,
    pub has_speed_level: bool,
    pub speed_level: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FanCommandRequest {
    fn default() -> &'a FanCommandRequest {
        <FanCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl FanCommandRequest {
    pub fn new() -> FanCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool has_state = 2;


    pub fn get_has_state(&self) -> bool {
        self.has_state
    }
    pub fn clear_has_state(&mut self) {
        self.has_state = false;
    }

    // Param is passed by value, moved
    pub fn set_has_state(&mut self, v: bool) {
        self.has_state = v;
    }

    // bool state = 3;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // bool has_speed = 4;


    pub fn get_has_speed(&self) -> bool {
        self.has_speed
    }
    pub fn clear_has_speed(&mut self) {
        self.has_speed = false;
    }

    // Param is passed by value, moved
    pub fn set_has_speed(&mut self, v: bool) {
        self.has_speed = v;
    }

    // .FanSpeed speed = 5;


    pub fn get_speed(&self) -> FanSpeed {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = FanSpeed::FAN_SPEED_LOW;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: FanSpeed) {
        self.speed = v;
    }

    // bool has_oscillating = 6;


    pub fn get_has_oscillating(&self) -> bool {
        self.has_oscillating
    }
    pub fn clear_has_oscillating(&mut self) {
        self.has_oscillating = false;
    }

    // Param is passed by value, moved
    pub fn set_has_oscillating(&mut self, v: bool) {
        self.has_oscillating = v;
    }

    // bool oscillating = 7;


    pub fn get_oscillating(&self) -> bool {
        self.oscillating
    }
    pub fn clear_oscillating(&mut self) {
        self.oscillating = false;
    }

    // Param is passed by value, moved
    pub fn set_oscillating(&mut self, v: bool) {
        self.oscillating = v;
    }

    // bool has_direction = 8;


    pub fn get_has_direction(&self) -> bool {
        self.has_direction
    }
    pub fn clear_has_direction(&mut self) {
        self.has_direction = false;
    }

    // Param is passed by value, moved
    pub fn set_has_direction(&mut self, v: bool) {
        self.has_direction = v;
    }

    // .FanDirection direction = 9;


    pub fn get_direction(&self) -> FanDirection {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = FanDirection::FAN_DIRECTION_FORWARD;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: FanDirection) {
        self.direction = v;
    }

    // bool has_speed_level = 10;


    pub fn get_has_speed_level(&self) -> bool {
        self.has_speed_level
    }
    pub fn clear_has_speed_level(&mut self) {
        self.has_speed_level = false;
    }

    // Param is passed by value, moved
    pub fn set_has_speed_level(&mut self, v: bool) {
        self.has_speed_level = v;
    }

    // int32 speed_level = 11;


    pub fn get_speed_level(&self) -> i32 {
        self.speed_level
    }
    pub fn clear_speed_level(&mut self) {
        self.speed_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_speed_level(&mut self, v: i32) {
        self.speed_level = v;
    }
}

impl ::protobuf::Message for FanCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_speed = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.speed, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_oscillating = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.oscillating = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_direction = tmp;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 9, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_speed_level = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.speed_level = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.has_state != false {
            my_size += 2;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.has_speed != false {
            my_size += 2;
        }
        if self.speed != FanSpeed::FAN_SPEED_LOW {
            my_size += ::protobuf::rt::enum_size(5, self.speed);
        }
        if self.has_oscillating != false {
            my_size += 2;
        }
        if self.oscillating != false {
            my_size += 2;
        }
        if self.has_direction != false {
            my_size += 2;
        }
        if self.direction != FanDirection::FAN_DIRECTION_FORWARD {
            my_size += ::protobuf::rt::enum_size(9, self.direction);
        }
        if self.has_speed_level != false {
            my_size += 2;
        }
        if self.speed_level != 0 {
            my_size += ::protobuf::rt::value_size(11, self.speed_level, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_state != false {
            os.write_bool(2, self.has_state)?;
        }
        if self.state != false {
            os.write_bool(3, self.state)?;
        }
        if self.has_speed != false {
            os.write_bool(4, self.has_speed)?;
        }
        if self.speed != FanSpeed::FAN_SPEED_LOW {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.speed))?;
        }
        if self.has_oscillating != false {
            os.write_bool(6, self.has_oscillating)?;
        }
        if self.oscillating != false {
            os.write_bool(7, self.oscillating)?;
        }
        if self.has_direction != false {
            os.write_bool(8, self.has_direction)?;
        }
        if self.direction != FanDirection::FAN_DIRECTION_FORWARD {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.direction))?;
        }
        if self.has_speed_level != false {
            os.write_bool(10, self.has_speed_level)?;
        }
        if self.speed_level != 0 {
            os.write_int32(11, self.speed_level)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FanCommandRequest {
        FanCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &FanCommandRequest| { &m.key },
                |m: &mut FanCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_state",
                |m: &FanCommandRequest| { &m.has_state },
                |m: &mut FanCommandRequest| { &mut m.has_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &FanCommandRequest| { &m.state },
                |m: &mut FanCommandRequest| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_speed",
                |m: &FanCommandRequest| { &m.has_speed },
                |m: &mut FanCommandRequest| { &mut m.has_speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FanSpeed>>(
                "speed",
                |m: &FanCommandRequest| { &m.speed },
                |m: &mut FanCommandRequest| { &mut m.speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_oscillating",
                |m: &FanCommandRequest| { &m.has_oscillating },
                |m: &mut FanCommandRequest| { &mut m.has_oscillating },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "oscillating",
                |m: &FanCommandRequest| { &m.oscillating },
                |m: &mut FanCommandRequest| { &mut m.oscillating },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_direction",
                |m: &FanCommandRequest| { &m.has_direction },
                |m: &mut FanCommandRequest| { &mut m.has_direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FanDirection>>(
                "direction",
                |m: &FanCommandRequest| { &m.direction },
                |m: &mut FanCommandRequest| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_speed_level",
                |m: &FanCommandRequest| { &m.has_speed_level },
                |m: &mut FanCommandRequest| { &mut m.has_speed_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "speed_level",
                |m: &FanCommandRequest| { &m.speed_level },
                |m: &mut FanCommandRequest| { &mut m.speed_level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FanCommandRequest>(
                "FanCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FanCommandRequest {
        static instance: ::protobuf::rt::LazyV2<FanCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FanCommandRequest::new)
    }
}

impl ::protobuf::Clear for FanCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.has_state = false;
        self.state = false;
        self.has_speed = false;
        self.speed = FanSpeed::FAN_SPEED_LOW;
        self.has_oscillating = false;
        self.oscillating = false;
        self.has_direction = false;
        self.direction = FanDirection::FAN_DIRECTION_FORWARD;
        self.has_speed_level = false;
        self.speed_level = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FanCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FanCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesLightResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub supported_color_modes: ::std::vec::Vec<ColorMode>,
    pub legacy_supports_brightness: bool,
    pub legacy_supports_rgb: bool,
    pub legacy_supports_white_value: bool,
    pub legacy_supports_color_temperature: bool,
    pub min_mireds: f32,
    pub max_mireds: f32,
    pub effects: ::protobuf::RepeatedField<::std::string::String>,
    pub disabled_by_default: bool,
    pub icon: ::std::string::String,
    pub entity_category: EntityCategory,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesLightResponse {
    fn default() -> &'a ListEntitiesLightResponse {
        <ListEntitiesLightResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesLightResponse {
    pub fn new() -> ListEntitiesLightResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // repeated .ColorMode supported_color_modes = 12;


    pub fn get_supported_color_modes(&self) -> &[ColorMode] {
        &self.supported_color_modes
    }
    pub fn clear_supported_color_modes(&mut self) {
        self.supported_color_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_color_modes(&mut self, v: ::std::vec::Vec<ColorMode>) {
        self.supported_color_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_color_modes(&mut self) -> &mut ::std::vec::Vec<ColorMode> {
        &mut self.supported_color_modes
    }

    // Take field
    pub fn take_supported_color_modes(&mut self) -> ::std::vec::Vec<ColorMode> {
        ::std::mem::replace(&mut self.supported_color_modes, ::std::vec::Vec::new())
    }

    // bool legacy_supports_brightness = 5;


    pub fn get_legacy_supports_brightness(&self) -> bool {
        self.legacy_supports_brightness
    }
    pub fn clear_legacy_supports_brightness(&mut self) {
        self.legacy_supports_brightness = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_brightness(&mut self, v: bool) {
        self.legacy_supports_brightness = v;
    }

    // bool legacy_supports_rgb = 6;


    pub fn get_legacy_supports_rgb(&self) -> bool {
        self.legacy_supports_rgb
    }
    pub fn clear_legacy_supports_rgb(&mut self) {
        self.legacy_supports_rgb = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_rgb(&mut self, v: bool) {
        self.legacy_supports_rgb = v;
    }

    // bool legacy_supports_white_value = 7;


    pub fn get_legacy_supports_white_value(&self) -> bool {
        self.legacy_supports_white_value
    }
    pub fn clear_legacy_supports_white_value(&mut self) {
        self.legacy_supports_white_value = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_white_value(&mut self, v: bool) {
        self.legacy_supports_white_value = v;
    }

    // bool legacy_supports_color_temperature = 8;


    pub fn get_legacy_supports_color_temperature(&self) -> bool {
        self.legacy_supports_color_temperature
    }
    pub fn clear_legacy_supports_color_temperature(&mut self) {
        self.legacy_supports_color_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_color_temperature(&mut self, v: bool) {
        self.legacy_supports_color_temperature = v;
    }

    // float min_mireds = 9;


    pub fn get_min_mireds(&self) -> f32 {
        self.min_mireds
    }
    pub fn clear_min_mireds(&mut self) {
        self.min_mireds = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_mireds(&mut self, v: f32) {
        self.min_mireds = v;
    }

    // float max_mireds = 10;


    pub fn get_max_mireds(&self) -> f32 {
        self.max_mireds
    }
    pub fn clear_max_mireds(&mut self) {
        self.max_mireds = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_mireds(&mut self, v: f32) {
        self.max_mireds = v;
    }

    // repeated string effects = 11;


    pub fn get_effects(&self) -> &[::std::string::String] {
        &self.effects
    }
    pub fn clear_effects(&mut self) {
        self.effects.clear();
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.effects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_effects(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.effects
    }

    // Take field
    pub fn take_effects(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.effects, ::protobuf::RepeatedField::new())
    }

    // bool disabled_by_default = 13;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // string icon = 14;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // .EntityCategory entity_category = 15;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }
}

impl ::protobuf::Message for ListEntitiesLightResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_color_modes, 12, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_brightness = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_rgb = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_white_value = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_color_temperature = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min_mireds = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_mireds = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.effects)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                15 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 15, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        for value in &self.supported_color_modes {
            my_size += ::protobuf::rt::enum_size(12, *value);
        };
        if self.legacy_supports_brightness != false {
            my_size += 2;
        }
        if self.legacy_supports_rgb != false {
            my_size += 2;
        }
        if self.legacy_supports_white_value != false {
            my_size += 2;
        }
        if self.legacy_supports_color_temperature != false {
            my_size += 2;
        }
        if self.min_mireds != 0. {
            my_size += 5;
        }
        if self.max_mireds != 0. {
            my_size += 5;
        }
        for value in &self.effects {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.icon);
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(15, self.entity_category);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        for v in &self.supported_color_modes {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.legacy_supports_brightness != false {
            os.write_bool(5, self.legacy_supports_brightness)?;
        }
        if self.legacy_supports_rgb != false {
            os.write_bool(6, self.legacy_supports_rgb)?;
        }
        if self.legacy_supports_white_value != false {
            os.write_bool(7, self.legacy_supports_white_value)?;
        }
        if self.legacy_supports_color_temperature != false {
            os.write_bool(8, self.legacy_supports_color_temperature)?;
        }
        if self.min_mireds != 0. {
            os.write_float(9, self.min_mireds)?;
        }
        if self.max_mireds != 0. {
            os.write_float(10, self.max_mireds)?;
        }
        for v in &self.effects {
            os.write_string(11, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(13, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(14, &self.icon)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(15, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesLightResponse {
        ListEntitiesLightResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesLightResponse| { &m.object_id },
                |m: &mut ListEntitiesLightResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesLightResponse| { &m.key },
                |m: &mut ListEntitiesLightResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesLightResponse| { &m.name },
                |m: &mut ListEntitiesLightResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesLightResponse| { &m.unique_id },
                |m: &mut ListEntitiesLightResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ColorMode>>(
                "supported_color_modes",
                |m: &ListEntitiesLightResponse| { &m.supported_color_modes },
                |m: &mut ListEntitiesLightResponse| { &mut m.supported_color_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_brightness",
                |m: &ListEntitiesLightResponse| { &m.legacy_supports_brightness },
                |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_rgb",
                |m: &ListEntitiesLightResponse| { &m.legacy_supports_rgb },
                |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_rgb },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_white_value",
                |m: &ListEntitiesLightResponse| { &m.legacy_supports_white_value },
                |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_white_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_color_temperature",
                |m: &ListEntitiesLightResponse| { &m.legacy_supports_color_temperature },
                |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_color_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "min_mireds",
                |m: &ListEntitiesLightResponse| { &m.min_mireds },
                |m: &mut ListEntitiesLightResponse| { &mut m.min_mireds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max_mireds",
                |m: &ListEntitiesLightResponse| { &m.max_mireds },
                |m: &mut ListEntitiesLightResponse| { &mut m.max_mireds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effects",
                |m: &ListEntitiesLightResponse| { &m.effects },
                |m: &mut ListEntitiesLightResponse| { &mut m.effects },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesLightResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesLightResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesLightResponse| { &m.icon },
                |m: &mut ListEntitiesLightResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesLightResponse| { &m.entity_category },
                |m: &mut ListEntitiesLightResponse| { &mut m.entity_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesLightResponse>(
                "ListEntitiesLightResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesLightResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesLightResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesLightResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesLightResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supported_color_modes.clear();
        self.legacy_supports_brightness = false;
        self.legacy_supports_rgb = false;
        self.legacy_supports_white_value = false;
        self.legacy_supports_color_temperature = false;
        self.min_mireds = 0.;
        self.max_mireds = 0.;
        self.effects.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesLightResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesLightResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LightStateResponse {
    // message fields
    pub key: u32,
    pub state: bool,
    pub brightness: f32,
    pub color_mode: ColorMode,
    pub color_brightness: f32,
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub white: f32,
    pub color_temperature: f32,
    pub cold_white: f32,
    pub warm_white: f32,
    pub effect: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightStateResponse {
    fn default() -> &'a LightStateResponse {
        <LightStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl LightStateResponse {
    pub fn new() -> LightStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // float brightness = 3;


    pub fn get_brightness(&self) -> f32 {
        self.brightness
    }
    pub fn clear_brightness(&mut self) {
        self.brightness = 0.;
    }

    // Param is passed by value, moved
    pub fn set_brightness(&mut self, v: f32) {
        self.brightness = v;
    }

    // .ColorMode color_mode = 11;


    pub fn get_color_mode(&self) -> ColorMode {
        self.color_mode
    }
    pub fn clear_color_mode(&mut self) {
        self.color_mode = ColorMode::COLOR_MODE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_color_mode(&mut self, v: ColorMode) {
        self.color_mode = v;
    }

    // float color_brightness = 10;


    pub fn get_color_brightness(&self) -> f32 {
        self.color_brightness
    }
    pub fn clear_color_brightness(&mut self) {
        self.color_brightness = 0.;
    }

    // Param is passed by value, moved
    pub fn set_color_brightness(&mut self, v: f32) {
        self.color_brightness = v;
    }

    // float red = 4;


    pub fn get_red(&self) -> f32 {
        self.red
    }
    pub fn clear_red(&mut self) {
        self.red = 0.;
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: f32) {
        self.red = v;
    }

    // float green = 5;


    pub fn get_green(&self) -> f32 {
        self.green
    }
    pub fn clear_green(&mut self) {
        self.green = 0.;
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: f32) {
        self.green = v;
    }

    // float blue = 6;


    pub fn get_blue(&self) -> f32 {
        self.blue
    }
    pub fn clear_blue(&mut self) {
        self.blue = 0.;
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: f32) {
        self.blue = v;
    }

    // float white = 7;


    pub fn get_white(&self) -> f32 {
        self.white
    }
    pub fn clear_white(&mut self) {
        self.white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_white(&mut self, v: f32) {
        self.white = v;
    }

    // float color_temperature = 8;


    pub fn get_color_temperature(&self) -> f32 {
        self.color_temperature
    }
    pub fn clear_color_temperature(&mut self) {
        self.color_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_color_temperature(&mut self, v: f32) {
        self.color_temperature = v;
    }

    // float cold_white = 12;


    pub fn get_cold_white(&self) -> f32 {
        self.cold_white
    }
    pub fn clear_cold_white(&mut self) {
        self.cold_white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cold_white(&mut self, v: f32) {
        self.cold_white = v;
    }

    // float warm_white = 13;


    pub fn get_warm_white(&self) -> f32 {
        self.warm_white
    }
    pub fn clear_warm_white(&mut self) {
        self.warm_white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_warm_white(&mut self, v: f32) {
        self.warm_white = v;
    }

    // string effect = 9;


    pub fn get_effect(&self) -> &str {
        &self.effect
    }
    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        &mut self.effect
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.effect, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LightStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.brightness = tmp;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.color_mode, 11, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.color_brightness = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.red = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.green = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.blue = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.white = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.color_temperature = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cold_white = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.warm_white = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.effect)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.brightness != 0. {
            my_size += 5;
        }
        if self.color_mode != ColorMode::COLOR_MODE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(11, self.color_mode);
        }
        if self.color_brightness != 0. {
            my_size += 5;
        }
        if self.red != 0. {
            my_size += 5;
        }
        if self.green != 0. {
            my_size += 5;
        }
        if self.blue != 0. {
            my_size += 5;
        }
        if self.white != 0. {
            my_size += 5;
        }
        if self.color_temperature != 0. {
            my_size += 5;
        }
        if self.cold_white != 0. {
            my_size += 5;
        }
        if self.warm_white != 0. {
            my_size += 5;
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.effect);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.brightness != 0. {
            os.write_float(3, self.brightness)?;
        }
        if self.color_mode != ColorMode::COLOR_MODE_UNKNOWN {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.color_mode))?;
        }
        if self.color_brightness != 0. {
            os.write_float(10, self.color_brightness)?;
        }
        if self.red != 0. {
            os.write_float(4, self.red)?;
        }
        if self.green != 0. {
            os.write_float(5, self.green)?;
        }
        if self.blue != 0. {
            os.write_float(6, self.blue)?;
        }
        if self.white != 0. {
            os.write_float(7, self.white)?;
        }
        if self.color_temperature != 0. {
            os.write_float(8, self.color_temperature)?;
        }
        if self.cold_white != 0. {
            os.write_float(12, self.cold_white)?;
        }
        if self.warm_white != 0. {
            os.write_float(13, self.warm_white)?;
        }
        if !self.effect.is_empty() {
            os.write_string(9, &self.effect)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightStateResponse {
        LightStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &LightStateResponse| { &m.key },
                |m: &mut LightStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &LightStateResponse| { &m.state },
                |m: &mut LightStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "brightness",
                |m: &LightStateResponse| { &m.brightness },
                |m: &mut LightStateResponse| { &mut m.brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ColorMode>>(
                "color_mode",
                |m: &LightStateResponse| { &m.color_mode },
                |m: &mut LightStateResponse| { &mut m.color_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "color_brightness",
                |m: &LightStateResponse| { &m.color_brightness },
                |m: &mut LightStateResponse| { &mut m.color_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "red",
                |m: &LightStateResponse| { &m.red },
                |m: &mut LightStateResponse| { &mut m.red },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "green",
                |m: &LightStateResponse| { &m.green },
                |m: &mut LightStateResponse| { &mut m.green },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "blue",
                |m: &LightStateResponse| { &m.blue },
                |m: &mut LightStateResponse| { &mut m.blue },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "white",
                |m: &LightStateResponse| { &m.white },
                |m: &mut LightStateResponse| { &mut m.white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "color_temperature",
                |m: &LightStateResponse| { &m.color_temperature },
                |m: &mut LightStateResponse| { &mut m.color_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cold_white",
                |m: &LightStateResponse| { &m.cold_white },
                |m: &mut LightStateResponse| { &mut m.cold_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "warm_white",
                |m: &LightStateResponse| { &m.warm_white },
                |m: &mut LightStateResponse| { &mut m.warm_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effect",
                |m: &LightStateResponse| { &m.effect },
                |m: &mut LightStateResponse| { &mut m.effect },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LightStateResponse>(
                "LightStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LightStateResponse {
        static instance: ::protobuf::rt::LazyV2<LightStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LightStateResponse::new)
    }
}

impl ::protobuf::Clear for LightStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.brightness = 0.;
        self.color_mode = ColorMode::COLOR_MODE_UNKNOWN;
        self.color_brightness = 0.;
        self.red = 0.;
        self.green = 0.;
        self.blue = 0.;
        self.white = 0.;
        self.color_temperature = 0.;
        self.cold_white = 0.;
        self.warm_white = 0.;
        self.effect.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LightCommandRequest {
    // message fields
    pub key: u32,
    pub has_state: bool,
    pub state: bool,
    pub has_brightness: bool,
    pub brightness: f32,
    pub has_color_mode: bool,
    pub color_mode: ColorMode,
    pub has_color_brightness: bool,
    pub color_brightness: f32,
    pub has_rgb: bool,
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub has_white: bool,
    pub white: f32,
    pub has_color_temperature: bool,
    pub color_temperature: f32,
    pub has_cold_white: bool,
    pub cold_white: f32,
    pub has_warm_white: bool,
    pub warm_white: f32,
    pub has_transition_length: bool,
    pub transition_length: u32,
    pub has_flash_length: bool,
    pub flash_length: u32,
    pub has_effect: bool,
    pub effect: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightCommandRequest {
    fn default() -> &'a LightCommandRequest {
        <LightCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl LightCommandRequest {
    pub fn new() -> LightCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool has_state = 2;


    pub fn get_has_state(&self) -> bool {
        self.has_state
    }
    pub fn clear_has_state(&mut self) {
        self.has_state = false;
    }

    // Param is passed by value, moved
    pub fn set_has_state(&mut self, v: bool) {
        self.has_state = v;
    }

    // bool state = 3;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // bool has_brightness = 4;


    pub fn get_has_brightness(&self) -> bool {
        self.has_brightness
    }
    pub fn clear_has_brightness(&mut self) {
        self.has_brightness = false;
    }

    // Param is passed by value, moved
    pub fn set_has_brightness(&mut self, v: bool) {
        self.has_brightness = v;
    }

    // float brightness = 5;


    pub fn get_brightness(&self) -> f32 {
        self.brightness
    }
    pub fn clear_brightness(&mut self) {
        self.brightness = 0.;
    }

    // Param is passed by value, moved
    pub fn set_brightness(&mut self, v: f32) {
        self.brightness = v;
    }

    // bool has_color_mode = 22;


    pub fn get_has_color_mode(&self) -> bool {
        self.has_color_mode
    }
    pub fn clear_has_color_mode(&mut self) {
        self.has_color_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_color_mode(&mut self, v: bool) {
        self.has_color_mode = v;
    }

    // .ColorMode color_mode = 23;


    pub fn get_color_mode(&self) -> ColorMode {
        self.color_mode
    }
    pub fn clear_color_mode(&mut self) {
        self.color_mode = ColorMode::COLOR_MODE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_color_mode(&mut self, v: ColorMode) {
        self.color_mode = v;
    }

    // bool has_color_brightness = 20;


    pub fn get_has_color_brightness(&self) -> bool {
        self.has_color_brightness
    }
    pub fn clear_has_color_brightness(&mut self) {
        self.has_color_brightness = false;
    }

    // Param is passed by value, moved
    pub fn set_has_color_brightness(&mut self, v: bool) {
        self.has_color_brightness = v;
    }

    // float color_brightness = 21;


    pub fn get_color_brightness(&self) -> f32 {
        self.color_brightness
    }
    pub fn clear_color_brightness(&mut self) {
        self.color_brightness = 0.;
    }

    // Param is passed by value, moved
    pub fn set_color_brightness(&mut self, v: f32) {
        self.color_brightness = v;
    }

    // bool has_rgb = 6;


    pub fn get_has_rgb(&self) -> bool {
        self.has_rgb
    }
    pub fn clear_has_rgb(&mut self) {
        self.has_rgb = false;
    }

    // Param is passed by value, moved
    pub fn set_has_rgb(&mut self, v: bool) {
        self.has_rgb = v;
    }

    // float red = 7;


    pub fn get_red(&self) -> f32 {
        self.red
    }
    pub fn clear_red(&mut self) {
        self.red = 0.;
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: f32) {
        self.red = v;
    }

    // float green = 8;


    pub fn get_green(&self) -> f32 {
        self.green
    }
    pub fn clear_green(&mut self) {
        self.green = 0.;
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: f32) {
        self.green = v;
    }

    // float blue = 9;


    pub fn get_blue(&self) -> f32 {
        self.blue
    }
    pub fn clear_blue(&mut self) {
        self.blue = 0.;
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: f32) {
        self.blue = v;
    }

    // bool has_white = 10;


    pub fn get_has_white(&self) -> bool {
        self.has_white
    }
    pub fn clear_has_white(&mut self) {
        self.has_white = false;
    }

    // Param is passed by value, moved
    pub fn set_has_white(&mut self, v: bool) {
        self.has_white = v;
    }

    // float white = 11;


    pub fn get_white(&self) -> f32 {
        self.white
    }
    pub fn clear_white(&mut self) {
        self.white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_white(&mut self, v: f32) {
        self.white = v;
    }

    // bool has_color_temperature = 12;


    pub fn get_has_color_temperature(&self) -> bool {
        self.has_color_temperature
    }
    pub fn clear_has_color_temperature(&mut self) {
        self.has_color_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_has_color_temperature(&mut self, v: bool) {
        self.has_color_temperature = v;
    }

    // float color_temperature = 13;


    pub fn get_color_temperature(&self) -> f32 {
        self.color_temperature
    }
    pub fn clear_color_temperature(&mut self) {
        self.color_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_color_temperature(&mut self, v: f32) {
        self.color_temperature = v;
    }

    // bool has_cold_white = 24;


    pub fn get_has_cold_white(&self) -> bool {
        self.has_cold_white
    }
    pub fn clear_has_cold_white(&mut self) {
        self.has_cold_white = false;
    }

    // Param is passed by value, moved
    pub fn set_has_cold_white(&mut self, v: bool) {
        self.has_cold_white = v;
    }

    // float cold_white = 25;


    pub fn get_cold_white(&self) -> f32 {
        self.cold_white
    }
    pub fn clear_cold_white(&mut self) {
        self.cold_white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cold_white(&mut self, v: f32) {
        self.cold_white = v;
    }

    // bool has_warm_white = 26;


    pub fn get_has_warm_white(&self) -> bool {
        self.has_warm_white
    }
    pub fn clear_has_warm_white(&mut self) {
        self.has_warm_white = false;
    }

    // Param is passed by value, moved
    pub fn set_has_warm_white(&mut self, v: bool) {
        self.has_warm_white = v;
    }

    // float warm_white = 27;


    pub fn get_warm_white(&self) -> f32 {
        self.warm_white
    }
    pub fn clear_warm_white(&mut self) {
        self.warm_white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_warm_white(&mut self, v: f32) {
        self.warm_white = v;
    }

    // bool has_transition_length = 14;


    pub fn get_has_transition_length(&self) -> bool {
        self.has_transition_length
    }
    pub fn clear_has_transition_length(&mut self) {
        self.has_transition_length = false;
    }

    // Param is passed by value, moved
    pub fn set_has_transition_length(&mut self, v: bool) {
        self.has_transition_length = v;
    }

    // uint32 transition_length = 15;


    pub fn get_transition_length(&self) -> u32 {
        self.transition_length
    }
    pub fn clear_transition_length(&mut self) {
        self.transition_length = 0;
    }

    // Param is passed by value, moved
    pub fn set_transition_length(&mut self, v: u32) {
        self.transition_length = v;
    }

    // bool has_flash_length = 16;


    pub fn get_has_flash_length(&self) -> bool {
        self.has_flash_length
    }
    pub fn clear_has_flash_length(&mut self) {
        self.has_flash_length = false;
    }

    // Param is passed by value, moved
    pub fn set_has_flash_length(&mut self, v: bool) {
        self.has_flash_length = v;
    }

    // uint32 flash_length = 17;


    pub fn get_flash_length(&self) -> u32 {
        self.flash_length
    }
    pub fn clear_flash_length(&mut self) {
        self.flash_length = 0;
    }

    // Param is passed by value, moved
    pub fn set_flash_length(&mut self, v: u32) {
        self.flash_length = v;
    }

    // bool has_effect = 18;


    pub fn get_has_effect(&self) -> bool {
        self.has_effect
    }
    pub fn clear_has_effect(&mut self) {
        self.has_effect = false;
    }

    // Param is passed by value, moved
    pub fn set_has_effect(&mut self, v: bool) {
        self.has_effect = v;
    }

    // string effect = 19;


    pub fn get_effect(&self) -> &str {
        &self.effect
    }
    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        &mut self.effect
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.effect, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LightCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_brightness = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.brightness = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_color_mode = tmp;
                },
                23 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.color_mode, 23, &mut self.unknown_fields)?
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_color_brightness = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.color_brightness = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_rgb = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.red = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.green = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.blue = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_white = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.white = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_color_temperature = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.color_temperature = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_cold_white = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cold_white = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_warm_white = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.warm_white = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_transition_length = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.transition_length = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_flash_length = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flash_length = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_effect = tmp;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.effect)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.has_state != false {
            my_size += 2;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.has_brightness != false {
            my_size += 2;
        }
        if self.brightness != 0. {
            my_size += 5;
        }
        if self.has_color_mode != false {
            my_size += 3;
        }
        if self.color_mode != ColorMode::COLOR_MODE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(23, self.color_mode);
        }
        if self.has_color_brightness != false {
            my_size += 3;
        }
        if self.color_brightness != 0. {
            my_size += 6;
        }
        if self.has_rgb != false {
            my_size += 2;
        }
        if self.red != 0. {
            my_size += 5;
        }
        if self.green != 0. {
            my_size += 5;
        }
        if self.blue != 0. {
            my_size += 5;
        }
        if self.has_white != false {
            my_size += 2;
        }
        if self.white != 0. {
            my_size += 5;
        }
        if self.has_color_temperature != false {
            my_size += 2;
        }
        if self.color_temperature != 0. {
            my_size += 5;
        }
        if self.has_cold_white != false {
            my_size += 3;
        }
        if self.cold_white != 0. {
            my_size += 6;
        }
        if self.has_warm_white != false {
            my_size += 3;
        }
        if self.warm_white != 0. {
            my_size += 6;
        }
        if self.has_transition_length != false {
            my_size += 2;
        }
        if self.transition_length != 0 {
            my_size += ::protobuf::rt::value_size(15, self.transition_length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.has_flash_length != false {
            my_size += 3;
        }
        if self.flash_length != 0 {
            my_size += ::protobuf::rt::value_size(17, self.flash_length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.has_effect != false {
            my_size += 3;
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.effect);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_state != false {
            os.write_bool(2, self.has_state)?;
        }
        if self.state != false {
            os.write_bool(3, self.state)?;
        }
        if self.has_brightness != false {
            os.write_bool(4, self.has_brightness)?;
        }
        if self.brightness != 0. {
            os.write_float(5, self.brightness)?;
        }
        if self.has_color_mode != false {
            os.write_bool(22, self.has_color_mode)?;
        }
        if self.color_mode != ColorMode::COLOR_MODE_UNKNOWN {
            os.write_enum(23, ::protobuf::ProtobufEnum::value(&self.color_mode))?;
        }
        if self.has_color_brightness != false {
            os.write_bool(20, self.has_color_brightness)?;
        }
        if self.color_brightness != 0. {
            os.write_float(21, self.color_brightness)?;
        }
        if self.has_rgb != false {
            os.write_bool(6, self.has_rgb)?;
        }
        if self.red != 0. {
            os.write_float(7, self.red)?;
        }
        if self.green != 0. {
            os.write_float(8, self.green)?;
        }
        if self.blue != 0. {
            os.write_float(9, self.blue)?;
        }
        if self.has_white != false {
            os.write_bool(10, self.has_white)?;
        }
        if self.white != 0. {
            os.write_float(11, self.white)?;
        }
        if self.has_color_temperature != false {
            os.write_bool(12, self.has_color_temperature)?;
        }
        if self.color_temperature != 0. {
            os.write_float(13, self.color_temperature)?;
        }
        if self.has_cold_white != false {
            os.write_bool(24, self.has_cold_white)?;
        }
        if self.cold_white != 0. {
            os.write_float(25, self.cold_white)?;
        }
        if self.has_warm_white != false {
            os.write_bool(26, self.has_warm_white)?;
        }
        if self.warm_white != 0. {
            os.write_float(27, self.warm_white)?;
        }
        if self.has_transition_length != false {
            os.write_bool(14, self.has_transition_length)?;
        }
        if self.transition_length != 0 {
            os.write_uint32(15, self.transition_length)?;
        }
        if self.has_flash_length != false {
            os.write_bool(16, self.has_flash_length)?;
        }
        if self.flash_length != 0 {
            os.write_uint32(17, self.flash_length)?;
        }
        if self.has_effect != false {
            os.write_bool(18, self.has_effect)?;
        }
        if !self.effect.is_empty() {
            os.write_string(19, &self.effect)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightCommandRequest {
        LightCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &LightCommandRequest| { &m.key },
                |m: &mut LightCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_state",
                |m: &LightCommandRequest| { &m.has_state },
                |m: &mut LightCommandRequest| { &mut m.has_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &LightCommandRequest| { &m.state },
                |m: &mut LightCommandRequest| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_brightness",
                |m: &LightCommandRequest| { &m.has_brightness },
                |m: &mut LightCommandRequest| { &mut m.has_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "brightness",
                |m: &LightCommandRequest| { &m.brightness },
                |m: &mut LightCommandRequest| { &mut m.brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_color_mode",
                |m: &LightCommandRequest| { &m.has_color_mode },
                |m: &mut LightCommandRequest| { &mut m.has_color_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ColorMode>>(
                "color_mode",
                |m: &LightCommandRequest| { &m.color_mode },
                |m: &mut LightCommandRequest| { &mut m.color_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_color_brightness",
                |m: &LightCommandRequest| { &m.has_color_brightness },
                |m: &mut LightCommandRequest| { &mut m.has_color_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "color_brightness",
                |m: &LightCommandRequest| { &m.color_brightness },
                |m: &mut LightCommandRequest| { &mut m.color_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_rgb",
                |m: &LightCommandRequest| { &m.has_rgb },
                |m: &mut LightCommandRequest| { &mut m.has_rgb },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "red",
                |m: &LightCommandRequest| { &m.red },
                |m: &mut LightCommandRequest| { &mut m.red },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "green",
                |m: &LightCommandRequest| { &m.green },
                |m: &mut LightCommandRequest| { &mut m.green },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "blue",
                |m: &LightCommandRequest| { &m.blue },
                |m: &mut LightCommandRequest| { &mut m.blue },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_white",
                |m: &LightCommandRequest| { &m.has_white },
                |m: &mut LightCommandRequest| { &mut m.has_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "white",
                |m: &LightCommandRequest| { &m.white },
                |m: &mut LightCommandRequest| { &mut m.white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_color_temperature",
                |m: &LightCommandRequest| { &m.has_color_temperature },
                |m: &mut LightCommandRequest| { &mut m.has_color_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "color_temperature",
                |m: &LightCommandRequest| { &m.color_temperature },
                |m: &mut LightCommandRequest| { &mut m.color_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_cold_white",
                |m: &LightCommandRequest| { &m.has_cold_white },
                |m: &mut LightCommandRequest| { &mut m.has_cold_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cold_white",
                |m: &LightCommandRequest| { &m.cold_white },
                |m: &mut LightCommandRequest| { &mut m.cold_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_warm_white",
                |m: &LightCommandRequest| { &m.has_warm_white },
                |m: &mut LightCommandRequest| { &mut m.has_warm_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "warm_white",
                |m: &LightCommandRequest| { &m.warm_white },
                |m: &mut LightCommandRequest| { &mut m.warm_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_transition_length",
                |m: &LightCommandRequest| { &m.has_transition_length },
                |m: &mut LightCommandRequest| { &mut m.has_transition_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "transition_length",
                |m: &LightCommandRequest| { &m.transition_length },
                |m: &mut LightCommandRequest| { &mut m.transition_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_flash_length",
                |m: &LightCommandRequest| { &m.has_flash_length },
                |m: &mut LightCommandRequest| { &mut m.has_flash_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flash_length",
                |m: &LightCommandRequest| { &m.flash_length },
                |m: &mut LightCommandRequest| { &mut m.flash_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_effect",
                |m: &LightCommandRequest| { &m.has_effect },
                |m: &mut LightCommandRequest| { &mut m.has_effect },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effect",
                |m: &LightCommandRequest| { &m.effect },
                |m: &mut LightCommandRequest| { &mut m.effect },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LightCommandRequest>(
                "LightCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LightCommandRequest {
        static instance: ::protobuf::rt::LazyV2<LightCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LightCommandRequest::new)
    }
}

impl ::protobuf::Clear for LightCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.has_state = false;
        self.state = false;
        self.has_brightness = false;
        self.brightness = 0.;
        self.has_color_mode = false;
        self.color_mode = ColorMode::COLOR_MODE_UNKNOWN;
        self.has_color_brightness = false;
        self.color_brightness = 0.;
        self.has_rgb = false;
        self.red = 0.;
        self.green = 0.;
        self.blue = 0.;
        self.has_white = false;
        self.white = 0.;
        self.has_color_temperature = false;
        self.color_temperature = 0.;
        self.has_cold_white = false;
        self.cold_white = 0.;
        self.has_warm_white = false;
        self.warm_white = 0.;
        self.has_transition_length = false;
        self.transition_length = 0;
        self.has_flash_length = false;
        self.flash_length = 0;
        self.has_effect = false;
        self.effect.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesSensorResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub unit_of_measurement: ::std::string::String,
    pub accuracy_decimals: i32,
    pub force_update: bool,
    pub device_class: ::std::string::String,
    pub state_class: SensorStateClass,
    pub legacy_last_reset_type: SensorLastResetType,
    pub disabled_by_default: bool,
    pub entity_category: EntityCategory,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSensorResponse {
    fn default() -> &'a ListEntitiesSensorResponse {
        <ListEntitiesSensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSensorResponse {
    pub fn new() -> ListEntitiesSensorResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // string unit_of_measurement = 6;


    pub fn get_unit_of_measurement(&self) -> &str {
        &self.unit_of_measurement
    }
    pub fn clear_unit_of_measurement(&mut self) {
        self.unit_of_measurement.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_of_measurement(&mut self, v: ::std::string::String) {
        self.unit_of_measurement = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_of_measurement(&mut self) -> &mut ::std::string::String {
        &mut self.unit_of_measurement
    }

    // Take field
    pub fn take_unit_of_measurement(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unit_of_measurement, ::std::string::String::new())
    }

    // int32 accuracy_decimals = 7;


    pub fn get_accuracy_decimals(&self) -> i32 {
        self.accuracy_decimals
    }
    pub fn clear_accuracy_decimals(&mut self) {
        self.accuracy_decimals = 0;
    }

    // Param is passed by value, moved
    pub fn set_accuracy_decimals(&mut self, v: i32) {
        self.accuracy_decimals = v;
    }

    // bool force_update = 8;


    pub fn get_force_update(&self) -> bool {
        self.force_update
    }
    pub fn clear_force_update(&mut self) {
        self.force_update = false;
    }

    // Param is passed by value, moved
    pub fn set_force_update(&mut self, v: bool) {
        self.force_update = v;
    }

    // string device_class = 9;


    pub fn get_device_class(&self) -> &str {
        &self.device_class
    }
    pub fn clear_device_class(&mut self) {
        self.device_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_class(&mut self, v: ::std::string::String) {
        self.device_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_class(&mut self) -> &mut ::std::string::String {
        &mut self.device_class
    }

    // Take field
    pub fn take_device_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_class, ::std::string::String::new())
    }

    // .SensorStateClass state_class = 10;


    pub fn get_state_class(&self) -> SensorStateClass {
        self.state_class
    }
    pub fn clear_state_class(&mut self) {
        self.state_class = SensorStateClass::STATE_CLASS_NONE;
    }

    // Param is passed by value, moved
    pub fn set_state_class(&mut self, v: SensorStateClass) {
        self.state_class = v;
    }

    // .SensorLastResetType legacy_last_reset_type = 11;


    pub fn get_legacy_last_reset_type(&self) -> SensorLastResetType {
        self.legacy_last_reset_type
    }
    pub fn clear_legacy_last_reset_type(&mut self) {
        self.legacy_last_reset_type = SensorLastResetType::LAST_RESET_NONE;
    }

    // Param is passed by value, moved
    pub fn set_legacy_last_reset_type(&mut self, v: SensorLastResetType) {
        self.legacy_last_reset_type = v;
    }

    // bool disabled_by_default = 12;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // .EntityCategory entity_category = 13;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }
}

impl ::protobuf::Message for ListEntitiesSensorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unit_of_measurement)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.accuracy_decimals = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_update = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_class)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state_class, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.legacy_last_reset_type, 11, &mut self.unknown_fields)?
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 13, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if !self.unit_of_measurement.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.unit_of_measurement);
        }
        if self.accuracy_decimals != 0 {
            my_size += ::protobuf::rt::value_size(7, self.accuracy_decimals, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.force_update != false {
            my_size += 2;
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.device_class);
        }
        if self.state_class != SensorStateClass::STATE_CLASS_NONE {
            my_size += ::protobuf::rt::enum_size(10, self.state_class);
        }
        if self.legacy_last_reset_type != SensorLastResetType::LAST_RESET_NONE {
            my_size += ::protobuf::rt::enum_size(11, self.legacy_last_reset_type);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(13, self.entity_category);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if !self.unit_of_measurement.is_empty() {
            os.write_string(6, &self.unit_of_measurement)?;
        }
        if self.accuracy_decimals != 0 {
            os.write_int32(7, self.accuracy_decimals)?;
        }
        if self.force_update != false {
            os.write_bool(8, self.force_update)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(9, &self.device_class)?;
        }
        if self.state_class != SensorStateClass::STATE_CLASS_NONE {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.state_class))?;
        }
        if self.legacy_last_reset_type != SensorLastResetType::LAST_RESET_NONE {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.legacy_last_reset_type))?;
        }
        if self.disabled_by_default != false {
            os.write_bool(12, self.disabled_by_default)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesSensorResponse {
        ListEntitiesSensorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesSensorResponse| { &m.object_id },
                |m: &mut ListEntitiesSensorResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesSensorResponse| { &m.key },
                |m: &mut ListEntitiesSensorResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesSensorResponse| { &m.name },
                |m: &mut ListEntitiesSensorResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesSensorResponse| { &m.unique_id },
                |m: &mut ListEntitiesSensorResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesSensorResponse| { &m.icon },
                |m: &mut ListEntitiesSensorResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unit_of_measurement",
                |m: &ListEntitiesSensorResponse| { &m.unit_of_measurement },
                |m: &mut ListEntitiesSensorResponse| { &mut m.unit_of_measurement },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "accuracy_decimals",
                |m: &ListEntitiesSensorResponse| { &m.accuracy_decimals },
                |m: &mut ListEntitiesSensorResponse| { &mut m.accuracy_decimals },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_update",
                |m: &ListEntitiesSensorResponse| { &m.force_update },
                |m: &mut ListEntitiesSensorResponse| { &mut m.force_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_class",
                |m: &ListEntitiesSensorResponse| { &m.device_class },
                |m: &mut ListEntitiesSensorResponse| { &mut m.device_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SensorStateClass>>(
                "state_class",
                |m: &ListEntitiesSensorResponse| { &m.state_class },
                |m: &mut ListEntitiesSensorResponse| { &mut m.state_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SensorLastResetType>>(
                "legacy_last_reset_type",
                |m: &ListEntitiesSensorResponse| { &m.legacy_last_reset_type },
                |m: &mut ListEntitiesSensorResponse| { &mut m.legacy_last_reset_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesSensorResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesSensorResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesSensorResponse| { &m.entity_category },
                |m: &mut ListEntitiesSensorResponse| { &mut m.entity_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesSensorResponse>(
                "ListEntitiesSensorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesSensorResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesSensorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesSensorResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesSensorResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.unit_of_measurement.clear();
        self.accuracy_decimals = 0;
        self.force_update = false;
        self.device_class.clear();
        self.state_class = SensorStateClass::STATE_CLASS_NONE;
        self.legacy_last_reset_type = SensorLastResetType::LAST_RESET_NONE;
        self.disabled_by_default = false;
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesSensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSensorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SensorStateResponse {
    // message fields
    pub key: u32,
    pub state: f32,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SensorStateResponse {
    fn default() -> &'a SensorStateResponse {
        <SensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SensorStateResponse {
    pub fn new() -> SensorStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // float state = 2;


    pub fn get_state(&self) -> f32 {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = 0.;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: f32) {
        self.state = v;
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for SensorStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != 0. {
            my_size += 5;
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SensorStateResponse {
        SensorStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SensorStateResponse| { &m.key },
                |m: &mut SensorStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "state",
                |m: &SensorStateResponse| { &m.state },
                |m: &mut SensorStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &SensorStateResponse| { &m.missing_state },
                |m: &mut SensorStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SensorStateResponse>(
                "SensorStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SensorStateResponse {
        static instance: ::protobuf::rt::LazyV2<SensorStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SensorStateResponse::new)
    }
}

impl ::protobuf::Clear for SensorStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SensorStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesSwitchResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub assumed_state: bool,
    pub disabled_by_default: bool,
    pub entity_category: EntityCategory,
    pub device_class: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSwitchResponse {
    fn default() -> &'a ListEntitiesSwitchResponse {
        <ListEntitiesSwitchResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSwitchResponse {
    pub fn new() -> ListEntitiesSwitchResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // bool assumed_state = 6;


    pub fn get_assumed_state(&self) -> bool {
        self.assumed_state
    }
    pub fn clear_assumed_state(&mut self) {
        self.assumed_state = false;
    }

    // Param is passed by value, moved
    pub fn set_assumed_state(&mut self, v: bool) {
        self.assumed_state = v;
    }

    // bool disabled_by_default = 7;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // .EntityCategory entity_category = 8;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }

    // string device_class = 9;


    pub fn get_device_class(&self) -> &str {
        &self.device_class
    }
    pub fn clear_device_class(&mut self) {
        self.device_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_class(&mut self, v: ::std::string::String) {
        self.device_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_class(&mut self) -> &mut ::std::string::String {
        &mut self.device_class
    }

    // Take field
    pub fn take_device_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_class, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListEntitiesSwitchResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.assumed_state = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_class)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.assumed_state != false {
            my_size += 2;
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(8, self.entity_category);
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.device_class);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.assumed_state != false {
            os.write_bool(6, self.assumed_state)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(9, &self.device_class)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesSwitchResponse {
        ListEntitiesSwitchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesSwitchResponse| { &m.object_id },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesSwitchResponse| { &m.key },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesSwitchResponse| { &m.name },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesSwitchResponse| { &m.unique_id },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesSwitchResponse| { &m.icon },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "assumed_state",
                |m: &ListEntitiesSwitchResponse| { &m.assumed_state },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.assumed_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesSwitchResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesSwitchResponse| { &m.entity_category },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.entity_category },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_class",
                |m: &ListEntitiesSwitchResponse| { &m.device_class },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.device_class },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesSwitchResponse>(
                "ListEntitiesSwitchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesSwitchResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesSwitchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesSwitchResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesSwitchResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.assumed_state = false;
        self.disabled_by_default = false;
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.device_class.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesSwitchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSwitchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SwitchStateResponse {
    // message fields
    pub key: u32,
    pub state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchStateResponse {
    fn default() -> &'a SwitchStateResponse {
        <SwitchStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SwitchStateResponse {
    pub fn new() -> SwitchStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }
}

impl ::protobuf::Message for SwitchStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwitchStateResponse {
        SwitchStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SwitchStateResponse| { &m.key },
                |m: &mut SwitchStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &SwitchStateResponse| { &m.state },
                |m: &mut SwitchStateResponse| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwitchStateResponse>(
                "SwitchStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwitchStateResponse {
        static instance: ::protobuf::rt::LazyV2<SwitchStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwitchStateResponse::new)
    }
}

impl ::protobuf::Clear for SwitchStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwitchStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SwitchCommandRequest {
    // message fields
    pub key: u32,
    pub state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchCommandRequest {
    fn default() -> &'a SwitchCommandRequest {
        <SwitchCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl SwitchCommandRequest {
    pub fn new() -> SwitchCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }
}

impl ::protobuf::Message for SwitchCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwitchCommandRequest {
        SwitchCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SwitchCommandRequest| { &m.key },
                |m: &mut SwitchCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &SwitchCommandRequest| { &m.state },
                |m: &mut SwitchCommandRequest| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwitchCommandRequest>(
                "SwitchCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwitchCommandRequest {
        static instance: ::protobuf::rt::LazyV2<SwitchCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwitchCommandRequest::new)
    }
}

impl ::protobuf::Clear for SwitchCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwitchCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesTextSensorResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub disabled_by_default: bool,
    pub entity_category: EntityCategory,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesTextSensorResponse {
    fn default() -> &'a ListEntitiesTextSensorResponse {
        <ListEntitiesTextSensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesTextSensorResponse {
    pub fn new() -> ListEntitiesTextSensorResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // bool disabled_by_default = 6;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // .EntityCategory entity_category = 7;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }
}

impl ::protobuf::Message for ListEntitiesTextSensorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(7, self.entity_category);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesTextSensorResponse {
        ListEntitiesTextSensorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesTextSensorResponse| { &m.object_id },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesTextSensorResponse| { &m.key },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesTextSensorResponse| { &m.name },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesTextSensorResponse| { &m.unique_id },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesTextSensorResponse| { &m.icon },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesTextSensorResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesTextSensorResponse| { &m.entity_category },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.entity_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesTextSensorResponse>(
                "ListEntitiesTextSensorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesTextSensorResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesTextSensorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesTextSensorResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesTextSensorResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesTextSensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesTextSensorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TextSensorStateResponse {
    // message fields
    pub key: u32,
    pub state: ::std::string::String,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextSensorStateResponse {
    fn default() -> &'a TextSensorStateResponse {
        <TextSensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl TextSensorStateResponse {
    pub fn new() -> TextSensorStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string state = 2;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for TextSensorStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TextSensorStateResponse {
        TextSensorStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &TextSensorStateResponse| { &m.key },
                |m: &mut TextSensorStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &TextSensorStateResponse| { &m.state },
                |m: &mut TextSensorStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &TextSensorStateResponse| { &m.missing_state },
                |m: &mut TextSensorStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TextSensorStateResponse>(
                "TextSensorStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TextSensorStateResponse {
        static instance: ::protobuf::rt::LazyV2<TextSensorStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TextSensorStateResponse::new)
    }
}

impl ::protobuf::Clear for TextSensorStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextSensorStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextSensorStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeLogsRequest {
    // message fields
    pub level: LogLevel,
    pub dump_config: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeLogsRequest {
    fn default() -> &'a SubscribeLogsRequest {
        <SubscribeLogsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeLogsRequest {
    pub fn new() -> SubscribeLogsRequest {
        ::std::default::Default::default()
    }

    // .LogLevel level = 1;


    pub fn get_level(&self) -> LogLevel {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = LogLevel::LOG_LEVEL_NONE;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: LogLevel) {
        self.level = v;
    }

    // bool dump_config = 2;


    pub fn get_dump_config(&self) -> bool {
        self.dump_config
    }
    pub fn clear_dump_config(&mut self) {
        self.dump_config = false;
    }

    // Param is passed by value, moved
    pub fn set_dump_config(&mut self, v: bool) {
        self.dump_config = v;
    }
}

impl ::protobuf::Message for SubscribeLogsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.level, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dump_config = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.level != LogLevel::LOG_LEVEL_NONE {
            my_size += ::protobuf::rt::enum_size(1, self.level);
        }
        if self.dump_config != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.level != LogLevel::LOG_LEVEL_NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.level))?;
        }
        if self.dump_config != false {
            os.write_bool(2, self.dump_config)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeLogsRequest {
        SubscribeLogsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LogLevel>>(
                "level",
                |m: &SubscribeLogsRequest| { &m.level },
                |m: &mut SubscribeLogsRequest| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dump_config",
                |m: &SubscribeLogsRequest| { &m.dump_config },
                |m: &mut SubscribeLogsRequest| { &mut m.dump_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeLogsRequest>(
                "SubscribeLogsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeLogsRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeLogsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeLogsRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeLogsRequest {
    fn clear(&mut self) {
        self.level = LogLevel::LOG_LEVEL_NONE;
        self.dump_config = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeLogsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeLogsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeLogsResponse {
    // message fields
    pub level: LogLevel,
    pub message: ::std::string::String,
    pub send_failed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeLogsResponse {
    fn default() -> &'a SubscribeLogsResponse {
        <SubscribeLogsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeLogsResponse {
    pub fn new() -> SubscribeLogsResponse {
        ::std::default::Default::default()
    }

    // .LogLevel level = 1;


    pub fn get_level(&self) -> LogLevel {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = LogLevel::LOG_LEVEL_NONE;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: LogLevel) {
        self.level = v;
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // bool send_failed = 4;


    pub fn get_send_failed(&self) -> bool {
        self.send_failed
    }
    pub fn clear_send_failed(&mut self) {
        self.send_failed = false;
    }

    // Param is passed by value, moved
    pub fn set_send_failed(&mut self, v: bool) {
        self.send_failed = v;
    }
}

impl ::protobuf::Message for SubscribeLogsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.level, 1, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_failed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.level != LogLevel::LOG_LEVEL_NONE {
            my_size += ::protobuf::rt::enum_size(1, self.level);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        if self.send_failed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.level != LogLevel::LOG_LEVEL_NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.level))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        if self.send_failed != false {
            os.write_bool(4, self.send_failed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeLogsResponse {
        SubscribeLogsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LogLevel>>(
                "level",
                |m: &SubscribeLogsResponse| { &m.level },
                |m: &mut SubscribeLogsResponse| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &SubscribeLogsResponse| { &m.message },
                |m: &mut SubscribeLogsResponse| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "send_failed",
                |m: &SubscribeLogsResponse| { &m.send_failed },
                |m: &mut SubscribeLogsResponse| { &mut m.send_failed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeLogsResponse>(
                "SubscribeLogsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeLogsResponse {
        static instance: ::protobuf::rt::LazyV2<SubscribeLogsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeLogsResponse::new)
    }
}

impl ::protobuf::Clear for SubscribeLogsResponse {
    fn clear(&mut self) {
        self.level = LogLevel::LOG_LEVEL_NONE;
        self.message.clear();
        self.send_failed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeLogsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeLogsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeHomeassistantServicesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeassistantServicesRequest {
    fn default() -> &'a SubscribeHomeassistantServicesRequest {
        <SubscribeHomeassistantServicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeassistantServicesRequest {
    pub fn new() -> SubscribeHomeassistantServicesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeHomeassistantServicesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeHomeassistantServicesRequest {
        SubscribeHomeassistantServicesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeHomeassistantServicesRequest>(
                "SubscribeHomeassistantServicesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeHomeassistantServicesRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeHomeassistantServicesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeHomeassistantServicesRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeHomeassistantServicesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeHomeassistantServicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeassistantServicesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HomeassistantServiceMap {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HomeassistantServiceMap {
    fn default() -> &'a HomeassistantServiceMap {
        <HomeassistantServiceMap as ::protobuf::Message>::default_instance()
    }
}

impl HomeassistantServiceMap {
    pub fn new() -> HomeassistantServiceMap {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HomeassistantServiceMap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HomeassistantServiceMap {
        HomeassistantServiceMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &HomeassistantServiceMap| { &m.key },
                |m: &mut HomeassistantServiceMap| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &HomeassistantServiceMap| { &m.value },
                |m: &mut HomeassistantServiceMap| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HomeassistantServiceMap>(
                "HomeassistantServiceMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HomeassistantServiceMap {
        static instance: ::protobuf::rt::LazyV2<HomeassistantServiceMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HomeassistantServiceMap::new)
    }
}

impl ::protobuf::Clear for HomeassistantServiceMap {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HomeassistantServiceMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeassistantServiceMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HomeassistantServiceResponse {
    // message fields
    pub service: ::std::string::String,
    pub data: ::protobuf::RepeatedField<HomeassistantServiceMap>,
    pub data_template: ::protobuf::RepeatedField<HomeassistantServiceMap>,
    pub variables: ::protobuf::RepeatedField<HomeassistantServiceMap>,
    pub is_event: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HomeassistantServiceResponse {
    fn default() -> &'a HomeassistantServiceResponse {
        <HomeassistantServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl HomeassistantServiceResponse {
    pub fn new() -> HomeassistantServiceResponse {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // repeated .HomeassistantServiceMap data = 2;


    pub fn get_data(&self) -> &[HomeassistantServiceMap] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<HomeassistantServiceMap>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<HomeassistantServiceMap> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<HomeassistantServiceMap> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    // repeated .HomeassistantServiceMap data_template = 3;


    pub fn get_data_template(&self) -> &[HomeassistantServiceMap] {
        &self.data_template
    }
    pub fn clear_data_template(&mut self) {
        self.data_template.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_template(&mut self, v: ::protobuf::RepeatedField<HomeassistantServiceMap>) {
        self.data_template = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_template(&mut self) -> &mut ::protobuf::RepeatedField<HomeassistantServiceMap> {
        &mut self.data_template
    }

    // Take field
    pub fn take_data_template(&mut self) -> ::protobuf::RepeatedField<HomeassistantServiceMap> {
        ::std::mem::replace(&mut self.data_template, ::protobuf::RepeatedField::new())
    }

    // repeated .HomeassistantServiceMap variables = 4;


    pub fn get_variables(&self) -> &[HomeassistantServiceMap] {
        &self.variables
    }
    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::protobuf::RepeatedField<HomeassistantServiceMap>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables(&mut self) -> &mut ::protobuf::RepeatedField<HomeassistantServiceMap> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::protobuf::RepeatedField<HomeassistantServiceMap> {
        ::std::mem::replace(&mut self.variables, ::protobuf::RepeatedField::new())
    }

    // bool is_event = 5;


    pub fn get_is_event(&self) -> bool {
        self.is_event
    }
    pub fn clear_is_event(&mut self) {
        self.is_event = false;
    }

    // Param is passed by value, moved
    pub fn set_is_event(&mut self, v: bool) {
        self.is_event = v;
    }
}

impl ::protobuf::Message for HomeassistantServiceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_template)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variables)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_event = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.data_template {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.is_event != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.data_template {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.variables {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.is_event != false {
            os.write_bool(5, self.is_event)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HomeassistantServiceResponse {
        HomeassistantServiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &HomeassistantServiceResponse| { &m.service },
                |m: &mut HomeassistantServiceResponse| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HomeassistantServiceMap>>(
                "data",
                |m: &HomeassistantServiceResponse| { &m.data },
                |m: &mut HomeassistantServiceResponse| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HomeassistantServiceMap>>(
                "data_template",
                |m: &HomeassistantServiceResponse| { &m.data_template },
                |m: &mut HomeassistantServiceResponse| { &mut m.data_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HomeassistantServiceMap>>(
                "variables",
                |m: &HomeassistantServiceResponse| { &m.variables },
                |m: &mut HomeassistantServiceResponse| { &mut m.variables },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_event",
                |m: &HomeassistantServiceResponse| { &m.is_event },
                |m: &mut HomeassistantServiceResponse| { &mut m.is_event },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HomeassistantServiceResponse>(
                "HomeassistantServiceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HomeassistantServiceResponse {
        static instance: ::protobuf::rt::LazyV2<HomeassistantServiceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HomeassistantServiceResponse::new)
    }
}

impl ::protobuf::Clear for HomeassistantServiceResponse {
    fn clear(&mut self) {
        self.service.clear();
        self.data.clear();
        self.data_template.clear();
        self.variables.clear();
        self.is_event = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HomeassistantServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeassistantServiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeHomeAssistantStatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeAssistantStatesRequest {
    fn default() -> &'a SubscribeHomeAssistantStatesRequest {
        <SubscribeHomeAssistantStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeAssistantStatesRequest {
    pub fn new() -> SubscribeHomeAssistantStatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeHomeAssistantStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeHomeAssistantStatesRequest {
        SubscribeHomeAssistantStatesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeHomeAssistantStatesRequest>(
                "SubscribeHomeAssistantStatesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeHomeAssistantStatesRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeHomeAssistantStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeHomeAssistantStatesRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeHomeAssistantStatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeHomeAssistantStatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeAssistantStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeHomeAssistantStateResponse {
    // message fields
    pub entity_id: ::std::string::String,
    pub attribute: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeAssistantStateResponse {
    fn default() -> &'a SubscribeHomeAssistantStateResponse {
        <SubscribeHomeAssistantStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeAssistantStateResponse {
    pub fn new() -> SubscribeHomeAssistantStateResponse {
        ::std::default::Default::default()
    }

    // string entity_id = 1;


    pub fn get_entity_id(&self) -> &str {
        &self.entity_id
    }
    pub fn clear_entity_id(&mut self) {
        self.entity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: ::std::string::String) {
        self.entity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_id(&mut self) -> &mut ::std::string::String {
        &mut self.entity_id
    }

    // Take field
    pub fn take_entity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity_id, ::std::string::String::new())
    }

    // string attribute = 2;


    pub fn get_attribute(&self) -> &str {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::std::string::String) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute(&mut self) -> &mut ::std::string::String {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attribute, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubscribeHomeAssistantStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attribute)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.attribute);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.attribute.is_empty() {
            os.write_string(2, &self.attribute)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeHomeAssistantStateResponse {
        SubscribeHomeAssistantStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity_id",
                |m: &SubscribeHomeAssistantStateResponse| { &m.entity_id },
                |m: &mut SubscribeHomeAssistantStateResponse| { &mut m.entity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attribute",
                |m: &SubscribeHomeAssistantStateResponse| { &m.attribute },
                |m: &mut SubscribeHomeAssistantStateResponse| { &mut m.attribute },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeHomeAssistantStateResponse>(
                "SubscribeHomeAssistantStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeHomeAssistantStateResponse {
        static instance: ::protobuf::rt::LazyV2<SubscribeHomeAssistantStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeHomeAssistantStateResponse::new)
    }
}

impl ::protobuf::Clear for SubscribeHomeAssistantStateResponse {
    fn clear(&mut self) {
        self.entity_id.clear();
        self.attribute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeHomeAssistantStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeAssistantStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HomeAssistantStateResponse {
    // message fields
    pub entity_id: ::std::string::String,
    pub state: ::std::string::String,
    pub attribute: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HomeAssistantStateResponse {
    fn default() -> &'a HomeAssistantStateResponse {
        <HomeAssistantStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl HomeAssistantStateResponse {
    pub fn new() -> HomeAssistantStateResponse {
        ::std::default::Default::default()
    }

    // string entity_id = 1;


    pub fn get_entity_id(&self) -> &str {
        &self.entity_id
    }
    pub fn clear_entity_id(&mut self) {
        self.entity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: ::std::string::String) {
        self.entity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_id(&mut self) -> &mut ::std::string::String {
        &mut self.entity_id
    }

    // Take field
    pub fn take_entity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity_id, ::std::string::String::new())
    }

    // string state = 2;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // string attribute = 3;


    pub fn get_attribute(&self) -> &str {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::std::string::String) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute(&mut self) -> &mut ::std::string::String {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attribute, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HomeAssistantStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attribute)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.attribute);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if !self.attribute.is_empty() {
            os.write_string(3, &self.attribute)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HomeAssistantStateResponse {
        HomeAssistantStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity_id",
                |m: &HomeAssistantStateResponse| { &m.entity_id },
                |m: &mut HomeAssistantStateResponse| { &mut m.entity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &HomeAssistantStateResponse| { &m.state },
                |m: &mut HomeAssistantStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attribute",
                |m: &HomeAssistantStateResponse| { &m.attribute },
                |m: &mut HomeAssistantStateResponse| { &mut m.attribute },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HomeAssistantStateResponse>(
                "HomeAssistantStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HomeAssistantStateResponse {
        static instance: ::protobuf::rt::LazyV2<HomeAssistantStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HomeAssistantStateResponse::new)
    }
}

impl ::protobuf::Clear for HomeAssistantStateResponse {
    fn clear(&mut self) {
        self.entity_id.clear();
        self.state.clear();
        self.attribute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HomeAssistantStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeAssistantStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTimeRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTimeRequest {
    fn default() -> &'a GetTimeRequest {
        <GetTimeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTimeRequest {
    pub fn new() -> GetTimeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetTimeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTimeRequest {
        GetTimeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTimeRequest>(
                "GetTimeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTimeRequest {
        static instance: ::protobuf::rt::LazyV2<GetTimeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTimeRequest::new)
    }
}

impl ::protobuf::Clear for GetTimeRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTimeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTimeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTimeResponse {
    // message fields
    pub epoch_seconds: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTimeResponse {
    fn default() -> &'a GetTimeResponse {
        <GetTimeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTimeResponse {
    pub fn new() -> GetTimeResponse {
        ::std::default::Default::default()
    }

    // fixed32 epoch_seconds = 1;


    pub fn get_epoch_seconds(&self) -> u32 {
        self.epoch_seconds
    }
    pub fn clear_epoch_seconds(&mut self) {
        self.epoch_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch_seconds(&mut self, v: u32) {
        self.epoch_seconds = v;
    }
}

impl ::protobuf::Message for GetTimeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.epoch_seconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epoch_seconds != 0 {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epoch_seconds != 0 {
            os.write_fixed32(1, self.epoch_seconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTimeResponse {
        GetTimeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "epoch_seconds",
                |m: &GetTimeResponse| { &m.epoch_seconds },
                |m: &mut GetTimeResponse| { &mut m.epoch_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTimeResponse>(
                "GetTimeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTimeResponse {
        static instance: ::protobuf::rt::LazyV2<GetTimeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTimeResponse::new)
    }
}

impl ::protobuf::Clear for GetTimeResponse {
    fn clear(&mut self) {
        self.epoch_seconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTimeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTimeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesServicesArgument {
    // message fields
    pub name: ::std::string::String,
    pub field_type: ServiceArgType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesServicesArgument {
    fn default() -> &'a ListEntitiesServicesArgument {
        <ListEntitiesServicesArgument as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesServicesArgument {
    pub fn new() -> ListEntitiesServicesArgument {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .ServiceArgType type = 2;


    pub fn get_field_type(&self) -> ServiceArgType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ServiceArgType::SERVICE_ARG_TYPE_BOOL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ServiceArgType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for ListEntitiesServicesArgument {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.field_type != ServiceArgType::SERVICE_ARG_TYPE_BOOL {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.field_type != ServiceArgType::SERVICE_ARG_TYPE_BOOL {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesServicesArgument {
        ListEntitiesServicesArgument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesServicesArgument| { &m.name },
                |m: &mut ListEntitiesServicesArgument| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServiceArgType>>(
                "type",
                |m: &ListEntitiesServicesArgument| { &m.field_type },
                |m: &mut ListEntitiesServicesArgument| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesServicesArgument>(
                "ListEntitiesServicesArgument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesServicesArgument {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesServicesArgument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesServicesArgument::new)
    }
}

impl ::protobuf::Clear for ListEntitiesServicesArgument {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type = ServiceArgType::SERVICE_ARG_TYPE_BOOL;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesServicesArgument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesServicesArgument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesServicesResponse {
    // message fields
    pub name: ::std::string::String,
    pub key: u32,
    pub args: ::protobuf::RepeatedField<ListEntitiesServicesArgument>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesServicesResponse {
    fn default() -> &'a ListEntitiesServicesResponse {
        <ListEntitiesServicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesServicesResponse {
    pub fn new() -> ListEntitiesServicesResponse {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // repeated .ListEntitiesServicesArgument args = 3;


    pub fn get_args(&self) -> &[ListEntitiesServicesArgument] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<ListEntitiesServicesArgument>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<ListEntitiesServicesArgument> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<ListEntitiesServicesArgument> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListEntitiesServicesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.key != 0 {
            my_size += 5;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        for v in &self.args {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesServicesResponse {
        ListEntitiesServicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesServicesResponse| { &m.name },
                |m: &mut ListEntitiesServicesResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesServicesResponse| { &m.key },
                |m: &mut ListEntitiesServicesResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListEntitiesServicesArgument>>(
                "args",
                |m: &ListEntitiesServicesResponse| { &m.args },
                |m: &mut ListEntitiesServicesResponse| { &mut m.args },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesServicesResponse>(
                "ListEntitiesServicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesServicesResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesServicesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesServicesResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesServicesResponse {
    fn clear(&mut self) {
        self.name.clear();
        self.key = 0;
        self.args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesServicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesServicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteServiceArgument {
    // message fields
    pub bool_: bool,
    pub legacy_int: i32,
    pub float_: f32,
    pub string_: ::std::string::String,
    pub int_: i32,
    pub bool_array: ::std::vec::Vec<bool>,
    pub int_array: ::std::vec::Vec<i32>,
    pub float_array: ::std::vec::Vec<f32>,
    pub string_array: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteServiceArgument {
    fn default() -> &'a ExecuteServiceArgument {
        <ExecuteServiceArgument as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteServiceArgument {
    pub fn new() -> ExecuteServiceArgument {
        ::std::default::Default::default()
    }

    // bool bool_ = 1;


    pub fn get_bool_(&self) -> bool {
        self.bool_
    }
    pub fn clear_bool_(&mut self) {
        self.bool_ = false;
    }

    // Param is passed by value, moved
    pub fn set_bool_(&mut self, v: bool) {
        self.bool_ = v;
    }

    // int32 legacy_int = 2;


    pub fn get_legacy_int(&self) -> i32 {
        self.legacy_int
    }
    pub fn clear_legacy_int(&mut self) {
        self.legacy_int = 0;
    }

    // Param is passed by value, moved
    pub fn set_legacy_int(&mut self, v: i32) {
        self.legacy_int = v;
    }

    // float float_ = 3;


    pub fn get_float_(&self) -> f32 {
        self.float_
    }
    pub fn clear_float_(&mut self) {
        self.float_ = 0.;
    }

    // Param is passed by value, moved
    pub fn set_float_(&mut self, v: f32) {
        self.float_ = v;
    }

    // string string_ = 4;


    pub fn get_string_(&self) -> &str {
        &self.string_
    }
    pub fn clear_string_(&mut self) {
        self.string_.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_(&mut self, v: ::std::string::String) {
        self.string_ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_(&mut self) -> &mut ::std::string::String {
        &mut self.string_
    }

    // Take field
    pub fn take_string_(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.string_, ::std::string::String::new())
    }

    // sint32 int_ = 5;


    pub fn get_int_(&self) -> i32 {
        self.int_
    }
    pub fn clear_int_(&mut self) {
        self.int_ = 0;
    }

    // Param is passed by value, moved
    pub fn set_int_(&mut self, v: i32) {
        self.int_ = v;
    }

    // repeated bool bool_array = 6;


    pub fn get_bool_array(&self) -> &[bool] {
        &self.bool_array
    }
    pub fn clear_bool_array(&mut self) {
        self.bool_array.clear();
    }

    // Param is passed by value, moved
    pub fn set_bool_array(&mut self, v: ::std::vec::Vec<bool>) {
        self.bool_array = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bool_array(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.bool_array
    }

    // Take field
    pub fn take_bool_array(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.bool_array, ::std::vec::Vec::new())
    }

    // repeated sint32 int_array = 7;


    pub fn get_int_array(&self) -> &[i32] {
        &self.int_array
    }
    pub fn clear_int_array(&mut self) {
        self.int_array.clear();
    }

    // Param is passed by value, moved
    pub fn set_int_array(&mut self, v: ::std::vec::Vec<i32>) {
        self.int_array = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int_array(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.int_array
    }

    // Take field
    pub fn take_int_array(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.int_array, ::std::vec::Vec::new())
    }

    // repeated float float_array = 8;


    pub fn get_float_array(&self) -> &[f32] {
        &self.float_array
    }
    pub fn clear_float_array(&mut self) {
        self.float_array.clear();
    }

    // Param is passed by value, moved
    pub fn set_float_array(&mut self, v: ::std::vec::Vec<f32>) {
        self.float_array = v;
    }

    // Mutable pointer to the field.
    pub fn mut_float_array(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.float_array
    }

    // Take field
    pub fn take_float_array(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.float_array, ::std::vec::Vec::new())
    }

    // repeated string string_array = 9;


    pub fn get_string_array(&self) -> &[::std::string::String] {
        &self.string_array
    }
    pub fn clear_string_array(&mut self) {
        self.string_array.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_array(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.string_array = v;
    }

    // Mutable pointer to the field.
    pub fn mut_string_array(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.string_array
    }

    // Take field
    pub fn take_string_array(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.string_array, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecuteServiceArgument {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bool_ = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.legacy_int = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.float_ = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.string_)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.int_ = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.bool_array)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.int_array)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.float_array)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.string_array)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bool_ != false {
            my_size += 2;
        }
        if self.legacy_int != 0 {
            my_size += ::protobuf::rt::value_size(2, self.legacy_int, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.float_ != 0. {
            my_size += 5;
        }
        if !self.string_.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.string_);
        }
        if self.int_ != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.int_);
        }
        my_size += 2 * self.bool_array.len() as u32;
        for value in &self.int_array {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, *value);
        };
        my_size += 5 * self.float_array.len() as u32;
        for value in &self.string_array {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bool_ != false {
            os.write_bool(1, self.bool_)?;
        }
        if self.legacy_int != 0 {
            os.write_int32(2, self.legacy_int)?;
        }
        if self.float_ != 0. {
            os.write_float(3, self.float_)?;
        }
        if !self.string_.is_empty() {
            os.write_string(4, &self.string_)?;
        }
        if self.int_ != 0 {
            os.write_sint32(5, self.int_)?;
        }
        for v in &self.bool_array {
            os.write_bool(6, *v)?;
        };
        for v in &self.int_array {
            os.write_sint32(7, *v)?;
        };
        for v in &self.float_array {
            os.write_float(8, *v)?;
        };
        for v in &self.string_array {
            os.write_string(9, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteServiceArgument {
        ExecuteServiceArgument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bool_",
                |m: &ExecuteServiceArgument| { &m.bool_ },
                |m: &mut ExecuteServiceArgument| { &mut m.bool_ },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "legacy_int",
                |m: &ExecuteServiceArgument| { &m.legacy_int },
                |m: &mut ExecuteServiceArgument| { &mut m.legacy_int },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "float_",
                |m: &ExecuteServiceArgument| { &m.float_ },
                |m: &mut ExecuteServiceArgument| { &mut m.float_ },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "string_",
                |m: &ExecuteServiceArgument| { &m.string_ },
                |m: &mut ExecuteServiceArgument| { &mut m.string_ },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "int_",
                |m: &ExecuteServiceArgument| { &m.int_ },
                |m: &mut ExecuteServiceArgument| { &mut m.int_ },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bool_array",
                |m: &ExecuteServiceArgument| { &m.bool_array },
                |m: &mut ExecuteServiceArgument| { &mut m.bool_array },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "int_array",
                |m: &ExecuteServiceArgument| { &m.int_array },
                |m: &mut ExecuteServiceArgument| { &mut m.int_array },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "float_array",
                |m: &ExecuteServiceArgument| { &m.float_array },
                |m: &mut ExecuteServiceArgument| { &mut m.float_array },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "string_array",
                |m: &ExecuteServiceArgument| { &m.string_array },
                |m: &mut ExecuteServiceArgument| { &mut m.string_array },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteServiceArgument>(
                "ExecuteServiceArgument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecuteServiceArgument {
        static instance: ::protobuf::rt::LazyV2<ExecuteServiceArgument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecuteServiceArgument::new)
    }
}

impl ::protobuf::Clear for ExecuteServiceArgument {
    fn clear(&mut self) {
        self.bool_ = false;
        self.legacy_int = 0;
        self.float_ = 0.;
        self.string_.clear();
        self.int_ = 0;
        self.bool_array.clear();
        self.int_array.clear();
        self.float_array.clear();
        self.string_array.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteServiceArgument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteServiceArgument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteServiceRequest {
    // message fields
    pub key: u32,
    pub args: ::protobuf::RepeatedField<ExecuteServiceArgument>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteServiceRequest {
    fn default() -> &'a ExecuteServiceRequest {
        <ExecuteServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteServiceRequest {
    pub fn new() -> ExecuteServiceRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // repeated .ExecuteServiceArgument args = 2;


    pub fn get_args(&self) -> &[ExecuteServiceArgument] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<ExecuteServiceArgument>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<ExecuteServiceArgument> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<ExecuteServiceArgument> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecuteServiceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        for v in &self.args {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteServiceRequest {
        ExecuteServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ExecuteServiceRequest| { &m.key },
                |m: &mut ExecuteServiceRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecuteServiceArgument>>(
                "args",
                |m: &ExecuteServiceRequest| { &m.args },
                |m: &mut ExecuteServiceRequest| { &mut m.args },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteServiceRequest>(
                "ExecuteServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecuteServiceRequest {
        static instance: ::protobuf::rt::LazyV2<ExecuteServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecuteServiceRequest::new)
    }
}

impl ::protobuf::Clear for ExecuteServiceRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesCameraResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub disabled_by_default: bool,
    pub icon: ::std::string::String,
    pub entity_category: EntityCategory,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesCameraResponse {
    fn default() -> &'a ListEntitiesCameraResponse {
        <ListEntitiesCameraResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesCameraResponse {
    pub fn new() -> ListEntitiesCameraResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // bool disabled_by_default = 5;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // string icon = 6;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // .EntityCategory entity_category = 7;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }
}

impl ::protobuf::Message for ListEntitiesCameraResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.icon);
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(7, self.entity_category);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(5, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(6, &self.icon)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesCameraResponse {
        ListEntitiesCameraResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesCameraResponse| { &m.object_id },
                |m: &mut ListEntitiesCameraResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesCameraResponse| { &m.key },
                |m: &mut ListEntitiesCameraResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesCameraResponse| { &m.name },
                |m: &mut ListEntitiesCameraResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesCameraResponse| { &m.unique_id },
                |m: &mut ListEntitiesCameraResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesCameraResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesCameraResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesCameraResponse| { &m.icon },
                |m: &mut ListEntitiesCameraResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesCameraResponse| { &m.entity_category },
                |m: &mut ListEntitiesCameraResponse| { &mut m.entity_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesCameraResponse>(
                "ListEntitiesCameraResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesCameraResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesCameraResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesCameraResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesCameraResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesCameraResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesCameraResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraImageResponse {
    // message fields
    pub key: u32,
    pub data: ::std::vec::Vec<u8>,
    pub done: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraImageResponse {
    fn default() -> &'a CameraImageResponse {
        <CameraImageResponse as ::protobuf::Message>::default_instance()
    }
}

impl CameraImageResponse {
    pub fn new() -> CameraImageResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bool done = 3;


    pub fn get_done(&self) -> bool {
        self.done
    }
    pub fn clear_done(&mut self) {
        self.done = false;
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: bool) {
        self.done = v;
    }
}

impl ::protobuf::Message for CameraImageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.done = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.done != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.done != false {
            os.write_bool(3, self.done)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraImageResponse {
        CameraImageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &CameraImageResponse| { &m.key },
                |m: &mut CameraImageResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CameraImageResponse| { &m.data },
                |m: &mut CameraImageResponse| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "done",
                |m: &CameraImageResponse| { &m.done },
                |m: &mut CameraImageResponse| { &mut m.done },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CameraImageResponse>(
                "CameraImageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CameraImageResponse {
        static instance: ::protobuf::rt::LazyV2<CameraImageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CameraImageResponse::new)
    }
}

impl ::protobuf::Clear for CameraImageResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.data.clear();
        self.done = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraImageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraImageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraImageRequest {
    // message fields
    pub single: bool,
    pub stream: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraImageRequest {
    fn default() -> &'a CameraImageRequest {
        <CameraImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl CameraImageRequest {
    pub fn new() -> CameraImageRequest {
        ::std::default::Default::default()
    }

    // bool single = 1;


    pub fn get_single(&self) -> bool {
        self.single
    }
    pub fn clear_single(&mut self) {
        self.single = false;
    }

    // Param is passed by value, moved
    pub fn set_single(&mut self, v: bool) {
        self.single = v;
    }

    // bool stream = 2;


    pub fn get_stream(&self) -> bool {
        self.stream
    }
    pub fn clear_stream(&mut self) {
        self.stream = false;
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: bool) {
        self.stream = v;
    }
}

impl ::protobuf::Message for CameraImageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.single = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stream = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.single != false {
            my_size += 2;
        }
        if self.stream != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.single != false {
            os.write_bool(1, self.single)?;
        }
        if self.stream != false {
            os.write_bool(2, self.stream)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraImageRequest {
        CameraImageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "single",
                |m: &CameraImageRequest| { &m.single },
                |m: &mut CameraImageRequest| { &mut m.single },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stream",
                |m: &CameraImageRequest| { &m.stream },
                |m: &mut CameraImageRequest| { &mut m.stream },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CameraImageRequest>(
                "CameraImageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CameraImageRequest {
        static instance: ::protobuf::rt::LazyV2<CameraImageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CameraImageRequest::new)
    }
}

impl ::protobuf::Clear for CameraImageRequest {
    fn clear(&mut self) {
        self.single = false;
        self.stream = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraImageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesClimateResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub supports_current_temperature: bool,
    pub supports_two_point_target_temperature: bool,
    pub supported_modes: ::std::vec::Vec<ClimateMode>,
    pub visual_min_temperature: f32,
    pub visual_max_temperature: f32,
    pub visual_temperature_step: f32,
    pub legacy_supports_away: bool,
    pub supports_action: bool,
    pub supported_fan_modes: ::std::vec::Vec<ClimateFanMode>,
    pub supported_swing_modes: ::std::vec::Vec<ClimateSwingMode>,
    pub supported_custom_fan_modes: ::protobuf::RepeatedField<::std::string::String>,
    pub supported_presets: ::std::vec::Vec<ClimatePreset>,
    pub supported_custom_presets: ::protobuf::RepeatedField<::std::string::String>,
    pub disabled_by_default: bool,
    pub icon: ::std::string::String,
    pub entity_category: EntityCategory,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesClimateResponse {
    fn default() -> &'a ListEntitiesClimateResponse {
        <ListEntitiesClimateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesClimateResponse {
    pub fn new() -> ListEntitiesClimateResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // bool supports_current_temperature = 5;


    pub fn get_supports_current_temperature(&self) -> bool {
        self.supports_current_temperature
    }
    pub fn clear_supports_current_temperature(&mut self) {
        self.supports_current_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_current_temperature(&mut self, v: bool) {
        self.supports_current_temperature = v;
    }

    // bool supports_two_point_target_temperature = 6;


    pub fn get_supports_two_point_target_temperature(&self) -> bool {
        self.supports_two_point_target_temperature
    }
    pub fn clear_supports_two_point_target_temperature(&mut self) {
        self.supports_two_point_target_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_two_point_target_temperature(&mut self, v: bool) {
        self.supports_two_point_target_temperature = v;
    }

    // repeated .ClimateMode supported_modes = 7;


    pub fn get_supported_modes(&self) -> &[ClimateMode] {
        &self.supported_modes
    }
    pub fn clear_supported_modes(&mut self) {
        self.supported_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_modes(&mut self, v: ::std::vec::Vec<ClimateMode>) {
        self.supported_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_modes(&mut self) -> &mut ::std::vec::Vec<ClimateMode> {
        &mut self.supported_modes
    }

    // Take field
    pub fn take_supported_modes(&mut self) -> ::std::vec::Vec<ClimateMode> {
        ::std::mem::replace(&mut self.supported_modes, ::std::vec::Vec::new())
    }

    // float visual_min_temperature = 8;


    pub fn get_visual_min_temperature(&self) -> f32 {
        self.visual_min_temperature
    }
    pub fn clear_visual_min_temperature(&mut self) {
        self.visual_min_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_visual_min_temperature(&mut self, v: f32) {
        self.visual_min_temperature = v;
    }

    // float visual_max_temperature = 9;


    pub fn get_visual_max_temperature(&self) -> f32 {
        self.visual_max_temperature
    }
    pub fn clear_visual_max_temperature(&mut self) {
        self.visual_max_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_visual_max_temperature(&mut self, v: f32) {
        self.visual_max_temperature = v;
    }

    // float visual_temperature_step = 10;


    pub fn get_visual_temperature_step(&self) -> f32 {
        self.visual_temperature_step
    }
    pub fn clear_visual_temperature_step(&mut self) {
        self.visual_temperature_step = 0.;
    }

    // Param is passed by value, moved
    pub fn set_visual_temperature_step(&mut self, v: f32) {
        self.visual_temperature_step = v;
    }

    // bool legacy_supports_away = 11;


    pub fn get_legacy_supports_away(&self) -> bool {
        self.legacy_supports_away
    }
    pub fn clear_legacy_supports_away(&mut self) {
        self.legacy_supports_away = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_away(&mut self, v: bool) {
        self.legacy_supports_away = v;
    }

    // bool supports_action = 12;


    pub fn get_supports_action(&self) -> bool {
        self.supports_action
    }
    pub fn clear_supports_action(&mut self) {
        self.supports_action = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_action(&mut self, v: bool) {
        self.supports_action = v;
    }

    // repeated .ClimateFanMode supported_fan_modes = 13;


    pub fn get_supported_fan_modes(&self) -> &[ClimateFanMode] {
        &self.supported_fan_modes
    }
    pub fn clear_supported_fan_modes(&mut self) {
        self.supported_fan_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_fan_modes(&mut self, v: ::std::vec::Vec<ClimateFanMode>) {
        self.supported_fan_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_fan_modes(&mut self) -> &mut ::std::vec::Vec<ClimateFanMode> {
        &mut self.supported_fan_modes
    }

    // Take field
    pub fn take_supported_fan_modes(&mut self) -> ::std::vec::Vec<ClimateFanMode> {
        ::std::mem::replace(&mut self.supported_fan_modes, ::std::vec::Vec::new())
    }

    // repeated .ClimateSwingMode supported_swing_modes = 14;


    pub fn get_supported_swing_modes(&self) -> &[ClimateSwingMode] {
        &self.supported_swing_modes
    }
    pub fn clear_supported_swing_modes(&mut self) {
        self.supported_swing_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_swing_modes(&mut self, v: ::std::vec::Vec<ClimateSwingMode>) {
        self.supported_swing_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_swing_modes(&mut self) -> &mut ::std::vec::Vec<ClimateSwingMode> {
        &mut self.supported_swing_modes
    }

    // Take field
    pub fn take_supported_swing_modes(&mut self) -> ::std::vec::Vec<ClimateSwingMode> {
        ::std::mem::replace(&mut self.supported_swing_modes, ::std::vec::Vec::new())
    }

    // repeated string supported_custom_fan_modes = 15;


    pub fn get_supported_custom_fan_modes(&self) -> &[::std::string::String] {
        &self.supported_custom_fan_modes
    }
    pub fn clear_supported_custom_fan_modes(&mut self) {
        self.supported_custom_fan_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_custom_fan_modes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.supported_custom_fan_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_custom_fan_modes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.supported_custom_fan_modes
    }

    // Take field
    pub fn take_supported_custom_fan_modes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.supported_custom_fan_modes, ::protobuf::RepeatedField::new())
    }

    // repeated .ClimatePreset supported_presets = 16;


    pub fn get_supported_presets(&self) -> &[ClimatePreset] {
        &self.supported_presets
    }
    pub fn clear_supported_presets(&mut self) {
        self.supported_presets.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_presets(&mut self, v: ::std::vec::Vec<ClimatePreset>) {
        self.supported_presets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_presets(&mut self) -> &mut ::std::vec::Vec<ClimatePreset> {
        &mut self.supported_presets
    }

    // Take field
    pub fn take_supported_presets(&mut self) -> ::std::vec::Vec<ClimatePreset> {
        ::std::mem::replace(&mut self.supported_presets, ::std::vec::Vec::new())
    }

    // repeated string supported_custom_presets = 17;


    pub fn get_supported_custom_presets(&self) -> &[::std::string::String] {
        &self.supported_custom_presets
    }
    pub fn clear_supported_custom_presets(&mut self) {
        self.supported_custom_presets.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_custom_presets(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.supported_custom_presets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_custom_presets(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.supported_custom_presets
    }

    // Take field
    pub fn take_supported_custom_presets(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.supported_custom_presets, ::protobuf::RepeatedField::new())
    }

    // bool disabled_by_default = 18;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // string icon = 19;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // .EntityCategory entity_category = 20;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }
}

impl ::protobuf::Message for ListEntitiesClimateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_current_temperature = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_two_point_target_temperature = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_modes, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.visual_min_temperature = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.visual_max_temperature = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.visual_temperature_step = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_away = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_action = tmp;
                },
                13 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_fan_modes, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_swing_modes, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.supported_custom_fan_modes)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_presets, 16, &mut self.unknown_fields)?
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.supported_custom_presets)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                20 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 20, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.supports_current_temperature != false {
            my_size += 2;
        }
        if self.supports_two_point_target_temperature != false {
            my_size += 2;
        }
        for value in &self.supported_modes {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        if self.visual_min_temperature != 0. {
            my_size += 5;
        }
        if self.visual_max_temperature != 0. {
            my_size += 5;
        }
        if self.visual_temperature_step != 0. {
            my_size += 5;
        }
        if self.legacy_supports_away != false {
            my_size += 2;
        }
        if self.supports_action != false {
            my_size += 2;
        }
        for value in &self.supported_fan_modes {
            my_size += ::protobuf::rt::enum_size(13, *value);
        };
        for value in &self.supported_swing_modes {
            my_size += ::protobuf::rt::enum_size(14, *value);
        };
        for value in &self.supported_custom_fan_modes {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.supported_presets {
            my_size += ::protobuf::rt::enum_size(16, *value);
        };
        for value in &self.supported_custom_presets {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        if self.disabled_by_default != false {
            my_size += 3;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.icon);
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(20, self.entity_category);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.supports_current_temperature != false {
            os.write_bool(5, self.supports_current_temperature)?;
        }
        if self.supports_two_point_target_temperature != false {
            os.write_bool(6, self.supports_two_point_target_temperature)?;
        }
        for v in &self.supported_modes {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.visual_min_temperature != 0. {
            os.write_float(8, self.visual_min_temperature)?;
        }
        if self.visual_max_temperature != 0. {
            os.write_float(9, self.visual_max_temperature)?;
        }
        if self.visual_temperature_step != 0. {
            os.write_float(10, self.visual_temperature_step)?;
        }
        if self.legacy_supports_away != false {
            os.write_bool(11, self.legacy_supports_away)?;
        }
        if self.supports_action != false {
            os.write_bool(12, self.supports_action)?;
        }
        for v in &self.supported_fan_modes {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.supported_swing_modes {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.supported_custom_fan_modes {
            os.write_string(15, &v)?;
        };
        for v in &self.supported_presets {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.supported_custom_presets {
            os.write_string(17, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(18, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(19, &self.icon)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(20, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesClimateResponse {
        ListEntitiesClimateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesClimateResponse| { &m.object_id },
                |m: &mut ListEntitiesClimateResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesClimateResponse| { &m.key },
                |m: &mut ListEntitiesClimateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesClimateResponse| { &m.name },
                |m: &mut ListEntitiesClimateResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesClimateResponse| { &m.unique_id },
                |m: &mut ListEntitiesClimateResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_current_temperature",
                |m: &ListEntitiesClimateResponse| { &m.supports_current_temperature },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supports_current_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_two_point_target_temperature",
                |m: &ListEntitiesClimateResponse| { &m.supports_two_point_target_temperature },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supports_two_point_target_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateMode>>(
                "supported_modes",
                |m: &ListEntitiesClimateResponse| { &m.supported_modes },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "visual_min_temperature",
                |m: &ListEntitiesClimateResponse| { &m.visual_min_temperature },
                |m: &mut ListEntitiesClimateResponse| { &mut m.visual_min_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "visual_max_temperature",
                |m: &ListEntitiesClimateResponse| { &m.visual_max_temperature },
                |m: &mut ListEntitiesClimateResponse| { &mut m.visual_max_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "visual_temperature_step",
                |m: &ListEntitiesClimateResponse| { &m.visual_temperature_step },
                |m: &mut ListEntitiesClimateResponse| { &mut m.visual_temperature_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_away",
                |m: &ListEntitiesClimateResponse| { &m.legacy_supports_away },
                |m: &mut ListEntitiesClimateResponse| { &mut m.legacy_supports_away },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_action",
                |m: &ListEntitiesClimateResponse| { &m.supports_action },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supports_action },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateFanMode>>(
                "supported_fan_modes",
                |m: &ListEntitiesClimateResponse| { &m.supported_fan_modes },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_fan_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateSwingMode>>(
                "supported_swing_modes",
                |m: &ListEntitiesClimateResponse| { &m.supported_swing_modes },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_swing_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "supported_custom_fan_modes",
                |m: &ListEntitiesClimateResponse| { &m.supported_custom_fan_modes },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_custom_fan_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimatePreset>>(
                "supported_presets",
                |m: &ListEntitiesClimateResponse| { &m.supported_presets },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_presets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "supported_custom_presets",
                |m: &ListEntitiesClimateResponse| { &m.supported_custom_presets },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_custom_presets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesClimateResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesClimateResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesClimateResponse| { &m.icon },
                |m: &mut ListEntitiesClimateResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesClimateResponse| { &m.entity_category },
                |m: &mut ListEntitiesClimateResponse| { &mut m.entity_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesClimateResponse>(
                "ListEntitiesClimateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesClimateResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesClimateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesClimateResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesClimateResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supports_current_temperature = false;
        self.supports_two_point_target_temperature = false;
        self.supported_modes.clear();
        self.visual_min_temperature = 0.;
        self.visual_max_temperature = 0.;
        self.visual_temperature_step = 0.;
        self.legacy_supports_away = false;
        self.supports_action = false;
        self.supported_fan_modes.clear();
        self.supported_swing_modes.clear();
        self.supported_custom_fan_modes.clear();
        self.supported_presets.clear();
        self.supported_custom_presets.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesClimateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesClimateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClimateStateResponse {
    // message fields
    pub key: u32,
    pub mode: ClimateMode,
    pub current_temperature: f32,
    pub target_temperature: f32,
    pub target_temperature_low: f32,
    pub target_temperature_high: f32,
    pub legacy_away: bool,
    pub action: ClimateAction,
    pub fan_mode: ClimateFanMode,
    pub swing_mode: ClimateSwingMode,
    pub custom_fan_mode: ::std::string::String,
    pub preset: ClimatePreset,
    pub custom_preset: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClimateStateResponse {
    fn default() -> &'a ClimateStateResponse {
        <ClimateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClimateStateResponse {
    pub fn new() -> ClimateStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // .ClimateMode mode = 2;


    pub fn get_mode(&self) -> ClimateMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = ClimateMode::CLIMATE_MODE_OFF;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ClimateMode) {
        self.mode = v;
    }

    // float current_temperature = 3;


    pub fn get_current_temperature(&self) -> f32 {
        self.current_temperature
    }
    pub fn clear_current_temperature(&mut self) {
        self.current_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_current_temperature(&mut self, v: f32) {
        self.current_temperature = v;
    }

    // float target_temperature = 4;


    pub fn get_target_temperature(&self) -> f32 {
        self.target_temperature
    }
    pub fn clear_target_temperature(&mut self) {
        self.target_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature(&mut self, v: f32) {
        self.target_temperature = v;
    }

    // float target_temperature_low = 5;


    pub fn get_target_temperature_low(&self) -> f32 {
        self.target_temperature_low
    }
    pub fn clear_target_temperature_low(&mut self) {
        self.target_temperature_low = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature_low(&mut self, v: f32) {
        self.target_temperature_low = v;
    }

    // float target_temperature_high = 6;


    pub fn get_target_temperature_high(&self) -> f32 {
        self.target_temperature_high
    }
    pub fn clear_target_temperature_high(&mut self) {
        self.target_temperature_high = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature_high(&mut self, v: f32) {
        self.target_temperature_high = v;
    }

    // bool legacy_away = 7;


    pub fn get_legacy_away(&self) -> bool {
        self.legacy_away
    }
    pub fn clear_legacy_away(&mut self) {
        self.legacy_away = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_away(&mut self, v: bool) {
        self.legacy_away = v;
    }

    // .ClimateAction action = 8;


    pub fn get_action(&self) -> ClimateAction {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = ClimateAction::CLIMATE_ACTION_OFF;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ClimateAction) {
        self.action = v;
    }

    // .ClimateFanMode fan_mode = 9;


    pub fn get_fan_mode(&self) -> ClimateFanMode {
        self.fan_mode
    }
    pub fn clear_fan_mode(&mut self) {
        self.fan_mode = ClimateFanMode::CLIMATE_FAN_ON;
    }

    // Param is passed by value, moved
    pub fn set_fan_mode(&mut self, v: ClimateFanMode) {
        self.fan_mode = v;
    }

    // .ClimateSwingMode swing_mode = 10;


    pub fn get_swing_mode(&self) -> ClimateSwingMode {
        self.swing_mode
    }
    pub fn clear_swing_mode(&mut self) {
        self.swing_mode = ClimateSwingMode::CLIMATE_SWING_OFF;
    }

    // Param is passed by value, moved
    pub fn set_swing_mode(&mut self, v: ClimateSwingMode) {
        self.swing_mode = v;
    }

    // string custom_fan_mode = 11;


    pub fn get_custom_fan_mode(&self) -> &str {
        &self.custom_fan_mode
    }
    pub fn clear_custom_fan_mode(&mut self) {
        self.custom_fan_mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_fan_mode(&mut self, v: ::std::string::String) {
        self.custom_fan_mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_fan_mode(&mut self) -> &mut ::std::string::String {
        &mut self.custom_fan_mode
    }

    // Take field
    pub fn take_custom_fan_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_fan_mode, ::std::string::String::new())
    }

    // .ClimatePreset preset = 12;


    pub fn get_preset(&self) -> ClimatePreset {
        self.preset
    }
    pub fn clear_preset(&mut self) {
        self.preset = ClimatePreset::CLIMATE_PRESET_NONE;
    }

    // Param is passed by value, moved
    pub fn set_preset(&mut self, v: ClimatePreset) {
        self.preset = v;
    }

    // string custom_preset = 13;


    pub fn get_custom_preset(&self) -> &str {
        &self.custom_preset
    }
    pub fn clear_custom_preset(&mut self) {
        self.custom_preset.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_preset(&mut self, v: ::std::string::String) {
        self.custom_preset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_preset(&mut self) -> &mut ::std::string::String {
        &mut self.custom_preset
    }

    // Take field
    pub fn take_custom_preset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_preset, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClimateStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.current_temperature = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature_low = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature_high = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_away = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.fan_mode, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.swing_mode, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_fan_mode)?;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.preset, 12, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_preset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.mode != ClimateMode::CLIMATE_MODE_OFF {
            my_size += ::protobuf::rt::enum_size(2, self.mode);
        }
        if self.current_temperature != 0. {
            my_size += 5;
        }
        if self.target_temperature != 0. {
            my_size += 5;
        }
        if self.target_temperature_low != 0. {
            my_size += 5;
        }
        if self.target_temperature_high != 0. {
            my_size += 5;
        }
        if self.legacy_away != false {
            my_size += 2;
        }
        if self.action != ClimateAction::CLIMATE_ACTION_OFF {
            my_size += ::protobuf::rt::enum_size(8, self.action);
        }
        if self.fan_mode != ClimateFanMode::CLIMATE_FAN_ON {
            my_size += ::protobuf::rt::enum_size(9, self.fan_mode);
        }
        if self.swing_mode != ClimateSwingMode::CLIMATE_SWING_OFF {
            my_size += ::protobuf::rt::enum_size(10, self.swing_mode);
        }
        if !self.custom_fan_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.custom_fan_mode);
        }
        if self.preset != ClimatePreset::CLIMATE_PRESET_NONE {
            my_size += ::protobuf::rt::enum_size(12, self.preset);
        }
        if !self.custom_preset.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.custom_preset);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.mode != ClimateMode::CLIMATE_MODE_OFF {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        if self.current_temperature != 0. {
            os.write_float(3, self.current_temperature)?;
        }
        if self.target_temperature != 0. {
            os.write_float(4, self.target_temperature)?;
        }
        if self.target_temperature_low != 0. {
            os.write_float(5, self.target_temperature_low)?;
        }
        if self.target_temperature_high != 0. {
            os.write_float(6, self.target_temperature_high)?;
        }
        if self.legacy_away != false {
            os.write_bool(7, self.legacy_away)?;
        }
        if self.action != ClimateAction::CLIMATE_ACTION_OFF {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if self.fan_mode != ClimateFanMode::CLIMATE_FAN_ON {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.fan_mode))?;
        }
        if self.swing_mode != ClimateSwingMode::CLIMATE_SWING_OFF {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.swing_mode))?;
        }
        if !self.custom_fan_mode.is_empty() {
            os.write_string(11, &self.custom_fan_mode)?;
        }
        if self.preset != ClimatePreset::CLIMATE_PRESET_NONE {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.preset))?;
        }
        if !self.custom_preset.is_empty() {
            os.write_string(13, &self.custom_preset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClimateStateResponse {
        ClimateStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ClimateStateResponse| { &m.key },
                |m: &mut ClimateStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateMode>>(
                "mode",
                |m: &ClimateStateResponse| { &m.mode },
                |m: &mut ClimateStateResponse| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "current_temperature",
                |m: &ClimateStateResponse| { &m.current_temperature },
                |m: &mut ClimateStateResponse| { &mut m.current_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature",
                |m: &ClimateStateResponse| { &m.target_temperature },
                |m: &mut ClimateStateResponse| { &mut m.target_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature_low",
                |m: &ClimateStateResponse| { &m.target_temperature_low },
                |m: &mut ClimateStateResponse| { &mut m.target_temperature_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature_high",
                |m: &ClimateStateResponse| { &m.target_temperature_high },
                |m: &mut ClimateStateResponse| { &mut m.target_temperature_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_away",
                |m: &ClimateStateResponse| { &m.legacy_away },
                |m: &mut ClimateStateResponse| { &mut m.legacy_away },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateAction>>(
                "action",
                |m: &ClimateStateResponse| { &m.action },
                |m: &mut ClimateStateResponse| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateFanMode>>(
                "fan_mode",
                |m: &ClimateStateResponse| { &m.fan_mode },
                |m: &mut ClimateStateResponse| { &mut m.fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateSwingMode>>(
                "swing_mode",
                |m: &ClimateStateResponse| { &m.swing_mode },
                |m: &mut ClimateStateResponse| { &mut m.swing_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_fan_mode",
                |m: &ClimateStateResponse| { &m.custom_fan_mode },
                |m: &mut ClimateStateResponse| { &mut m.custom_fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimatePreset>>(
                "preset",
                |m: &ClimateStateResponse| { &m.preset },
                |m: &mut ClimateStateResponse| { &mut m.preset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_preset",
                |m: &ClimateStateResponse| { &m.custom_preset },
                |m: &mut ClimateStateResponse| { &mut m.custom_preset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClimateStateResponse>(
                "ClimateStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClimateStateResponse {
        static instance: ::protobuf::rt::LazyV2<ClimateStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClimateStateResponse::new)
    }
}

impl ::protobuf::Clear for ClimateStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.mode = ClimateMode::CLIMATE_MODE_OFF;
        self.current_temperature = 0.;
        self.target_temperature = 0.;
        self.target_temperature_low = 0.;
        self.target_temperature_high = 0.;
        self.legacy_away = false;
        self.action = ClimateAction::CLIMATE_ACTION_OFF;
        self.fan_mode = ClimateFanMode::CLIMATE_FAN_ON;
        self.swing_mode = ClimateSwingMode::CLIMATE_SWING_OFF;
        self.custom_fan_mode.clear();
        self.preset = ClimatePreset::CLIMATE_PRESET_NONE;
        self.custom_preset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClimateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClimateCommandRequest {
    // message fields
    pub key: u32,
    pub has_mode: bool,
    pub mode: ClimateMode,
    pub has_target_temperature: bool,
    pub target_temperature: f32,
    pub has_target_temperature_low: bool,
    pub target_temperature_low: f32,
    pub has_target_temperature_high: bool,
    pub target_temperature_high: f32,
    pub has_legacy_away: bool,
    pub legacy_away: bool,
    pub has_fan_mode: bool,
    pub fan_mode: ClimateFanMode,
    pub has_swing_mode: bool,
    pub swing_mode: ClimateSwingMode,
    pub has_custom_fan_mode: bool,
    pub custom_fan_mode: ::std::string::String,
    pub has_preset: bool,
    pub preset: ClimatePreset,
    pub has_custom_preset: bool,
    pub custom_preset: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClimateCommandRequest {
    fn default() -> &'a ClimateCommandRequest {
        <ClimateCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClimateCommandRequest {
    pub fn new() -> ClimateCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool has_mode = 2;


    pub fn get_has_mode(&self) -> bool {
        self.has_mode
    }
    pub fn clear_has_mode(&mut self) {
        self.has_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_mode(&mut self, v: bool) {
        self.has_mode = v;
    }

    // .ClimateMode mode = 3;


    pub fn get_mode(&self) -> ClimateMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = ClimateMode::CLIMATE_MODE_OFF;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ClimateMode) {
        self.mode = v;
    }

    // bool has_target_temperature = 4;


    pub fn get_has_target_temperature(&self) -> bool {
        self.has_target_temperature
    }
    pub fn clear_has_target_temperature(&mut self) {
        self.has_target_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_has_target_temperature(&mut self, v: bool) {
        self.has_target_temperature = v;
    }

    // float target_temperature = 5;


    pub fn get_target_temperature(&self) -> f32 {
        self.target_temperature
    }
    pub fn clear_target_temperature(&mut self) {
        self.target_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature(&mut self, v: f32) {
        self.target_temperature = v;
    }

    // bool has_target_temperature_low = 6;


    pub fn get_has_target_temperature_low(&self) -> bool {
        self.has_target_temperature_low
    }
    pub fn clear_has_target_temperature_low(&mut self) {
        self.has_target_temperature_low = false;
    }

    // Param is passed by value, moved
    pub fn set_has_target_temperature_low(&mut self, v: bool) {
        self.has_target_temperature_low = v;
    }

    // float target_temperature_low = 7;


    pub fn get_target_temperature_low(&self) -> f32 {
        self.target_temperature_low
    }
    pub fn clear_target_temperature_low(&mut self) {
        self.target_temperature_low = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature_low(&mut self, v: f32) {
        self.target_temperature_low = v;
    }

    // bool has_target_temperature_high = 8;


    pub fn get_has_target_temperature_high(&self) -> bool {
        self.has_target_temperature_high
    }
    pub fn clear_has_target_temperature_high(&mut self) {
        self.has_target_temperature_high = false;
    }

    // Param is passed by value, moved
    pub fn set_has_target_temperature_high(&mut self, v: bool) {
        self.has_target_temperature_high = v;
    }

    // float target_temperature_high = 9;


    pub fn get_target_temperature_high(&self) -> f32 {
        self.target_temperature_high
    }
    pub fn clear_target_temperature_high(&mut self) {
        self.target_temperature_high = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature_high(&mut self, v: f32) {
        self.target_temperature_high = v;
    }

    // bool has_legacy_away = 10;


    pub fn get_has_legacy_away(&self) -> bool {
        self.has_legacy_away
    }
    pub fn clear_has_legacy_away(&mut self) {
        self.has_legacy_away = false;
    }

    // Param is passed by value, moved
    pub fn set_has_legacy_away(&mut self, v: bool) {
        self.has_legacy_away = v;
    }

    // bool legacy_away = 11;


    pub fn get_legacy_away(&self) -> bool {
        self.legacy_away
    }
    pub fn clear_legacy_away(&mut self) {
        self.legacy_away = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_away(&mut self, v: bool) {
        self.legacy_away = v;
    }

    // bool has_fan_mode = 12;


    pub fn get_has_fan_mode(&self) -> bool {
        self.has_fan_mode
    }
    pub fn clear_has_fan_mode(&mut self) {
        self.has_fan_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_fan_mode(&mut self, v: bool) {
        self.has_fan_mode = v;
    }

    // .ClimateFanMode fan_mode = 13;


    pub fn get_fan_mode(&self) -> ClimateFanMode {
        self.fan_mode
    }
    pub fn clear_fan_mode(&mut self) {
        self.fan_mode = ClimateFanMode::CLIMATE_FAN_ON;
    }

    // Param is passed by value, moved
    pub fn set_fan_mode(&mut self, v: ClimateFanMode) {
        self.fan_mode = v;
    }

    // bool has_swing_mode = 14;


    pub fn get_has_swing_mode(&self) -> bool {
        self.has_swing_mode
    }
    pub fn clear_has_swing_mode(&mut self) {
        self.has_swing_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_swing_mode(&mut self, v: bool) {
        self.has_swing_mode = v;
    }

    // .ClimateSwingMode swing_mode = 15;


    pub fn get_swing_mode(&self) -> ClimateSwingMode {
        self.swing_mode
    }
    pub fn clear_swing_mode(&mut self) {
        self.swing_mode = ClimateSwingMode::CLIMATE_SWING_OFF;
    }

    // Param is passed by value, moved
    pub fn set_swing_mode(&mut self, v: ClimateSwingMode) {
        self.swing_mode = v;
    }

    // bool has_custom_fan_mode = 16;


    pub fn get_has_custom_fan_mode(&self) -> bool {
        self.has_custom_fan_mode
    }
    pub fn clear_has_custom_fan_mode(&mut self) {
        self.has_custom_fan_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_custom_fan_mode(&mut self, v: bool) {
        self.has_custom_fan_mode = v;
    }

    // string custom_fan_mode = 17;


    pub fn get_custom_fan_mode(&self) -> &str {
        &self.custom_fan_mode
    }
    pub fn clear_custom_fan_mode(&mut self) {
        self.custom_fan_mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_fan_mode(&mut self, v: ::std::string::String) {
        self.custom_fan_mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_fan_mode(&mut self) -> &mut ::std::string::String {
        &mut self.custom_fan_mode
    }

    // Take field
    pub fn take_custom_fan_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_fan_mode, ::std::string::String::new())
    }

    // bool has_preset = 18;


    pub fn get_has_preset(&self) -> bool {
        self.has_preset
    }
    pub fn clear_has_preset(&mut self) {
        self.has_preset = false;
    }

    // Param is passed by value, moved
    pub fn set_has_preset(&mut self, v: bool) {
        self.has_preset = v;
    }

    // .ClimatePreset preset = 19;


    pub fn get_preset(&self) -> ClimatePreset {
        self.preset
    }
    pub fn clear_preset(&mut self) {
        self.preset = ClimatePreset::CLIMATE_PRESET_NONE;
    }

    // Param is passed by value, moved
    pub fn set_preset(&mut self, v: ClimatePreset) {
        self.preset = v;
    }

    // bool has_custom_preset = 20;


    pub fn get_has_custom_preset(&self) -> bool {
        self.has_custom_preset
    }
    pub fn clear_has_custom_preset(&mut self) {
        self.has_custom_preset = false;
    }

    // Param is passed by value, moved
    pub fn set_has_custom_preset(&mut self, v: bool) {
        self.has_custom_preset = v;
    }

    // string custom_preset = 21;


    pub fn get_custom_preset(&self) -> &str {
        &self.custom_preset
    }
    pub fn clear_custom_preset(&mut self) {
        self.custom_preset.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_preset(&mut self, v: ::std::string::String) {
        self.custom_preset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_preset(&mut self) -> &mut ::std::string::String {
        &mut self.custom_preset
    }

    // Take field
    pub fn take_custom_preset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_preset, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClimateCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_mode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_target_temperature = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_target_temperature_low = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature_low = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_target_temperature_high = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature_high = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_legacy_away = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_away = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_fan_mode = tmp;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.fan_mode, 13, &mut self.unknown_fields)?
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_swing_mode = tmp;
                },
                15 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.swing_mode, 15, &mut self.unknown_fields)?
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_custom_fan_mode = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_fan_mode)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_preset = tmp;
                },
                19 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.preset, 19, &mut self.unknown_fields)?
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_custom_preset = tmp;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_preset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.has_mode != false {
            my_size += 2;
        }
        if self.mode != ClimateMode::CLIMATE_MODE_OFF {
            my_size += ::protobuf::rt::enum_size(3, self.mode);
        }
        if self.has_target_temperature != false {
            my_size += 2;
        }
        if self.target_temperature != 0. {
            my_size += 5;
        }
        if self.has_target_temperature_low != false {
            my_size += 2;
        }
        if self.target_temperature_low != 0. {
            my_size += 5;
        }
        if self.has_target_temperature_high != false {
            my_size += 2;
        }
        if self.target_temperature_high != 0. {
            my_size += 5;
        }
        if self.has_legacy_away != false {
            my_size += 2;
        }
        if self.legacy_away != false {
            my_size += 2;
        }
        if self.has_fan_mode != false {
            my_size += 2;
        }
        if self.fan_mode != ClimateFanMode::CLIMATE_FAN_ON {
            my_size += ::protobuf::rt::enum_size(13, self.fan_mode);
        }
        if self.has_swing_mode != false {
            my_size += 2;
        }
        if self.swing_mode != ClimateSwingMode::CLIMATE_SWING_OFF {
            my_size += ::protobuf::rt::enum_size(15, self.swing_mode);
        }
        if self.has_custom_fan_mode != false {
            my_size += 3;
        }
        if !self.custom_fan_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.custom_fan_mode);
        }
        if self.has_preset != false {
            my_size += 3;
        }
        if self.preset != ClimatePreset::CLIMATE_PRESET_NONE {
            my_size += ::protobuf::rt::enum_size(19, self.preset);
        }
        if self.has_custom_preset != false {
            my_size += 3;
        }
        if !self.custom_preset.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.custom_preset);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_mode != false {
            os.write_bool(2, self.has_mode)?;
        }
        if self.mode != ClimateMode::CLIMATE_MODE_OFF {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        if self.has_target_temperature != false {
            os.write_bool(4, self.has_target_temperature)?;
        }
        if self.target_temperature != 0. {
            os.write_float(5, self.target_temperature)?;
        }
        if self.has_target_temperature_low != false {
            os.write_bool(6, self.has_target_temperature_low)?;
        }
        if self.target_temperature_low != 0. {
            os.write_float(7, self.target_temperature_low)?;
        }
        if self.has_target_temperature_high != false {
            os.write_bool(8, self.has_target_temperature_high)?;
        }
        if self.target_temperature_high != 0. {
            os.write_float(9, self.target_temperature_high)?;
        }
        if self.has_legacy_away != false {
            os.write_bool(10, self.has_legacy_away)?;
        }
        if self.legacy_away != false {
            os.write_bool(11, self.legacy_away)?;
        }
        if self.has_fan_mode != false {
            os.write_bool(12, self.has_fan_mode)?;
        }
        if self.fan_mode != ClimateFanMode::CLIMATE_FAN_ON {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&self.fan_mode))?;
        }
        if self.has_swing_mode != false {
            os.write_bool(14, self.has_swing_mode)?;
        }
        if self.swing_mode != ClimateSwingMode::CLIMATE_SWING_OFF {
            os.write_enum(15, ::protobuf::ProtobufEnum::value(&self.swing_mode))?;
        }
        if self.has_custom_fan_mode != false {
            os.write_bool(16, self.has_custom_fan_mode)?;
        }
        if !self.custom_fan_mode.is_empty() {
            os.write_string(17, &self.custom_fan_mode)?;
        }
        if self.has_preset != false {
            os.write_bool(18, self.has_preset)?;
        }
        if self.preset != ClimatePreset::CLIMATE_PRESET_NONE {
            os.write_enum(19, ::protobuf::ProtobufEnum::value(&self.preset))?;
        }
        if self.has_custom_preset != false {
            os.write_bool(20, self.has_custom_preset)?;
        }
        if !self.custom_preset.is_empty() {
            os.write_string(21, &self.custom_preset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClimateCommandRequest {
        ClimateCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ClimateCommandRequest| { &m.key },
                |m: &mut ClimateCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_mode",
                |m: &ClimateCommandRequest| { &m.has_mode },
                |m: &mut ClimateCommandRequest| { &mut m.has_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateMode>>(
                "mode",
                |m: &ClimateCommandRequest| { &m.mode },
                |m: &mut ClimateCommandRequest| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_target_temperature",
                |m: &ClimateCommandRequest| { &m.has_target_temperature },
                |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature",
                |m: &ClimateCommandRequest| { &m.target_temperature },
                |m: &mut ClimateCommandRequest| { &mut m.target_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_target_temperature_low",
                |m: &ClimateCommandRequest| { &m.has_target_temperature_low },
                |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature_low",
                |m: &ClimateCommandRequest| { &m.target_temperature_low },
                |m: &mut ClimateCommandRequest| { &mut m.target_temperature_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_target_temperature_high",
                |m: &ClimateCommandRequest| { &m.has_target_temperature_high },
                |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature_high",
                |m: &ClimateCommandRequest| { &m.target_temperature_high },
                |m: &mut ClimateCommandRequest| { &mut m.target_temperature_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_legacy_away",
                |m: &ClimateCommandRequest| { &m.has_legacy_away },
                |m: &mut ClimateCommandRequest| { &mut m.has_legacy_away },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_away",
                |m: &ClimateCommandRequest| { &m.legacy_away },
                |m: &mut ClimateCommandRequest| { &mut m.legacy_away },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_fan_mode",
                |m: &ClimateCommandRequest| { &m.has_fan_mode },
                |m: &mut ClimateCommandRequest| { &mut m.has_fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateFanMode>>(
                "fan_mode",
                |m: &ClimateCommandRequest| { &m.fan_mode },
                |m: &mut ClimateCommandRequest| { &mut m.fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_swing_mode",
                |m: &ClimateCommandRequest| { &m.has_swing_mode },
                |m: &mut ClimateCommandRequest| { &mut m.has_swing_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateSwingMode>>(
                "swing_mode",
                |m: &ClimateCommandRequest| { &m.swing_mode },
                |m: &mut ClimateCommandRequest| { &mut m.swing_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_custom_fan_mode",
                |m: &ClimateCommandRequest| { &m.has_custom_fan_mode },
                |m: &mut ClimateCommandRequest| { &mut m.has_custom_fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_fan_mode",
                |m: &ClimateCommandRequest| { &m.custom_fan_mode },
                |m: &mut ClimateCommandRequest| { &mut m.custom_fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_preset",
                |m: &ClimateCommandRequest| { &m.has_preset },
                |m: &mut ClimateCommandRequest| { &mut m.has_preset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimatePreset>>(
                "preset",
                |m: &ClimateCommandRequest| { &m.preset },
                |m: &mut ClimateCommandRequest| { &mut m.preset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_custom_preset",
                |m: &ClimateCommandRequest| { &m.has_custom_preset },
                |m: &mut ClimateCommandRequest| { &mut m.has_custom_preset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_preset",
                |m: &ClimateCommandRequest| { &m.custom_preset },
                |m: &mut ClimateCommandRequest| { &mut m.custom_preset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClimateCommandRequest>(
                "ClimateCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClimateCommandRequest {
        static instance: ::protobuf::rt::LazyV2<ClimateCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClimateCommandRequest::new)
    }
}

impl ::protobuf::Clear for ClimateCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.has_mode = false;
        self.mode = ClimateMode::CLIMATE_MODE_OFF;
        self.has_target_temperature = false;
        self.target_temperature = 0.;
        self.has_target_temperature_low = false;
        self.target_temperature_low = 0.;
        self.has_target_temperature_high = false;
        self.target_temperature_high = 0.;
        self.has_legacy_away = false;
        self.legacy_away = false;
        self.has_fan_mode = false;
        self.fan_mode = ClimateFanMode::CLIMATE_FAN_ON;
        self.has_swing_mode = false;
        self.swing_mode = ClimateSwingMode::CLIMATE_SWING_OFF;
        self.has_custom_fan_mode = false;
        self.custom_fan_mode.clear();
        self.has_preset = false;
        self.preset = ClimatePreset::CLIMATE_PRESET_NONE;
        self.has_custom_preset = false;
        self.custom_preset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClimateCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesNumberResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub min_value: f32,
    pub max_value: f32,
    pub step: f32,
    pub disabled_by_default: bool,
    pub entity_category: EntityCategory,
    pub unit_of_measurement: ::std::string::String,
    pub mode: NumberMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesNumberResponse {
    fn default() -> &'a ListEntitiesNumberResponse {
        <ListEntitiesNumberResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesNumberResponse {
    pub fn new() -> ListEntitiesNumberResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // float min_value = 6;


    pub fn get_min_value(&self) -> f32 {
        self.min_value
    }
    pub fn clear_min_value(&mut self) {
        self.min_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_value(&mut self, v: f32) {
        self.min_value = v;
    }

    // float max_value = 7;


    pub fn get_max_value(&self) -> f32 {
        self.max_value
    }
    pub fn clear_max_value(&mut self) {
        self.max_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_value(&mut self, v: f32) {
        self.max_value = v;
    }

    // float step = 8;


    pub fn get_step(&self) -> f32 {
        self.step
    }
    pub fn clear_step(&mut self) {
        self.step = 0.;
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: f32) {
        self.step = v;
    }

    // bool disabled_by_default = 9;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // .EntityCategory entity_category = 10;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }

    // string unit_of_measurement = 11;


    pub fn get_unit_of_measurement(&self) -> &str {
        &self.unit_of_measurement
    }
    pub fn clear_unit_of_measurement(&mut self) {
        self.unit_of_measurement.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_of_measurement(&mut self, v: ::std::string::String) {
        self.unit_of_measurement = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_of_measurement(&mut self) -> &mut ::std::string::String {
        &mut self.unit_of_measurement
    }

    // Take field
    pub fn take_unit_of_measurement(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unit_of_measurement, ::std::string::String::new())
    }

    // .NumberMode mode = 12;


    pub fn get_mode(&self) -> NumberMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = NumberMode::NUMBER_MODE_AUTO;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: NumberMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for ListEntitiesNumberResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min_value = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_value = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.step = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unit_of_measurement)?;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 12, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.min_value != 0. {
            my_size += 5;
        }
        if self.max_value != 0. {
            my_size += 5;
        }
        if self.step != 0. {
            my_size += 5;
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(10, self.entity_category);
        }
        if !self.unit_of_measurement.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.unit_of_measurement);
        }
        if self.mode != NumberMode::NUMBER_MODE_AUTO {
            my_size += ::protobuf::rt::enum_size(12, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.min_value != 0. {
            os.write_float(6, self.min_value)?;
        }
        if self.max_value != 0. {
            os.write_float(7, self.max_value)?;
        }
        if self.step != 0. {
            os.write_float(8, self.step)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        if !self.unit_of_measurement.is_empty() {
            os.write_string(11, &self.unit_of_measurement)?;
        }
        if self.mode != NumberMode::NUMBER_MODE_AUTO {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesNumberResponse {
        ListEntitiesNumberResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesNumberResponse| { &m.object_id },
                |m: &mut ListEntitiesNumberResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesNumberResponse| { &m.key },
                |m: &mut ListEntitiesNumberResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesNumberResponse| { &m.name },
                |m: &mut ListEntitiesNumberResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesNumberResponse| { &m.unique_id },
                |m: &mut ListEntitiesNumberResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesNumberResponse| { &m.icon },
                |m: &mut ListEntitiesNumberResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "min_value",
                |m: &ListEntitiesNumberResponse| { &m.min_value },
                |m: &mut ListEntitiesNumberResponse| { &mut m.min_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max_value",
                |m: &ListEntitiesNumberResponse| { &m.max_value },
                |m: &mut ListEntitiesNumberResponse| { &mut m.max_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "step",
                |m: &ListEntitiesNumberResponse| { &m.step },
                |m: &mut ListEntitiesNumberResponse| { &mut m.step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesNumberResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesNumberResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesNumberResponse| { &m.entity_category },
                |m: &mut ListEntitiesNumberResponse| { &mut m.entity_category },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unit_of_measurement",
                |m: &ListEntitiesNumberResponse| { &m.unit_of_measurement },
                |m: &mut ListEntitiesNumberResponse| { &mut m.unit_of_measurement },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NumberMode>>(
                "mode",
                |m: &ListEntitiesNumberResponse| { &m.mode },
                |m: &mut ListEntitiesNumberResponse| { &mut m.mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesNumberResponse>(
                "ListEntitiesNumberResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesNumberResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesNumberResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesNumberResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesNumberResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.min_value = 0.;
        self.max_value = 0.;
        self.step = 0.;
        self.disabled_by_default = false;
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unit_of_measurement.clear();
        self.mode = NumberMode::NUMBER_MODE_AUTO;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesNumberResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesNumberResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NumberStateResponse {
    // message fields
    pub key: u32,
    pub state: f32,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NumberStateResponse {
    fn default() -> &'a NumberStateResponse {
        <NumberStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl NumberStateResponse {
    pub fn new() -> NumberStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // float state = 2;


    pub fn get_state(&self) -> f32 {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = 0.;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: f32) {
        self.state = v;
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for NumberStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != 0. {
            my_size += 5;
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NumberStateResponse {
        NumberStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &NumberStateResponse| { &m.key },
                |m: &mut NumberStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "state",
                |m: &NumberStateResponse| { &m.state },
                |m: &mut NumberStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &NumberStateResponse| { &m.missing_state },
                |m: &mut NumberStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NumberStateResponse>(
                "NumberStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NumberStateResponse {
        static instance: ::protobuf::rt::LazyV2<NumberStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NumberStateResponse::new)
    }
}

impl ::protobuf::Clear for NumberStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NumberStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NumberCommandRequest {
    // message fields
    pub key: u32,
    pub state: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NumberCommandRequest {
    fn default() -> &'a NumberCommandRequest {
        <NumberCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl NumberCommandRequest {
    pub fn new() -> NumberCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // float state = 2;


    pub fn get_state(&self) -> f32 {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = 0.;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: f32) {
        self.state = v;
    }
}

impl ::protobuf::Message for NumberCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NumberCommandRequest {
        NumberCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &NumberCommandRequest| { &m.key },
                |m: &mut NumberCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "state",
                |m: &NumberCommandRequest| { &m.state },
                |m: &mut NumberCommandRequest| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NumberCommandRequest>(
                "NumberCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NumberCommandRequest {
        static instance: ::protobuf::rt::LazyV2<NumberCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NumberCommandRequest::new)
    }
}

impl ::protobuf::Clear for NumberCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NumberCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesSelectResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub options: ::protobuf::RepeatedField<::std::string::String>,
    pub disabled_by_default: bool,
    pub entity_category: EntityCategory,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSelectResponse {
    fn default() -> &'a ListEntitiesSelectResponse {
        <ListEntitiesSelectResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSelectResponse {
    pub fn new() -> ListEntitiesSelectResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // repeated string options = 6;


    pub fn get_options(&self) -> &[::std::string::String] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }

    // bool disabled_by_default = 7;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // .EntityCategory entity_category = 8;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }
}

impl ::protobuf::Message for ListEntitiesSelectResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.options)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(8, self.entity_category);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        for v in &self.options {
            os.write_string(6, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesSelectResponse {
        ListEntitiesSelectResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesSelectResponse| { &m.object_id },
                |m: &mut ListEntitiesSelectResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesSelectResponse| { &m.key },
                |m: &mut ListEntitiesSelectResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesSelectResponse| { &m.name },
                |m: &mut ListEntitiesSelectResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesSelectResponse| { &m.unique_id },
                |m: &mut ListEntitiesSelectResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesSelectResponse| { &m.icon },
                |m: &mut ListEntitiesSelectResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "options",
                |m: &ListEntitiesSelectResponse| { &m.options },
                |m: &mut ListEntitiesSelectResponse| { &mut m.options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesSelectResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesSelectResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesSelectResponse| { &m.entity_category },
                |m: &mut ListEntitiesSelectResponse| { &mut m.entity_category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesSelectResponse>(
                "ListEntitiesSelectResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesSelectResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesSelectResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesSelectResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesSelectResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.options.clear();
        self.disabled_by_default = false;
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesSelectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSelectResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelectStateResponse {
    // message fields
    pub key: u32,
    pub state: ::std::string::String,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelectStateResponse {
    fn default() -> &'a SelectStateResponse {
        <SelectStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SelectStateResponse {
    pub fn new() -> SelectStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string state = 2;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for SelectStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelectStateResponse {
        SelectStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SelectStateResponse| { &m.key },
                |m: &mut SelectStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &SelectStateResponse| { &m.state },
                |m: &mut SelectStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &SelectStateResponse| { &m.missing_state },
                |m: &mut SelectStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelectStateResponse>(
                "SelectStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelectStateResponse {
        static instance: ::protobuf::rt::LazyV2<SelectStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelectStateResponse::new)
    }
}

impl ::protobuf::Clear for SelectStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelectStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelectCommandRequest {
    // message fields
    pub key: u32,
    pub state: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelectCommandRequest {
    fn default() -> &'a SelectCommandRequest {
        <SelectCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl SelectCommandRequest {
    pub fn new() -> SelectCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string state = 2;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SelectCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelectCommandRequest {
        SelectCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SelectCommandRequest| { &m.key },
                |m: &mut SelectCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &SelectCommandRequest| { &m.state },
                |m: &mut SelectCommandRequest| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelectCommandRequest>(
                "SelectCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelectCommandRequest {
        static instance: ::protobuf::rt::LazyV2<SelectCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelectCommandRequest::new)
    }
}

impl ::protobuf::Clear for SelectCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelectCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesLockResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub disabled_by_default: bool,
    pub entity_category: EntityCategory,
    pub assumed_state: bool,
    pub supports_open: bool,
    pub requires_code: bool,
    pub code_format: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesLockResponse {
    fn default() -> &'a ListEntitiesLockResponse {
        <ListEntitiesLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesLockResponse {
    pub fn new() -> ListEntitiesLockResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // bool disabled_by_default = 6;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // .EntityCategory entity_category = 7;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }

    // bool assumed_state = 8;


    pub fn get_assumed_state(&self) -> bool {
        self.assumed_state
    }
    pub fn clear_assumed_state(&mut self) {
        self.assumed_state = false;
    }

    // Param is passed by value, moved
    pub fn set_assumed_state(&mut self, v: bool) {
        self.assumed_state = v;
    }

    // bool supports_open = 9;


    pub fn get_supports_open(&self) -> bool {
        self.supports_open
    }
    pub fn clear_supports_open(&mut self) {
        self.supports_open = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_open(&mut self, v: bool) {
        self.supports_open = v;
    }

    // bool requires_code = 10;


    pub fn get_requires_code(&self) -> bool {
        self.requires_code
    }
    pub fn clear_requires_code(&mut self) {
        self.requires_code = false;
    }

    // Param is passed by value, moved
    pub fn set_requires_code(&mut self, v: bool) {
        self.requires_code = v;
    }

    // string code_format = 11;


    pub fn get_code_format(&self) -> &str {
        &self.code_format
    }
    pub fn clear_code_format(&mut self) {
        self.code_format.clear();
    }

    // Param is passed by value, moved
    pub fn set_code_format(&mut self, v: ::std::string::String) {
        self.code_format = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_format(&mut self) -> &mut ::std::string::String {
        &mut self.code_format
    }

    // Take field
    pub fn take_code_format(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code_format, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListEntitiesLockResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.assumed_state = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_open = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requires_code = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code_format)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(7, self.entity_category);
        }
        if self.assumed_state != false {
            my_size += 2;
        }
        if self.supports_open != false {
            my_size += 2;
        }
        if self.requires_code != false {
            my_size += 2;
        }
        if !self.code_format.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.code_format);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        if self.assumed_state != false {
            os.write_bool(8, self.assumed_state)?;
        }
        if self.supports_open != false {
            os.write_bool(9, self.supports_open)?;
        }
        if self.requires_code != false {
            os.write_bool(10, self.requires_code)?;
        }
        if !self.code_format.is_empty() {
            os.write_string(11, &self.code_format)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesLockResponse {
        ListEntitiesLockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesLockResponse| { &m.object_id },
                |m: &mut ListEntitiesLockResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesLockResponse| { &m.key },
                |m: &mut ListEntitiesLockResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesLockResponse| { &m.name },
                |m: &mut ListEntitiesLockResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesLockResponse| { &m.unique_id },
                |m: &mut ListEntitiesLockResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesLockResponse| { &m.icon },
                |m: &mut ListEntitiesLockResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesLockResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesLockResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesLockResponse| { &m.entity_category },
                |m: &mut ListEntitiesLockResponse| { &mut m.entity_category },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "assumed_state",
                |m: &ListEntitiesLockResponse| { &m.assumed_state },
                |m: &mut ListEntitiesLockResponse| { &mut m.assumed_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_open",
                |m: &ListEntitiesLockResponse| { &m.supports_open },
                |m: &mut ListEntitiesLockResponse| { &mut m.supports_open },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requires_code",
                |m: &ListEntitiesLockResponse| { &m.requires_code },
                |m: &mut ListEntitiesLockResponse| { &mut m.requires_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "code_format",
                |m: &ListEntitiesLockResponse| { &m.code_format },
                |m: &mut ListEntitiesLockResponse| { &mut m.code_format },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesLockResponse>(
                "ListEntitiesLockResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesLockResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesLockResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesLockResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesLockResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.assumed_state = false;
        self.supports_open = false;
        self.requires_code = false;
        self.code_format.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesLockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesLockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockStateResponse {
    // message fields
    pub key: u32,
    pub state: LockState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockStateResponse {
    fn default() -> &'a LockStateResponse {
        <LockStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl LockStateResponse {
    pub fn new() -> LockStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // .LockState state = 2;


    pub fn get_state(&self) -> LockState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = LockState::LOCK_STATE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: LockState) {
        self.state = v;
    }
}

impl ::protobuf::Message for LockStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != LockState::LOCK_STATE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != LockState::LOCK_STATE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockStateResponse {
        LockStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &LockStateResponse| { &m.key },
                |m: &mut LockStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LockState>>(
                "state",
                |m: &LockStateResponse| { &m.state },
                |m: &mut LockStateResponse| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LockStateResponse>(
                "LockStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LockStateResponse {
        static instance: ::protobuf::rt::LazyV2<LockStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockStateResponse::new)
    }
}

impl ::protobuf::Clear for LockStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = LockState::LOCK_STATE_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockCommandRequest {
    // message fields
    pub key: u32,
    pub command: LockCommand,
    pub has_code: bool,
    pub code: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockCommandRequest {
    fn default() -> &'a LockCommandRequest {
        <LockCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl LockCommandRequest {
    pub fn new() -> LockCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // .LockCommand command = 2;


    pub fn get_command(&self) -> LockCommand {
        self.command
    }
    pub fn clear_command(&mut self) {
        self.command = LockCommand::LOCK_UNLOCK;
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: LockCommand) {
        self.command = v;
    }

    // bool has_code = 3;


    pub fn get_has_code(&self) -> bool {
        self.has_code
    }
    pub fn clear_has_code(&mut self) {
        self.has_code = false;
    }

    // Param is passed by value, moved
    pub fn set_has_code(&mut self, v: bool) {
        self.has_code = v;
    }

    // string code = 4;


    pub fn get_code(&self) -> &str {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LockCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.command, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_code = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.command != LockCommand::LOCK_UNLOCK {
            my_size += ::protobuf::rt::enum_size(2, self.command);
        }
        if self.has_code != false {
            my_size += 2;
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.command != LockCommand::LOCK_UNLOCK {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.command))?;
        }
        if self.has_code != false {
            os.write_bool(3, self.has_code)?;
        }
        if !self.code.is_empty() {
            os.write_string(4, &self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockCommandRequest {
        LockCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &LockCommandRequest| { &m.key },
                |m: &mut LockCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LockCommand>>(
                "command",
                |m: &LockCommandRequest| { &m.command },
                |m: &mut LockCommandRequest| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_code",
                |m: &LockCommandRequest| { &m.has_code },
                |m: &mut LockCommandRequest| { &mut m.has_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "code",
                |m: &LockCommandRequest| { &m.code },
                |m: &mut LockCommandRequest| { &mut m.code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LockCommandRequest>(
                "LockCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LockCommandRequest {
        static instance: ::protobuf::rt::LazyV2<LockCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockCommandRequest::new)
    }
}

impl ::protobuf::Clear for LockCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.command = LockCommand::LOCK_UNLOCK;
        self.has_code = false;
        self.code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesButtonResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub disabled_by_default: bool,
    pub entity_category: EntityCategory,
    pub device_class: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesButtonResponse {
    fn default() -> &'a ListEntitiesButtonResponse {
        <ListEntitiesButtonResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesButtonResponse {
    pub fn new() -> ListEntitiesButtonResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // bool disabled_by_default = 6;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }

    // .EntityCategory entity_category = 7;


    pub fn get_entity_category(&self) -> EntityCategory {
        self.entity_category
    }
    pub fn clear_entity_category(&mut self) {
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
    }

    // Param is passed by value, moved
    pub fn set_entity_category(&mut self, v: EntityCategory) {
        self.entity_category = v;
    }

    // string device_class = 8;


    pub fn get_device_class(&self) -> &str {
        &self.device_class
    }
    pub fn clear_device_class(&mut self) {
        self.device_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_class(&mut self, v: ::std::string::String) {
        self.device_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_class(&mut self) -> &mut ::std::string::String {
        &mut self.device_class
    }

    // Take field
    pub fn take_device_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_class, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListEntitiesButtonResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.entity_category, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_class)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            my_size += ::protobuf::rt::enum_size(7, self.entity_category);
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != EntityCategory::ENTITY_CATEGORY_NONE {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesButtonResponse {
        ListEntitiesButtonResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesButtonResponse| { &m.object_id },
                |m: &mut ListEntitiesButtonResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesButtonResponse| { &m.key },
                |m: &mut ListEntitiesButtonResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesButtonResponse| { &m.name },
                |m: &mut ListEntitiesButtonResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesButtonResponse| { &m.unique_id },
                |m: &mut ListEntitiesButtonResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesButtonResponse| { &m.icon },
                |m: &mut ListEntitiesButtonResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesButtonResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesButtonResponse| { &mut m.disabled_by_default },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityCategory>>(
                "entity_category",
                |m: &ListEntitiesButtonResponse| { &m.entity_category },
                |m: &mut ListEntitiesButtonResponse| { &mut m.entity_category },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_class",
                |m: &ListEntitiesButtonResponse| { &m.device_class },
                |m: &mut ListEntitiesButtonResponse| { &mut m.device_class },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesButtonResponse>(
                "ListEntitiesButtonResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesButtonResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesButtonResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesButtonResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesButtonResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = EntityCategory::ENTITY_CATEGORY_NONE;
        self.device_class.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesButtonResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesButtonResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ButtonCommandRequest {
    // message fields
    pub key: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ButtonCommandRequest {
    fn default() -> &'a ButtonCommandRequest {
        <ButtonCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl ButtonCommandRequest {
    pub fn new() -> ButtonCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }
}

impl ::protobuf::Message for ButtonCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ButtonCommandRequest {
        ButtonCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ButtonCommandRequest| { &m.key },
                |m: &mut ButtonCommandRequest| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ButtonCommandRequest>(
                "ButtonCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ButtonCommandRequest {
        static instance: ::protobuf::rt::LazyV2<ButtonCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ButtonCommandRequest::new)
    }
}

impl ::protobuf::Clear for ButtonCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ButtonCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EntityCategory {
    ENTITY_CATEGORY_NONE = 0,
    ENTITY_CATEGORY_CONFIG = 1,
    ENTITY_CATEGORY_DIAGNOSTIC = 2,
}

impl ::protobuf::ProtobufEnum for EntityCategory {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EntityCategory> {
        match value {
            0 => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_NONE),
            1 => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_CONFIG),
            2 => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_DIAGNOSTIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EntityCategory] = &[
            EntityCategory::ENTITY_CATEGORY_NONE,
            EntityCategory::ENTITY_CATEGORY_CONFIG,
            EntityCategory::ENTITY_CATEGORY_DIAGNOSTIC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EntityCategory>("EntityCategory", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EntityCategory {
}

impl ::std::default::Default for EntityCategory {
    fn default() -> Self {
        EntityCategory::ENTITY_CATEGORY_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityCategory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LegacyCoverState {
    LEGACY_COVER_STATE_OPEN = 0,
    LEGACY_COVER_STATE_CLOSED = 1,
}

impl ::protobuf::ProtobufEnum for LegacyCoverState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LegacyCoverState> {
        match value {
            0 => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_OPEN),
            1 => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_CLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LegacyCoverState] = &[
            LegacyCoverState::LEGACY_COVER_STATE_OPEN,
            LegacyCoverState::LEGACY_COVER_STATE_CLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LegacyCoverState>("LegacyCoverState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LegacyCoverState {
}

impl ::std::default::Default for LegacyCoverState {
    fn default() -> Self {
        LegacyCoverState::LEGACY_COVER_STATE_OPEN
    }
}

impl ::protobuf::reflect::ProtobufValue for LegacyCoverState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CoverOperation {
    COVER_OPERATION_IDLE = 0,
    COVER_OPERATION_IS_OPENING = 1,
    COVER_OPERATION_IS_CLOSING = 2,
}

impl ::protobuf::ProtobufEnum for CoverOperation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CoverOperation> {
        match value {
            0 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IDLE),
            1 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_OPENING),
            2 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_CLOSING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CoverOperation] = &[
            CoverOperation::COVER_OPERATION_IDLE,
            CoverOperation::COVER_OPERATION_IS_OPENING,
            CoverOperation::COVER_OPERATION_IS_CLOSING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CoverOperation>("CoverOperation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CoverOperation {
}

impl ::std::default::Default for CoverOperation {
    fn default() -> Self {
        CoverOperation::COVER_OPERATION_IDLE
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverOperation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LegacyCoverCommand {
    LEGACY_COVER_COMMAND_OPEN = 0,
    LEGACY_COVER_COMMAND_CLOSE = 1,
    LEGACY_COVER_COMMAND_STOP = 2,
}

impl ::protobuf::ProtobufEnum for LegacyCoverCommand {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LegacyCoverCommand> {
        match value {
            0 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN),
            1 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_CLOSE),
            2 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_STOP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LegacyCoverCommand] = &[
            LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN,
            LegacyCoverCommand::LEGACY_COVER_COMMAND_CLOSE,
            LegacyCoverCommand::LEGACY_COVER_COMMAND_STOP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LegacyCoverCommand>("LegacyCoverCommand", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LegacyCoverCommand {
}

impl ::std::default::Default for LegacyCoverCommand {
    fn default() -> Self {
        LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN
    }
}

impl ::protobuf::reflect::ProtobufValue for LegacyCoverCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FanSpeed {
    FAN_SPEED_LOW = 0,
    FAN_SPEED_MEDIUM = 1,
    FAN_SPEED_HIGH = 2,
}

impl ::protobuf::ProtobufEnum for FanSpeed {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FanSpeed> {
        match value {
            0 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_LOW),
            1 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_MEDIUM),
            2 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_HIGH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FanSpeed] = &[
            FanSpeed::FAN_SPEED_LOW,
            FanSpeed::FAN_SPEED_MEDIUM,
            FanSpeed::FAN_SPEED_HIGH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FanSpeed>("FanSpeed", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FanSpeed {
}

impl ::std::default::Default for FanSpeed {
    fn default() -> Self {
        FanSpeed::FAN_SPEED_LOW
    }
}

impl ::protobuf::reflect::ProtobufValue for FanSpeed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FanDirection {
    FAN_DIRECTION_FORWARD = 0,
    FAN_DIRECTION_REVERSE = 1,
}

impl ::protobuf::ProtobufEnum for FanDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FanDirection> {
        match value {
            0 => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_FORWARD),
            1 => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_REVERSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FanDirection] = &[
            FanDirection::FAN_DIRECTION_FORWARD,
            FanDirection::FAN_DIRECTION_REVERSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FanDirection>("FanDirection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FanDirection {
}

impl ::std::default::Default for FanDirection {
    fn default() -> Self {
        FanDirection::FAN_DIRECTION_FORWARD
    }
}

impl ::protobuf::reflect::ProtobufValue for FanDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ColorMode {
    COLOR_MODE_UNKNOWN = 0,
    COLOR_MODE_ON_OFF = 1,
    COLOR_MODE_BRIGHTNESS = 2,
    COLOR_MODE_WHITE = 7,
    COLOR_MODE_COLOR_TEMPERATURE = 11,
    COLOR_MODE_COLD_WARM_WHITE = 19,
    COLOR_MODE_RGB = 35,
    COLOR_MODE_RGB_WHITE = 39,
    COLOR_MODE_RGB_COLOR_TEMPERATURE = 47,
    COLOR_MODE_RGB_COLD_WARM_WHITE = 51,
}

impl ::protobuf::ProtobufEnum for ColorMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ColorMode> {
        match value {
            0 => ::std::option::Option::Some(ColorMode::COLOR_MODE_UNKNOWN),
            1 => ::std::option::Option::Some(ColorMode::COLOR_MODE_ON_OFF),
            2 => ::std::option::Option::Some(ColorMode::COLOR_MODE_BRIGHTNESS),
            7 => ::std::option::Option::Some(ColorMode::COLOR_MODE_WHITE),
            11 => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLOR_TEMPERATURE),
            19 => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLD_WARM_WHITE),
            35 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB),
            39 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_WHITE),
            47 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE),
            51 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ColorMode] = &[
            ColorMode::COLOR_MODE_UNKNOWN,
            ColorMode::COLOR_MODE_ON_OFF,
            ColorMode::COLOR_MODE_BRIGHTNESS,
            ColorMode::COLOR_MODE_WHITE,
            ColorMode::COLOR_MODE_COLOR_TEMPERATURE,
            ColorMode::COLOR_MODE_COLD_WARM_WHITE,
            ColorMode::COLOR_MODE_RGB,
            ColorMode::COLOR_MODE_RGB_WHITE,
            ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE,
            ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ColorMode>("ColorMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ColorMode {
}

impl ::std::default::Default for ColorMode {
    fn default() -> Self {
        ColorMode::COLOR_MODE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SensorStateClass {
    STATE_CLASS_NONE = 0,
    STATE_CLASS_MEASUREMENT = 1,
    STATE_CLASS_TOTAL_INCREASING = 2,
}

impl ::protobuf::ProtobufEnum for SensorStateClass {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorStateClass> {
        match value {
            0 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_NONE),
            1 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_MEASUREMENT),
            2 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_TOTAL_INCREASING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SensorStateClass] = &[
            SensorStateClass::STATE_CLASS_NONE,
            SensorStateClass::STATE_CLASS_MEASUREMENT,
            SensorStateClass::STATE_CLASS_TOTAL_INCREASING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SensorStateClass>("SensorStateClass", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SensorStateClass {
}

impl ::std::default::Default for SensorStateClass {
    fn default() -> Self {
        SensorStateClass::STATE_CLASS_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorStateClass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SensorLastResetType {
    LAST_RESET_NONE = 0,
    LAST_RESET_NEVER = 1,
    LAST_RESET_AUTO = 2,
}

impl ::protobuf::ProtobufEnum for SensorLastResetType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorLastResetType> {
        match value {
            0 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NONE),
            1 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NEVER),
            2 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_AUTO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SensorLastResetType] = &[
            SensorLastResetType::LAST_RESET_NONE,
            SensorLastResetType::LAST_RESET_NEVER,
            SensorLastResetType::LAST_RESET_AUTO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SensorLastResetType>("SensorLastResetType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SensorLastResetType {
}

impl ::std::default::Default for SensorLastResetType {
    fn default() -> Self {
        SensorLastResetType::LAST_RESET_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorLastResetType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LogLevel {
    LOG_LEVEL_NONE = 0,
    LOG_LEVEL_ERROR = 1,
    LOG_LEVEL_WARN = 2,
    LOG_LEVEL_INFO = 3,
    LOG_LEVEL_CONFIG = 4,
    LOG_LEVEL_DEBUG = 5,
    LOG_LEVEL_VERBOSE = 6,
    LOG_LEVEL_VERY_VERBOSE = 7,
}

impl ::protobuf::ProtobufEnum for LogLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LogLevel> {
        match value {
            0 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_NONE),
            1 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_ERROR),
            2 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_WARN),
            3 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_INFO),
            4 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_CONFIG),
            5 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_DEBUG),
            6 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERBOSE),
            7 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERY_VERBOSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LogLevel] = &[
            LogLevel::LOG_LEVEL_NONE,
            LogLevel::LOG_LEVEL_ERROR,
            LogLevel::LOG_LEVEL_WARN,
            LogLevel::LOG_LEVEL_INFO,
            LogLevel::LOG_LEVEL_CONFIG,
            LogLevel::LOG_LEVEL_DEBUG,
            LogLevel::LOG_LEVEL_VERBOSE,
            LogLevel::LOG_LEVEL_VERY_VERBOSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LogLevel>("LogLevel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LogLevel {
}

impl ::std::default::Default for LogLevel {
    fn default() -> Self {
        LogLevel::LOG_LEVEL_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for LogLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServiceArgType {
    SERVICE_ARG_TYPE_BOOL = 0,
    SERVICE_ARG_TYPE_INT = 1,
    SERVICE_ARG_TYPE_FLOAT = 2,
    SERVICE_ARG_TYPE_STRING = 3,
    SERVICE_ARG_TYPE_BOOL_ARRAY = 4,
    SERVICE_ARG_TYPE_INT_ARRAY = 5,
    SERVICE_ARG_TYPE_FLOAT_ARRAY = 6,
    SERVICE_ARG_TYPE_STRING_ARRAY = 7,
}

impl ::protobuf::ProtobufEnum for ServiceArgType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServiceArgType> {
        match value {
            0 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL),
            1 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT),
            2 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT),
            3 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING),
            4 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL_ARRAY),
            5 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT_ARRAY),
            6 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT_ARRAY),
            7 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING_ARRAY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServiceArgType] = &[
            ServiceArgType::SERVICE_ARG_TYPE_BOOL,
            ServiceArgType::SERVICE_ARG_TYPE_INT,
            ServiceArgType::SERVICE_ARG_TYPE_FLOAT,
            ServiceArgType::SERVICE_ARG_TYPE_STRING,
            ServiceArgType::SERVICE_ARG_TYPE_BOOL_ARRAY,
            ServiceArgType::SERVICE_ARG_TYPE_INT_ARRAY,
            ServiceArgType::SERVICE_ARG_TYPE_FLOAT_ARRAY,
            ServiceArgType::SERVICE_ARG_TYPE_STRING_ARRAY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ServiceArgType>("ServiceArgType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ServiceArgType {
}

impl ::std::default::Default for ServiceArgType {
    fn default() -> Self {
        ServiceArgType::SERVICE_ARG_TYPE_BOOL
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceArgType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimateMode {
    CLIMATE_MODE_OFF = 0,
    CLIMATE_MODE_HEAT_COOL = 1,
    CLIMATE_MODE_COOL = 2,
    CLIMATE_MODE_HEAT = 3,
    CLIMATE_MODE_FAN_ONLY = 4,
    CLIMATE_MODE_DRY = 5,
    CLIMATE_MODE_AUTO = 6,
}

impl ::protobuf::ProtobufEnum for ClimateMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_OFF),
            1 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT_COOL),
            2 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_COOL),
            3 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT),
            4 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_FAN_ONLY),
            5 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_DRY),
            6 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_AUTO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimateMode] = &[
            ClimateMode::CLIMATE_MODE_OFF,
            ClimateMode::CLIMATE_MODE_HEAT_COOL,
            ClimateMode::CLIMATE_MODE_COOL,
            ClimateMode::CLIMATE_MODE_HEAT,
            ClimateMode::CLIMATE_MODE_FAN_ONLY,
            ClimateMode::CLIMATE_MODE_DRY,
            ClimateMode::CLIMATE_MODE_AUTO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimateMode>("ClimateMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimateMode {
}

impl ::std::default::Default for ClimateMode {
    fn default() -> Self {
        ClimateMode::CLIMATE_MODE_OFF
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimateFanMode {
    CLIMATE_FAN_ON = 0,
    CLIMATE_FAN_OFF = 1,
    CLIMATE_FAN_AUTO = 2,
    CLIMATE_FAN_LOW = 3,
    CLIMATE_FAN_MEDIUM = 4,
    CLIMATE_FAN_HIGH = 5,
    CLIMATE_FAN_MIDDLE = 6,
    CLIMATE_FAN_FOCUS = 7,
    CLIMATE_FAN_DIFFUSE = 8,
}

impl ::protobuf::ProtobufEnum for ClimateFanMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateFanMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_ON),
            1 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_OFF),
            2 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_AUTO),
            3 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_LOW),
            4 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MEDIUM),
            5 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_HIGH),
            6 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MIDDLE),
            7 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_FOCUS),
            8 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_DIFFUSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimateFanMode] = &[
            ClimateFanMode::CLIMATE_FAN_ON,
            ClimateFanMode::CLIMATE_FAN_OFF,
            ClimateFanMode::CLIMATE_FAN_AUTO,
            ClimateFanMode::CLIMATE_FAN_LOW,
            ClimateFanMode::CLIMATE_FAN_MEDIUM,
            ClimateFanMode::CLIMATE_FAN_HIGH,
            ClimateFanMode::CLIMATE_FAN_MIDDLE,
            ClimateFanMode::CLIMATE_FAN_FOCUS,
            ClimateFanMode::CLIMATE_FAN_DIFFUSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimateFanMode>("ClimateFanMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimateFanMode {
}

impl ::std::default::Default for ClimateFanMode {
    fn default() -> Self {
        ClimateFanMode::CLIMATE_FAN_ON
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateFanMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimateSwingMode {
    CLIMATE_SWING_OFF = 0,
    CLIMATE_SWING_BOTH = 1,
    CLIMATE_SWING_VERTICAL = 2,
    CLIMATE_SWING_HORIZONTAL = 3,
}

impl ::protobuf::ProtobufEnum for ClimateSwingMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateSwingMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_OFF),
            1 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_BOTH),
            2 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_VERTICAL),
            3 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_HORIZONTAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimateSwingMode] = &[
            ClimateSwingMode::CLIMATE_SWING_OFF,
            ClimateSwingMode::CLIMATE_SWING_BOTH,
            ClimateSwingMode::CLIMATE_SWING_VERTICAL,
            ClimateSwingMode::CLIMATE_SWING_HORIZONTAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimateSwingMode>("ClimateSwingMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimateSwingMode {
}

impl ::std::default::Default for ClimateSwingMode {
    fn default() -> Self {
        ClimateSwingMode::CLIMATE_SWING_OFF
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateSwingMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimateAction {
    CLIMATE_ACTION_OFF = 0,
    CLIMATE_ACTION_COOLING = 2,
    CLIMATE_ACTION_HEATING = 3,
    CLIMATE_ACTION_IDLE = 4,
    CLIMATE_ACTION_DRYING = 5,
    CLIMATE_ACTION_FAN = 6,
}

impl ::protobuf::ProtobufEnum for ClimateAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateAction> {
        match value {
            0 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_OFF),
            2 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_COOLING),
            3 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_HEATING),
            4 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_IDLE),
            5 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_DRYING),
            6 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_FAN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimateAction] = &[
            ClimateAction::CLIMATE_ACTION_OFF,
            ClimateAction::CLIMATE_ACTION_COOLING,
            ClimateAction::CLIMATE_ACTION_HEATING,
            ClimateAction::CLIMATE_ACTION_IDLE,
            ClimateAction::CLIMATE_ACTION_DRYING,
            ClimateAction::CLIMATE_ACTION_FAN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimateAction>("ClimateAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimateAction {
}

impl ::std::default::Default for ClimateAction {
    fn default() -> Self {
        ClimateAction::CLIMATE_ACTION_OFF
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimatePreset {
    CLIMATE_PRESET_NONE = 0,
    CLIMATE_PRESET_HOME = 1,
    CLIMATE_PRESET_AWAY = 2,
    CLIMATE_PRESET_BOOST = 3,
    CLIMATE_PRESET_COMFORT = 4,
    CLIMATE_PRESET_ECO = 5,
    CLIMATE_PRESET_SLEEP = 6,
    CLIMATE_PRESET_ACTIVITY = 7,
}

impl ::protobuf::ProtobufEnum for ClimatePreset {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimatePreset> {
        match value {
            0 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_NONE),
            1 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_HOME),
            2 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_AWAY),
            3 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_BOOST),
            4 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_COMFORT),
            5 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ECO),
            6 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_SLEEP),
            7 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ACTIVITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimatePreset] = &[
            ClimatePreset::CLIMATE_PRESET_NONE,
            ClimatePreset::CLIMATE_PRESET_HOME,
            ClimatePreset::CLIMATE_PRESET_AWAY,
            ClimatePreset::CLIMATE_PRESET_BOOST,
            ClimatePreset::CLIMATE_PRESET_COMFORT,
            ClimatePreset::CLIMATE_PRESET_ECO,
            ClimatePreset::CLIMATE_PRESET_SLEEP,
            ClimatePreset::CLIMATE_PRESET_ACTIVITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimatePreset>("ClimatePreset", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimatePreset {
}

impl ::std::default::Default for ClimatePreset {
    fn default() -> Self {
        ClimatePreset::CLIMATE_PRESET_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimatePreset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NumberMode {
    NUMBER_MODE_AUTO = 0,
    NUMBER_MODE_BOX = 1,
    NUMBER_MODE_SLIDER = 2,
}

impl ::protobuf::ProtobufEnum for NumberMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NumberMode> {
        match value {
            0 => ::std::option::Option::Some(NumberMode::NUMBER_MODE_AUTO),
            1 => ::std::option::Option::Some(NumberMode::NUMBER_MODE_BOX),
            2 => ::std::option::Option::Some(NumberMode::NUMBER_MODE_SLIDER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NumberMode] = &[
            NumberMode::NUMBER_MODE_AUTO,
            NumberMode::NUMBER_MODE_BOX,
            NumberMode::NUMBER_MODE_SLIDER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NumberMode>("NumberMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NumberMode {
}

impl ::std::default::Default for NumberMode {
    fn default() -> Self {
        NumberMode::NUMBER_MODE_AUTO
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LockState {
    LOCK_STATE_NONE = 0,
    LOCK_STATE_LOCKED = 1,
    LOCK_STATE_UNLOCKED = 2,
    LOCK_STATE_JAMMED = 3,
    LOCK_STATE_LOCKING = 4,
    LOCK_STATE_UNLOCKING = 5,
}

impl ::protobuf::ProtobufEnum for LockState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockState> {
        match value {
            0 => ::std::option::Option::Some(LockState::LOCK_STATE_NONE),
            1 => ::std::option::Option::Some(LockState::LOCK_STATE_LOCKED),
            2 => ::std::option::Option::Some(LockState::LOCK_STATE_UNLOCKED),
            3 => ::std::option::Option::Some(LockState::LOCK_STATE_JAMMED),
            4 => ::std::option::Option::Some(LockState::LOCK_STATE_LOCKING),
            5 => ::std::option::Option::Some(LockState::LOCK_STATE_UNLOCKING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LockState] = &[
            LockState::LOCK_STATE_NONE,
            LockState::LOCK_STATE_LOCKED,
            LockState::LOCK_STATE_UNLOCKED,
            LockState::LOCK_STATE_JAMMED,
            LockState::LOCK_STATE_LOCKING,
            LockState::LOCK_STATE_UNLOCKING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LockState>("LockState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LockState {
}

impl ::std::default::Default for LockState {
    fn default() -> Self {
        LockState::LOCK_STATE_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for LockState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LockCommand {
    LOCK_UNLOCK = 0,
    LOCK_LOCK = 1,
    LOCK_OPEN = 2,
}

impl ::protobuf::ProtobufEnum for LockCommand {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockCommand> {
        match value {
            0 => ::std::option::Option::Some(LockCommand::LOCK_UNLOCK),
            1 => ::std::option::Option::Some(LockCommand::LOCK_LOCK),
            2 => ::std::option::Option::Some(LockCommand::LOCK_OPEN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LockCommand] = &[
            LockCommand::LOCK_UNLOCK,
            LockCommand::LOCK_LOCK,
            LockCommand::LOCK_OPEN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LockCommand>("LockCommand", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LockCommand {
}

impl ::std::default::Default for LockCommand {
    fn default() -> Self {
        LockCommand::LOCK_UNLOCK
    }
}

impl ::protobuf::reflect::ProtobufValue for LockCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tapi.proto\x1a\x11api_options.proto\":\n\x0cHelloRequest\x12\x1f\n\
    \x0bclient_info\x18\x01\x20\x01(\tR\nclientInfo:\t\x80A\x01\xe0@\x01\xe8\
    @\x02\"\xa7\x01\n\rHelloResponse\x12*\n\x11api_version_major\x18\x01\x20\
    \x01(\rR\x0fapiVersionMajor\x12*\n\x11api_version_minor\x18\x02\x20\x01(\
    \rR\x0fapiVersionMinor\x12\x1f\n\x0bserver_info\x18\x03\x20\x01(\tR\nser\
    verInfo\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name:\t\x80A\x01\xe0@\
    \x02\xe8@\x01\"7\n\x0eConnectRequest\x12\x1a\n\x08password\x18\x01\x20\
    \x01(\tR\x08password:\t\x80A\x01\xe0@\x03\xe8@\x02\"G\n\x0fConnectRespon\
    se\x12)\n\x10invalid_password\x18\x01\x20\x01(\x08R\x0finvalidPassword:\
    \t\x80A\x01\xe0@\x04\xe8@\x01\"\x1e\n\x11DisconnectRequest:\t\x80A\x01\
    \xe0@\x05\xe8@\0\"\x1f\n\x12DisconnectResponse:\t\x80A\x01\xe0@\x06\xe8@\
    \0\"\x15\n\x0bPingRequest:\x06\xe0@\x07\xe8@\0\"\x16\n\x0cPingResponse:\
    \x06\xe0@\x08\xe8@\0\"\x1b\n\x11DeviceInfoRequest:\x06\xe0@\t\xe8@\x02\"\
    \xf9\x02\n\x12DeviceInfoResponse\x12#\n\ruses_password\x18\x01\x20\x01(\
    \x08R\x0cusesPassword\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x1f\n\x0bmac_address\x18\x03\x20\x01(\tR\nmacAddress\x12'\n\x0fesphome_\
    version\x18\x04\x20\x01(\tR\x0eesphomeVersion\x12)\n\x10compilation_time\
    \x18\x05\x20\x01(\tR\x0fcompilationTime\x12\x14\n\x05model\x18\x06\x20\
    \x01(\tR\x05model\x12$\n\x0ehas_deep_sleep\x18\x07\x20\x01(\x08R\x0chasD\
    eepSleep\x12!\n\x0cproject_name\x18\x08\x20\x01(\tR\x0bprojectName\x12'\
    \n\x0fproject_version\x18\t\x20\x01(\tR\x0eprojectVersion\x12%\n\x0ewebs\
    erver_port\x18\n\x20\x01(\rR\rwebserverPort:\x06\xe0@\n\xe8@\x01\"\x1d\n\
    \x13ListEntitiesRequest:\x06\xe0@\x0b\xe8@\x02\"%\n\x18ListEntitiesDoneR\
    esponse:\t\x80A\x01\xe0@\x13\xe8@\x01\"\x20\n\x16SubscribeStatesRequest:\
    \x06\xe0@\x14\xe8@\x02\"\xf6\x02\n\x20ListEntitiesBinarySensorResponse\
    \x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\
    \x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04n\
    ame\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12!\n\x0cdevic\
    e_class\x18\x05\x20\x01(\tR\x0bdeviceClass\x125\n\x17is_status_binary_se\
    nsor\x18\x06\x20\x01(\x08R\x14isStatusBinarySensor\x12.\n\x13disabled_by\
    _default\x18\x07\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04icon\
    \x18\x08\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\t\x20\x01(\
    \x0e2\x0f.EntityCategoryR\x0eentityCategory:\x1a\xf2@\x11USE_BINARY_SENS\
    OR\xe0@\x0c\xe8@\x01\"\x87\x01\n\x19BinarySensorStateResponse\x12\x10\n\
    \x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\
    \x08R\x05state\x12#\n\rmissing_state\x18\x03\x20\x01(\x08R\x0cmissingSta\
    te:\x1d\x80A\x01\xf2@\x11USE_BINARY_SENSOR\xe0@\x15\xe8@\x01\"\xa7\x03\n\
    \x19ListEntitiesCoverResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12#\n\rassumed_state\x18\x05\x20\x01(\x08R\x0cassumedStat\
    e\x12+\n\x11supports_position\x18\x06\x20\x01(\x08R\x10supportsPosition\
    \x12#\n\rsupports_tilt\x18\x07\x20\x01(\x08R\x0csupportsTilt\x12!\n\x0cd\
    evice_class\x18\x08\x20\x01(\tR\x0bdeviceClass\x12.\n\x13disabled_by_def\
    ault\x18\t\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04icon\x18\n\
    \x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x0b\x20\x01(\x0e2\x0f\
    .EntityCategoryR\x0eentityCategory:\x12\xf2@\tUSE_COVER\xe0@\r\xe8@\x01\
    \"\xe1\x01\n\x12CoverStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07\
    R\x03key\x124\n\x0clegacy_state\x18\x02\x20\x01(\x0e2\x11.LegacyCoverSta\
    teR\x0blegacyState\x12\x1a\n\x08position\x18\x03\x20\x01(\x02R\x08positi\
    on\x12\x12\n\x04tilt\x18\x04\x20\x01(\x02R\x04tilt\x12<\n\x11current_ope\
    ration\x18\x05\x20\x01(\x0e2\x0f.CoverOperationR\x10currentOperation:\
    \x15\x80A\x01\xf2@\tUSE_COVER\xe0@\x16\xe8@\x01\"\xaa\x02\n\x13CoverComm\
    andRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12,\n\x12has_l\
    egacy_command\x18\x02\x20\x01(\x08R\x10hasLegacyCommand\x12:\n\x0elegacy\
    _command\x18\x03\x20\x01(\x0e2\x13.LegacyCoverCommandR\rlegacyCommand\
    \x12!\n\x0chas_position\x18\x04\x20\x01(\x08R\x0bhasPosition\x12\x1a\n\
    \x08position\x18\x05\x20\x01(\x02R\x08position\x12\x19\n\x08has_tilt\x18\
    \x06\x20\x01(\x08R\x07hasTilt\x12\x12\n\x04tilt\x18\x07\x20\x01(\x02R\
    \x04tilt\x12\x12\n\x04stop\x18\x08\x20\x01(\x08R\x04stop:\x15\x80A\x01\
    \xf2@\tUSE_COVER\xe0@\x1e\xe8@\x02\"\xc6\x03\n\x17ListEntitiesFanRespons\
    e\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\
    \x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04n\
    ame\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x121\n\x14suppo\
    rts_oscillation\x18\x05\x20\x01(\x08R\x13supportsOscillation\x12%\n\x0es\
    upports_speed\x18\x06\x20\x01(\x08R\rsupportsSpeed\x12-\n\x12supports_di\
    rection\x18\x07\x20\x01(\x08R\x11supportsDirection\x122\n\x15supported_s\
    peed_count\x18\x08\x20\x01(\x05R\x13supportedSpeedCount\x12.\n\x13disabl\
    ed_by_default\x18\t\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04icon\
    \x18\n\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x0b\x20\x01(\
    \x0e2\x0f.EntityCategoryR\x0eentityCategory:\x10\xf2@\x07USE_FAN\xe0@\
    \x0e\xe8@\x01\"\xe4\x01\n\x10FanStateResponse\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\x08R\x05state\
    \x12\x20\n\x0boscillating\x18\x03\x20\x01(\x08R\x0boscillating\x12#\n\
    \x05speed\x18\x04\x20\x01(\x0e2\t.FanSpeedR\x05speedB\x02\x18\x01\x12+\n\
    \tdirection\x18\x05\x20\x01(\x0e2\r.FanDirectionR\tdirection\x12\x1f\n\
    \x0bspeed_level\x18\x06\x20\x01(\x05R\nspeedLevel:\x13\x80A\x01\xf2@\x07\
    USE_FAN\xe0@\x17\xe8@\x01\"\x99\x03\n\x11FanCommandRequest\x12\x10\n\x03\
    key\x18\x01\x20\x01(\x07R\x03key\x12\x1b\n\thas_state\x18\x02\x20\x01(\
    \x08R\x08hasState\x12\x14\n\x05state\x18\x03\x20\x01(\x08R\x05state\x12\
    \x1f\n\thas_speed\x18\x04\x20\x01(\x08R\x08hasSpeedB\x02\x18\x01\x12#\n\
    \x05speed\x18\x05\x20\x01(\x0e2\t.FanSpeedR\x05speedB\x02\x18\x01\x12'\n\
    \x0fhas_oscillating\x18\x06\x20\x01(\x08R\x0ehasOscillating\x12\x20\n\
    \x0boscillating\x18\x07\x20\x01(\x08R\x0boscillating\x12#\n\rhas_directi\
    on\x18\x08\x20\x01(\x08R\x0chasDirection\x12+\n\tdirection\x18\t\x20\x01\
    (\x0e2\r.FanDirectionR\tdirection\x12&\n\x0fhas_speed_level\x18\n\x20\
    \x01(\x08R\rhasSpeedLevel\x12\x1f\n\x0bspeed_level\x18\x0b\x20\x01(\x05R\
    \nspeedLevel:\x13\x80A\x01\xf2@\x07USE_FAN\xe0@\x1f\xe8@\x02\"\xad\x05\n\
    \x19ListEntitiesLightResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12>\n\x15supported_color_modes\x18\x0c\x20\x03(\x0e2\n.Co\
    lorModeR\x13supportedColorModes\x12@\n\x1alegacy_supports_brightness\x18\
    \x05\x20\x01(\x08R\x18legacySupportsBrightnessB\x02\x18\x01\x122\n\x13le\
    gacy_supports_rgb\x18\x06\x20\x01(\x08R\x11legacySupportsRgbB\x02\x18\
    \x01\x12A\n\x1blegacy_supports_white_value\x18\x07\x20\x01(\x08R\x18lega\
    cySupportsWhiteValueB\x02\x18\x01\x12M\n!legacy_supports_color_temperatu\
    re\x18\x08\x20\x01(\x08R\x1elegacySupportsColorTemperatureB\x02\x18\x01\
    \x12\x1d\n\nmin_mireds\x18\t\x20\x01(\x02R\tminMireds\x12\x1d\n\nmax_mir\
    eds\x18\n\x20\x01(\x02R\tmaxMireds\x12\x18\n\x07effects\x18\x0b\x20\x03(\
    \tR\x07effects\x12.\n\x13disabled_by_default\x18\r\x20\x01(\x08R\x11disa\
    bledByDefault\x12\x12\n\x04icon\x18\x0e\x20\x01(\tR\x04icon\x128\n\x0fen\
    tity_category\x18\x0f\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategor\
    y:\x12\xf2@\tUSE_LIGHT\xe0@\x0f\xe8@\x01\"\x9e\x03\n\x12LightStateRespon\
    se\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\
    \x02\x20\x01(\x08R\x05state\x12\x1e\n\nbrightness\x18\x03\x20\x01(\x02R\
    \nbrightness\x12)\n\ncolor_mode\x18\x0b\x20\x01(\x0e2\n.ColorModeR\tcolo\
    rMode\x12)\n\x10color_brightness\x18\n\x20\x01(\x02R\x0fcolorBrightness\
    \x12\x10\n\x03red\x18\x04\x20\x01(\x02R\x03red\x12\x14\n\x05green\x18\
    \x05\x20\x01(\x02R\x05green\x12\x12\n\x04blue\x18\x06\x20\x01(\x02R\x04b\
    lue\x12\x14\n\x05white\x18\x07\x20\x01(\x02R\x05white\x12+\n\x11color_te\
    mperature\x18\x08\x20\x01(\x02R\x10colorTemperature\x12\x1d\n\ncold_whit\
    e\x18\x0c\x20\x01(\x02R\tcoldWhite\x12\x1d\n\nwarm_white\x18\r\x20\x01(\
    \x02R\twarmWhite\x12\x16\n\x06effect\x18\t\x20\x01(\tR\x06effect:\x15\
    \x80A\x01\xf2@\tUSE_LIGHT\xe0@\x18\xe8@\x01\"\xbe\x07\n\x13LightCommandR\
    equest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x1b\n\thas_stat\
    e\x18\x02\x20\x01(\x08R\x08hasState\x12\x14\n\x05state\x18\x03\x20\x01(\
    \x08R\x05state\x12%\n\x0ehas_brightness\x18\x04\x20\x01(\x08R\rhasBright\
    ness\x12\x1e\n\nbrightness\x18\x05\x20\x01(\x02R\nbrightness\x12$\n\x0eh\
    as_color_mode\x18\x16\x20\x01(\x08R\x0chasColorMode\x12)\n\ncolor_mode\
    \x18\x17\x20\x01(\x0e2\n.ColorModeR\tcolorMode\x120\n\x14has_color_brigh\
    tness\x18\x14\x20\x01(\x08R\x12hasColorBrightness\x12)\n\x10color_bright\
    ness\x18\x15\x20\x01(\x02R\x0fcolorBrightness\x12\x17\n\x07has_rgb\x18\
    \x06\x20\x01(\x08R\x06hasRgb\x12\x10\n\x03red\x18\x07\x20\x01(\x02R\x03r\
    ed\x12\x14\n\x05green\x18\x08\x20\x01(\x02R\x05green\x12\x12\n\x04blue\
    \x18\t\x20\x01(\x02R\x04blue\x12\x1b\n\thas_white\x18\n\x20\x01(\x08R\
    \x08hasWhite\x12\x14\n\x05white\x18\x0b\x20\x01(\x02R\x05white\x122\n\
    \x15has_color_temperature\x18\x0c\x20\x01(\x08R\x13hasColorTemperature\
    \x12+\n\x11color_temperature\x18\r\x20\x01(\x02R\x10colorTemperature\x12\
    $\n\x0ehas_cold_white\x18\x18\x20\x01(\x08R\x0chasColdWhite\x12\x1d\n\nc\
    old_white\x18\x19\x20\x01(\x02R\tcoldWhite\x12$\n\x0ehas_warm_white\x18\
    \x1a\x20\x01(\x08R\x0chasWarmWhite\x12\x1d\n\nwarm_white\x18\x1b\x20\x01\
    (\x02R\twarmWhite\x122\n\x15has_transition_length\x18\x0e\x20\x01(\x08R\
    \x13hasTransitionLength\x12+\n\x11transition_length\x18\x0f\x20\x01(\rR\
    \x10transitionLength\x12(\n\x10has_flash_length\x18\x10\x20\x01(\x08R\
    \x0ehasFlashLength\x12!\n\x0cflash_length\x18\x11\x20\x01(\rR\x0bflashLe\
    ngth\x12\x1d\n\nhas_effect\x18\x12\x20\x01(\x08R\thasEffect\x12\x16\n\
    \x06effect\x18\x13\x20\x01(\tR\x06effect:\x15\x80A\x01\xf2@\tUSE_LIGHT\
    \xe0@\x20\xe8@\x02\"\xb1\x04\n\x1aListEntitiesSensorResponse\x12\x1b\n\t\
    object_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\
    \x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\
    \n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\
    \x20\x01(\tR\x04icon\x12.\n\x13unit_of_measurement\x18\x06\x20\x01(\tR\
    \x11unitOfMeasurement\x12+\n\x11accuracy_decimals\x18\x07\x20\x01(\x05R\
    \x10accuracyDecimals\x12!\n\x0cforce_update\x18\x08\x20\x01(\x08R\x0bfor\
    ceUpdate\x12!\n\x0cdevice_class\x18\t\x20\x01(\tR\x0bdeviceClass\x122\n\
    \x0bstate_class\x18\n\x20\x01(\x0e2\x11.SensorStateClassR\nstateClass\
    \x12I\n\x16legacy_last_reset_type\x18\x0b\x20\x01(\x0e2\x14.SensorLastRe\
    setTypeR\x13legacyLastResetType\x12.\n\x13disabled_by_default\x18\x0c\
    \x20\x01(\x08R\x11disabledByDefault\x128\n\x0fentity_category\x18\r\x20\
    \x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory:\x13\xf2@\nUSE_SENSOR\
    \xe0@\x10\xe8@\x01\"z\n\x13SensorStateResponse\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\x02R\x05state\
    \x12#\n\rmissing_state\x18\x03\x20\x01(\x08R\x0cmissingState:\x16\x80A\
    \x01\xf2@\nUSE_SENSOR\xe0@\x19\xe8@\x01\"\xd7\x02\n\x1aListEntitiesSwitc\
    hResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\
    \x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\
    \tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\
    \n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12#\n\rassumed_state\x18\x06\x20\
    \x01(\x08R\x0cassumedState\x12.\n\x13disabled_by_default\x18\x07\x20\x01\
    (\x08R\x11disabledByDefault\x128\n\x0fentity_category\x18\x08\x20\x01(\
    \x0e2\x0f.EntityCategoryR\x0eentityCategory\x12!\n\x0cdevice_class\x18\t\
    \x20\x01(\tR\x0bdeviceClass:\x13\xf2@\nUSE_SWITCH\xe0@\x11\xe8@\x01\"U\n\
    \x13SwitchStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\
    \x12\x14\n\x05state\x18\x02\x20\x01(\x08R\x05state:\x16\x80A\x01\xf2@\nU\
    SE_SWITCH\xe0@\x1a\xe8@\x01\"V\n\x14SwitchCommandRequest\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\x08R\
    \x05state:\x16\x80A\x01\xf2@\nUSE_SWITCH\xe0@!\xe8@\x02\"\x98\x02\n\x1eL\
    istEntitiesTextSensorResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13di\
    sabled_by_default\x18\x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fe\
    ntity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCatego\
    ry:\x18\xf2@\x0fUSE_TEXT_SENSOR\xe0@\x12\xe8@\x01\"\x83\x01\n\x17TextSen\
    sorStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\
    \x05state\x18\x02\x20\x01(\tR\x05state\x12#\n\rmissing_state\x18\x03\x20\
    \x01(\x08R\x0cmissingState:\x1b\x80A\x01\xf2@\x0fUSE_TEXT_SENSOR\xe0@\
    \x1b\xe8@\x01\"`\n\x14SubscribeLogsRequest\x12\x1f\n\x05level\x18\x01\
    \x20\x01(\x0e2\t.LogLevelR\x05level\x12\x1f\n\x0bdump_config\x18\x02\x20\
    \x01(\x08R\ndumpConfig:\x06\xe0@\x1c\xe8@\x02\"\x81\x01\n\x15SubscribeLo\
    gsResponse\x12\x1f\n\x05level\x18\x01\x20\x01(\x0e2\t.LogLevelR\x05level\
    \x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\x1f\n\x0bsend_f\
    ailed\x18\x04\x20\x01(\x08R\nsendFailed:\x0c\xf8@\0\x80A\0\xe0@\x1d\xe8@\
    \x01\"/\n%SubscribeHomeassistantServicesRequest:\x06\xe0@\"\xe8@\x02\"A\
    \n\x17HomeassistantServiceMap\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x83\x02\n\x1cHomeass\
    istantServiceResponse\x12\x18\n\x07service\x18\x01\x20\x01(\tR\x07servic\
    e\x12,\n\x04data\x18\x02\x20\x03(\x0b2\x18.HomeassistantServiceMapR\x04d\
    ata\x12=\n\rdata_template\x18\x03\x20\x03(\x0b2\x18.HomeassistantService\
    MapR\x0cdataTemplate\x126\n\tvariables\x18\x04\x20\x03(\x0b2\x18.Homeass\
    istantServiceMapR\tvariables\x12\x19\n\x08is_event\x18\x05\x20\x01(\x08R\
    \x07isEvent:\t\x80A\x01\xe0@#\xe8@\x01\"-\n#SubscribeHomeAssistantStates\
    Request:\x06\xe0@&\xe8@\x02\"h\n#SubscribeHomeAssistantStateResponse\x12\
    \x1b\n\tentity_id\x18\x01\x20\x01(\tR\x08entityId\x12\x1c\n\tattribute\
    \x18\x02\x20\x01(\tR\tattribute:\x06\xe0@'\xe8@\x01\"x\n\x1aHomeAssistan\
    tStateResponse\x12\x1b\n\tentity_id\x18\x01\x20\x01(\tR\x08entityId\x12\
    \x14\n\x05state\x18\x02\x20\x01(\tR\x05state\x12\x1c\n\tattribute\x18\
    \x03\x20\x01(\tR\tattribute:\t\x80A\x01\xe0@(\xe8@\x02\"\x18\n\x0eGetTim\
    eRequest:\x06\xe0@$\xe8@\0\"A\n\x0fGetTimeResponse\x12#\n\repoch_seconds\
    \x18\x01\x20\x01(\x07R\x0cepochSeconds:\t\x80A\x01\xe0@%\xe8@\0\"W\n\x1c\
    ListEntitiesServicesArgument\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\x12#\n\x04type\x18\x02\x20\x01(\x0e2\x0f.ServiceArgTypeR\x04type\"\
    \x7f\n\x1cListEntitiesServicesResponse\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x121\n\x04arg\
    s\x18\x03\x20\x03(\x0b2\x1d.ListEntitiesServicesArgumentR\x04args:\x06\
    \xe0@)\xe8@\x01\"\x9b\x02\n\x16ExecuteServiceArgument\x12\x13\n\x05bool_\
    \x18\x01\x20\x01(\x08R\x04bool\x12\x1d\n\nlegacy_int\x18\x02\x20\x01(\
    \x05R\tlegacyInt\x12\x15\n\x06float_\x18\x03\x20\x01(\x02R\x05float\x12\
    \x17\n\x07string_\x18\x04\x20\x01(\tR\x06string\x12\x11\n\x04int_\x18\
    \x05\x20\x01(\x11R\x03int\x12!\n\nbool_array\x18\x06\x20\x03(\x08R\tbool\
    ArrayB\x02\x10\0\x12\x1f\n\tint_array\x18\x07\x20\x03(\x11R\x08intArrayB\
    \x02\x10\0\x12#\n\x0bfloat_array\x18\x08\x20\x03(\x02R\nfloatArrayB\x02\
    \x10\0\x12!\n\x0cstring_array\x18\t\x20\x03(\tR\x0bstringArray\"a\n\x15E\
    xecuteServiceRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12+\
    \n\x04args\x18\x02\x20\x03(\x0b2\x17.ExecuteServiceArgumentR\x04args:\t\
    \x80A\x01\xe0@*\xe8@\x02\"\x95\x02\n\x1aListEntitiesCameraResponse\x12\
    \x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\
    \x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\
    \x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12.\n\x13disabled\
    _by_default\x18\x05\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04icon\
    \x18\x06\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x07\x20\x01(\
    \x0e2\x0f.EntityCategoryR\x0eentityCategory:\x19\xf2@\x10USE_ESP32_CAMER\
    A\xe0@+\xe8@\x01\"j\n\x13CameraImageResponse\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\
    \x12\x12\n\x04done\x18\x03\x20\x01(\x08R\x04done:\x19\xf2@\x10USE_ESP32_\
    CAMERA\xe0@,\xe8@\x01\"b\n\x12CameraImageRequest\x12\x16\n\x06single\x18\
    \x01\x20\x01(\x08R\x06single\x12\x16\n\x06stream\x18\x02\x20\x01(\x08R\
    \x06stream:\x1c\x80A\x01\xf2@\x10USE_ESP32_CAMERA\xe0@-\xe8@\x02\"\x97\
    \x08\n\x1bListEntitiesClimateResponse\x12\x1b\n\tobject_id\x18\x01\x20\
    \x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\
    \x20\x01(\tR\x08uniqueId\x12@\n\x1csupports_current_temperature\x18\x05\
    \x20\x01(\x08R\x1asupportsCurrentTemperature\x12P\n%supports_two_point_t\
    arget_temperature\x18\x06\x20\x01(\x08R!supportsTwoPointTargetTemperatur\
    e\x125\n\x0fsupported_modes\x18\x07\x20\x03(\x0e2\x0c.ClimateModeR\x0esu\
    pportedModes\x124\n\x16visual_min_temperature\x18\x08\x20\x01(\x02R\x14v\
    isualMinTemperature\x124\n\x16visual_max_temperature\x18\t\x20\x01(\x02R\
    \x14visualMaxTemperature\x126\n\x17visual_temperature_step\x18\n\x20\x01\
    (\x02R\x15visualTemperatureStep\x120\n\x14legacy_supports_away\x18\x0b\
    \x20\x01(\x08R\x12legacySupportsAway\x12'\n\x0fsupports_action\x18\x0c\
    \x20\x01(\x08R\x0esupportsAction\x12?\n\x13supported_fan_modes\x18\r\x20\
    \x03(\x0e2\x0f.ClimateFanModeR\x11supportedFanModes\x12E\n\x15supported_\
    swing_modes\x18\x0e\x20\x03(\x0e2\x11.ClimateSwingModeR\x13supportedSwin\
    gModes\x12;\n\x1asupported_custom_fan_modes\x18\x0f\x20\x03(\tR\x17suppo\
    rtedCustomFanModes\x12;\n\x11supported_presets\x18\x10\x20\x03(\x0e2\x0e\
    .ClimatePresetR\x10supportedPresets\x128\n\x18supported_custom_presets\
    \x18\x11\x20\x03(\tR\x16supportedCustomPresets\x12.\n\x13disabled_by_def\
    ault\x18\x12\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04icon\x18\
    \x13\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x14\x20\x01(\x0e2\
    \x0f.EntityCategoryR\x0eentityCategory:\x14\xf2@\x0bUSE_CLIMATE\xe0@.\
    \xe8@\x01\"\xcd\x04\n\x14ClimateStateResponse\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x12\x20\n\x04mode\x18\x02\x20\x01(\x0e2\x0c.Climat\
    eModeR\x04mode\x12/\n\x13current_temperature\x18\x03\x20\x01(\x02R\x12cu\
    rrentTemperature\x12-\n\x12target_temperature\x18\x04\x20\x01(\x02R\x11t\
    argetTemperature\x124\n\x16target_temperature_low\x18\x05\x20\x01(\x02R\
    \x14targetTemperatureLow\x126\n\x17target_temperature_high\x18\x06\x20\
    \x01(\x02R\x15targetTemperatureHigh\x12\x1f\n\x0blegacy_away\x18\x07\x20\
    \x01(\x08R\nlegacyAway\x12&\n\x06action\x18\x08\x20\x01(\x0e2\x0e.Climat\
    eActionR\x06action\x12*\n\x08fan_mode\x18\t\x20\x01(\x0e2\x0f.ClimateFan\
    ModeR\x07fanMode\x120\n\nswing_mode\x18\n\x20\x01(\x0e2\x11.ClimateSwing\
    ModeR\tswingMode\x12&\n\x0fcustom_fan_mode\x18\x0b\x20\x01(\tR\rcustomFa\
    nMode\x12&\n\x06preset\x18\x0c\x20\x01(\x0e2\x0e.ClimatePresetR\x06prese\
    t\x12#\n\rcustom_preset\x18\r\x20\x01(\tR\x0ccustomPreset:\x17\x80A\x01\
    \xf2@\x0bUSE_CLIMATE\xe0@/\xe8@\x01\"\xac\x07\n\x15ClimateCommandRequest\
    \x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x19\n\x08has_mode\x18\
    \x02\x20\x01(\x08R\x07hasMode\x12\x20\n\x04mode\x18\x03\x20\x01(\x0e2\
    \x0c.ClimateModeR\x04mode\x124\n\x16has_target_temperature\x18\x04\x20\
    \x01(\x08R\x14hasTargetTemperature\x12-\n\x12target_temperature\x18\x05\
    \x20\x01(\x02R\x11targetTemperature\x12;\n\x1ahas_target_temperature_low\
    \x18\x06\x20\x01(\x08R\x17hasTargetTemperatureLow\x124\n\x16target_tempe\
    rature_low\x18\x07\x20\x01(\x02R\x14targetTemperatureLow\x12=\n\x1bhas_t\
    arget_temperature_high\x18\x08\x20\x01(\x08R\x18hasTargetTemperatureHigh\
    \x126\n\x17target_temperature_high\x18\t\x20\x01(\x02R\x15targetTemperat\
    ureHigh\x12&\n\x0fhas_legacy_away\x18\n\x20\x01(\x08R\rhasLegacyAway\x12\
    \x1f\n\x0blegacy_away\x18\x0b\x20\x01(\x08R\nlegacyAway\x12\x20\n\x0chas\
    _fan_mode\x18\x0c\x20\x01(\x08R\nhasFanMode\x12*\n\x08fan_mode\x18\r\x20\
    \x01(\x0e2\x0f.ClimateFanModeR\x07fanMode\x12$\n\x0ehas_swing_mode\x18\
    \x0e\x20\x01(\x08R\x0chasSwingMode\x120\n\nswing_mode\x18\x0f\x20\x01(\
    \x0e2\x11.ClimateSwingModeR\tswingMode\x12-\n\x13has_custom_fan_mode\x18\
    \x10\x20\x01(\x08R\x10hasCustomFanMode\x12&\n\x0fcustom_fan_mode\x18\x11\
    \x20\x01(\tR\rcustomFanMode\x12\x1d\n\nhas_preset\x18\x12\x20\x01(\x08R\
    \thasPreset\x12&\n\x06preset\x18\x13\x20\x01(\x0e2\x0e.ClimatePresetR\
    \x06preset\x12*\n\x11has_custom_preset\x18\x14\x20\x01(\x08R\x0fhasCusto\
    mPreset\x12#\n\rcustom_preset\x18\x15\x20\x01(\tR\x0ccustomPreset:\x17\
    \x80A\x01\xf2@\x0bUSE_CLIMATE\xe0@0\xe8@\x02\"\xae\x03\n\x1aListEntities\
    NumberResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\
    \x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\
    \x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\
    \x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12\x1b\n\tmin_value\x18\
    \x06\x20\x01(\x02R\x08minValue\x12\x1b\n\tmax_value\x18\x07\x20\x01(\x02\
    R\x08maxValue\x12\x12\n\x04step\x18\x08\x20\x01(\x02R\x04step\x12.\n\x13\
    disabled_by_default\x18\t\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fe\
    ntity_category\x18\n\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\
    \x12.\n\x13unit_of_measurement\x18\x0b\x20\x01(\tR\x11unitOfMeasurement\
    \x12\x1f\n\x04mode\x18\x0c\x20\x01(\x0e2\x0b.NumberModeR\x04mode:\x13\
    \xf2@\nUSE_NUMBER\xe0@1\xe8@\x01\"z\n\x13NumberStateResponse\x12\x10\n\
    \x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\
    \x02R\x05state\x12#\n\rmissing_state\x18\x03\x20\x01(\x08R\x0cmissingSta\
    te:\x16\x80A\x01\xf2@\nUSE_NUMBER\xe0@2\xe8@\x01\"V\n\x14NumberCommandRe\
    quest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\
    \x18\x02\x20\x01(\x02R\x05state:\x16\x80A\x01\xf2@\nUSE_NUMBER\xe0@3\xe8\
    @\x02\"\xa9\x02\n\x1aListEntitiesSelectResponse\x12\x1b\n\tobject_id\x18\
    \x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03k\
    ey\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\
    \x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12\x18\n\x07options\x18\x06\x20\x03(\tR\x07options\x12.\n\x13d\
    isabled_by_default\x18\x07\x20\x01(\x08R\x11disabledByDefault\x128\n\x0f\
    entity_category\x18\x08\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCateg\
    ory:\x13\xf2@\nUSE_SELECT\xe0@4\xe8@\x01\"z\n\x13SelectStateResponse\x12\
    \x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\
    \x20\x01(\tR\x05state\x12#\n\rmissing_state\x18\x03\x20\x01(\x08R\x0cmis\
    singState:\x16\x80A\x01\xf2@\nUSE_SELECT\xe0@5\xe8@\x01\"V\n\x14SelectCo\
    mmandRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05\
    state\x18\x02\x20\x01(\tR\x05state:\x16\x80A\x01\xf2@\nUSE_SELECT\xe0@6\
    \xe8@\x02\"\x9b\x03\n\x18ListEntitiesLockResponse\x12\x1b\n\tobject_id\
    \x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\
    \x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_\
    id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12.\n\x13disabled_by_default\x18\x06\x20\x01(\x08R\x11disabled\
    ByDefault\x128\n\x0fentity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCate\
    goryR\x0eentityCategory\x12#\n\rassumed_state\x18\x08\x20\x01(\x08R\x0ca\
    ssumedState\x12#\n\rsupports_open\x18\t\x20\x01(\x08R\x0csupportsOpen\
    \x12#\n\rrequires_code\x18\n\x20\x01(\x08R\x0crequiresCode\x12\x1f\n\x0b\
    code_format\x18\x0b\x20\x01(\tR\ncodeFormat:\x11\xf2@\x08USE_LOCK\xe0@:\
    \xe8@\x01\"]\n\x11LockStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\
    \x07R\x03key\x12\x20\n\x05state\x18\x02\x20\x01(\x0e2\n.LockStateR\x05st\
    ate:\x14\x80A\x01\xf2@\x08USE_LOCK\xe0@;\xe8@\x01\"\x93\x01\n\x12LockCom\
    mandRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12&\n\x07comm\
    and\x18\x02\x20\x01(\x0e2\x0c.LockCommandR\x07command\x12\x19\n\x08has_c\
    ode\x18\x03\x20\x01(\x08R\x07hasCode\x12\x12\n\x04code\x18\x04\x20\x01(\
    \tR\x04code:\x14\x80A\x01\xf2@\x08USE_LOCK\xe0@<\xe8@\x02\"\xb2\x02\n\
    \x1aListEntitiesButtonResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13di\
    sabled_by_default\x18\x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fe\
    ntity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCatego\
    ry\x12!\n\x0cdevice_class\x18\x08\x20\x01(\tR\x0bdeviceClass:\x13\xf2@\n\
    USE_BUTTON\xe0@=\xe8@\x01\"@\n\x14ButtonCommandRequest\x12\x10\n\x03key\
    \x18\x01\x20\x01(\x07R\x03key:\x16\x80A\x01\xf2@\nUSE_BUTTON\xe0@>\xe8@\
    \x02*f\n\x0eEntityCategory\x12\x18\n\x14ENTITY_CATEGORY_NONE\x10\0\x12\
    \x1a\n\x16ENTITY_CATEGORY_CONFIG\x10\x01\x12\x1e\n\x1aENTITY_CATEGORY_DI\
    AGNOSTIC\x10\x02*N\n\x10LegacyCoverState\x12\x1b\n\x17LEGACY_COVER_STATE\
    _OPEN\x10\0\x12\x1d\n\x19LEGACY_COVER_STATE_CLOSED\x10\x01*j\n\x0eCoverO\
    peration\x12\x18\n\x14COVER_OPERATION_IDLE\x10\0\x12\x1e\n\x1aCOVER_OPER\
    ATION_IS_OPENING\x10\x01\x12\x1e\n\x1aCOVER_OPERATION_IS_CLOSING\x10\x02\
    *r\n\x12LegacyCoverCommand\x12\x1d\n\x19LEGACY_COVER_COMMAND_OPEN\x10\0\
    \x12\x1e\n\x1aLEGACY_COVER_COMMAND_CLOSE\x10\x01\x12\x1d\n\x19LEGACY_COV\
    ER_COMMAND_STOP\x10\x02*G\n\x08FanSpeed\x12\x11\n\rFAN_SPEED_LOW\x10\0\
    \x12\x14\n\x10FAN_SPEED_MEDIUM\x10\x01\x12\x12\n\x0eFAN_SPEED_HIGH\x10\
    \x02*D\n\x0cFanDirection\x12\x19\n\x15FAN_DIRECTION_FORWARD\x10\0\x12\
    \x19\n\x15FAN_DIRECTION_REVERSE\x10\x01*\xa5\x02\n\tColorMode\x12\x16\n\
    \x12COLOR_MODE_UNKNOWN\x10\0\x12\x15\n\x11COLOR_MODE_ON_OFF\x10\x01\x12\
    \x19\n\x15COLOR_MODE_BRIGHTNESS\x10\x02\x12\x14\n\x10COLOR_MODE_WHITE\
    \x10\x07\x12\x20\n\x1cCOLOR_MODE_COLOR_TEMPERATURE\x10\x0b\x12\x1e\n\x1a\
    COLOR_MODE_COLD_WARM_WHITE\x10\x13\x12\x12\n\x0eCOLOR_MODE_RGB\x10#\x12\
    \x18\n\x14COLOR_MODE_RGB_WHITE\x10'\x12$\n\x20COLOR_MODE_RGB_COLOR_TEMPE\
    RATURE\x10/\x12\"\n\x1eCOLOR_MODE_RGB_COLD_WARM_WHITE\x103*g\n\x10Sensor\
    StateClass\x12\x14\n\x10STATE_CLASS_NONE\x10\0\x12\x1b\n\x17STATE_CLASS_\
    MEASUREMENT\x10\x01\x12\x20\n\x1cSTATE_CLASS_TOTAL_INCREASING\x10\x02*U\
    \n\x13SensorLastResetType\x12\x13\n\x0fLAST_RESET_NONE\x10\0\x12\x14\n\
    \x10LAST_RESET_NEVER\x10\x01\x12\x13\n\x0fLAST_RESET_AUTO\x10\x02*\xb9\
    \x01\n\x08LogLevel\x12\x12\n\x0eLOG_LEVEL_NONE\x10\0\x12\x13\n\x0fLOG_LE\
    VEL_ERROR\x10\x01\x12\x12\n\x0eLOG_LEVEL_WARN\x10\x02\x12\x12\n\x0eLOG_L\
    EVEL_INFO\x10\x03\x12\x14\n\x10LOG_LEVEL_CONFIG\x10\x04\x12\x13\n\x0fLOG\
    _LEVEL_DEBUG\x10\x05\x12\x15\n\x11LOG_LEVEL_VERBOSE\x10\x06\x12\x1a\n\
    \x16LOG_LEVEL_VERY_VERBOSE\x10\x07*\x84\x02\n\x0eServiceArgType\x12\x19\
    \n\x15SERVICE_ARG_TYPE_BOOL\x10\0\x12\x18\n\x14SERVICE_ARG_TYPE_INT\x10\
    \x01\x12\x1a\n\x16SERVICE_ARG_TYPE_FLOAT\x10\x02\x12\x1b\n\x17SERVICE_AR\
    G_TYPE_STRING\x10\x03\x12\x1f\n\x1bSERVICE_ARG_TYPE_BOOL_ARRAY\x10\x04\
    \x12\x1e\n\x1aSERVICE_ARG_TYPE_INT_ARRAY\x10\x05\x12\x20\n\x1cSERVICE_AR\
    G_TYPE_FLOAT_ARRAY\x10\x06\x12!\n\x1dSERVICE_ARG_TYPE_STRING_ARRAY\x10\
    \x07*\xb5\x01\n\x0bClimateMode\x12\x14\n\x10CLIMATE_MODE_OFF\x10\0\x12\
    \x1a\n\x16CLIMATE_MODE_HEAT_COOL\x10\x01\x12\x15\n\x11CLIMATE_MODE_COOL\
    \x10\x02\x12\x15\n\x11CLIMATE_MODE_HEAT\x10\x03\x12\x19\n\x15CLIMATE_MOD\
    E_FAN_ONLY\x10\x04\x12\x14\n\x10CLIMATE_MODE_DRY\x10\x05\x12\x15\n\x11CL\
    IMATE_MODE_AUTO\x10\x06*\xda\x01\n\x0eClimateFanMode\x12\x12\n\x0eCLIMAT\
    E_FAN_ON\x10\0\x12\x13\n\x0fCLIMATE_FAN_OFF\x10\x01\x12\x14\n\x10CLIMATE\
    _FAN_AUTO\x10\x02\x12\x13\n\x0fCLIMATE_FAN_LOW\x10\x03\x12\x16\n\x12CLIM\
    ATE_FAN_MEDIUM\x10\x04\x12\x14\n\x10CLIMATE_FAN_HIGH\x10\x05\x12\x16\n\
    \x12CLIMATE_FAN_MIDDLE\x10\x06\x12\x15\n\x11CLIMATE_FAN_FOCUS\x10\x07\
    \x12\x17\n\x13CLIMATE_FAN_DIFFUSE\x10\x08*{\n\x10ClimateSwingMode\x12\
    \x15\n\x11CLIMATE_SWING_OFF\x10\0\x12\x16\n\x12CLIMATE_SWING_BOTH\x10\
    \x01\x12\x1a\n\x16CLIMATE_SWING_VERTICAL\x10\x02\x12\x1c\n\x18CLIMATE_SW\
    ING_HORIZONTAL\x10\x03*\xab\x01\n\rClimateAction\x12\x16\n\x12CLIMATE_AC\
    TION_OFF\x10\0\x12\x1a\n\x16CLIMATE_ACTION_COOLING\x10\x02\x12\x1a\n\x16\
    CLIMATE_ACTION_HEATING\x10\x03\x12\x17\n\x13CLIMATE_ACTION_IDLE\x10\x04\
    \x12\x19\n\x15CLIMATE_ACTION_DRYING\x10\x05\x12\x16\n\x12CLIMATE_ACTION_\
    FAN\x10\x06*\xdf\x01\n\rClimatePreset\x12\x17\n\x13CLIMATE_PRESET_NONE\
    \x10\0\x12\x17\n\x13CLIMATE_PRESET_HOME\x10\x01\x12\x17\n\x13CLIMATE_PRE\
    SET_AWAY\x10\x02\x12\x18\n\x14CLIMATE_PRESET_BOOST\x10\x03\x12\x1a\n\x16\
    CLIMATE_PRESET_COMFORT\x10\x04\x12\x16\n\x12CLIMATE_PRESET_ECO\x10\x05\
    \x12\x18\n\x14CLIMATE_PRESET_SLEEP\x10\x06\x12\x1b\n\x17CLIMATE_PRESET_A\
    CTIVITY\x10\x07*O\n\nNumberMode\x12\x14\n\x10NUMBER_MODE_AUTO\x10\0\x12\
    \x13\n\x0fNUMBER_MODE_BOX\x10\x01\x12\x16\n\x12NUMBER_MODE_SLIDER\x10\
    \x02*\x99\x01\n\tLockState\x12\x13\n\x0fLOCK_STATE_NONE\x10\0\x12\x15\n\
    \x11LOCK_STATE_LOCKED\x10\x01\x12\x17\n\x13LOCK_STATE_UNLOCKED\x10\x02\
    \x12\x15\n\x11LOCK_STATE_JAMMED\x10\x03\x12\x16\n\x12LOCK_STATE_LOCKING\
    \x10\x04\x12\x18\n\x14LOCK_STATE_UNLOCKING\x10\x05*<\n\x0bLockCommand\
    \x12\x0f\n\x0bLOCK_UNLOCK\x10\0\x12\r\n\tLOCK_LOCK\x10\x01\x12\r\n\tLOCK\
    _OPEN\x10\x022\xa9\t\n\rAPIConnection\x12.\n\x05hello\x12\r.HelloRequest\
    \x1a\x0e.HelloResponse\"\x06\xf0@\0\xf8@\0\x124\n\x07connect\x12\x0f.Con\
    nectRequest\x1a\x10.ConnectResponse\"\x06\xf0@\0\xf8@\0\x12=\n\ndisconne\
    ct\x12\x12.DisconnectRequest\x1a\x13.DisconnectResponse\"\x06\xf0@\0\xf8\
    @\0\x12+\n\x04ping\x12\x0c.PingRequest\x1a\r.PingResponse\"\x06\xf0@\0\
    \xf8@\0\x12;\n\x0bdevice_info\x12\x12.DeviceInfoRequest\x1a\x13.DeviceIn\
    foResponse\"\x03\xf8@\0\x12.\n\rlist_entities\x12\x14.ListEntitiesReques\
    t\x1a\x05.void\"\0\x124\n\x10subscribe_states\x12\x17.SubscribeStatesReq\
    uest\x1a\x05.void\"\0\x120\n\x0esubscribe_logs\x12\x15.SubscribeLogsRequ\
    est\x1a\x05.void\"\0\x12S\n\x20subscribe_homeassistant_services\x12&.Sub\
    scribeHomeassistantServicesRequest\x1a\x05.void\"\0\x12P\n\x1fsubscribe_\
    home_assistant_states\x12$.SubscribeHomeAssistantStatesRequest\x1a\x05.v\
    oid\"\0\x122\n\x08get_time\x12\x0f.GetTimeRequest\x1a\x10.GetTimeRespons\
    e\"\x03\xf8@\0\x122\n\x0fexecute_service\x12\x16.ExecuteServiceRequest\
    \x1a\x05.void\"\0\x12.\n\rcover_command\x12\x14.CoverCommandRequest\x1a\
    \x05.void\"\0\x12*\n\x0bfan_command\x12\x12.FanCommandRequest\x1a\x05.vo\
    id\"\0\x12.\n\rlight_command\x12\x14.LightCommandRequest\x1a\x05.void\"\
    \0\x120\n\x0eswitch_command\x12\x15.SwitchCommandRequest\x1a\x05.void\"\
    \0\x12,\n\x0ccamera_image\x12\x13.CameraImageRequest\x1a\x05.void\"\0\
    \x122\n\x0fclimate_command\x12\x16.ClimateCommandRequest\x1a\x05.void\"\
    \0\x120\n\x0enumber_command\x12\x15.NumberCommandRequest\x1a\x05.void\"\
    \0\x120\n\x0eselect_command\x12\x15.SelectCommandRequest\x1a\x05.void\"\
    \0\x120\n\x0ebutton_command\x12\x15.ButtonCommandRequest\x1a\x05.void\"\
    \0\x12,\n\x0clock_command\x12\x13.LockCommandRequest\x1a\x05.void\"\0J\
    \x8b\xaf\x02\n\x07\x12\x05\0\0\x90\x08\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\t\n\x02\x03\0\x12\x03\x02\0\x1b\n\n\n\x02\x06\0\x12\x04\x04\0,\
    \x01\n\n\n\x03\x06\0\x01\x12\x03\x04\x08\x15\n\x0c\n\x04\x06\0\x02\0\x12\
    \x04\x05\x02\x08\x03\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x05\x06\x0b\n\
    \x0c\n\x05\x06\0\x02\0\x02\x12\x03\x05\r\x19\n\x0c\n\x05\x06\0\x02\0\x03\
    \x12\x03\x05$1\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03\x06\x04,\n\x0e\n\x07\
    \x06\0\x02\0\x04\x8e\x08\x12\x03\x06\x04,\n\x0c\n\x05\x06\0\x02\0\x04\
    \x12\x03\x07\x04*\n\x0e\n\x07\x06\0\x02\0\x04\x8f\x08\x12\x03\x07\x04*\n\
    \x0c\n\x04\x06\0\x02\x01\x12\x04\t\x02\x0c\x03\n\x0c\n\x05\x06\0\x02\x01\
    \x01\x12\x03\t\x06\r\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\t\x0f\x1d\n\
    \x0c\n\x05\x06\0\x02\x01\x03\x12\x03\t(7\n\x0c\n\x05\x06\0\x02\x01\x04\
    \x12\x03\n\x04,\n\x0e\n\x07\x06\0\x02\x01\x04\x8e\x08\x12\x03\n\x04,\n\
    \x0c\n\x05\x06\0\x02\x01\x04\x12\x03\x0b\x04*\n\x0e\n\x07\x06\0\x02\x01\
    \x04\x8f\x08\x12\x03\x0b\x04*\n\x0c\n\x04\x06\0\x02\x02\x12\x04\r\x02\
    \x10\x03\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\r\x06\x10\n\x0c\n\x05\x06\
    \0\x02\x02\x02\x12\x03\r\x12#\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\r.@\
    \n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03\x0e\x04,\n\x0e\n\x07\x06\0\x02\
    \x02\x04\x8e\x08\x12\x03\x0e\x04,\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03\
    \x0f\x04*\n\x0e\n\x07\x06\0\x02\x02\x04\x8f\x08\x12\x03\x0f\x04*\n\x0c\n\
    \x04\x06\0\x02\x03\x12\x04\x11\x02\x14\x03\n\x0c\n\x05\x06\0\x02\x03\x01\
    \x12\x03\x11\x06\n\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\x11\x0c\x17\n\
    \x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x11\".\n\x0c\n\x05\x06\0\x02\x03\
    \x04\x12\x03\x12\x04,\n\x0e\n\x07\x06\0\x02\x03\x04\x8e\x08\x12\x03\x12\
    \x04,\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03\x13\x04*\n\x0e\n\x07\x06\0\
    \x02\x03\x04\x8f\x08\x12\x03\x13\x04*\n\x0c\n\x04\x06\0\x02\x04\x12\x04\
    \x15\x02\x17\x03\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\x15\x06\x11\n\x0c\
    \n\x05\x06\0\x02\x04\x02\x12\x03\x15\x13$\n\x0c\n\x05\x06\0\x02\x04\x03\
    \x12\x03\x15/A\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03\x16\x04*\n\x0e\n\
    \x07\x06\0\x02\x04\x04\x8f\x08\x12\x03\x16\x04*\n\x0b\n\x04\x06\0\x02\
    \x05\x12\x03\x18\x02;\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03\x18\x06\x13\
    \n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03\x18\x15(\n\x0c\n\x05\x06\0\x02\
    \x05\x03\x12\x03\x1837\n\x0b\n\x04\x06\0\x02\x06\x12\x03\x19\x02A\n\x0c\
    \n\x05\x06\0\x02\x06\x01\x12\x03\x19\x06\x16\n\x0c\n\x05\x06\0\x02\x06\
    \x02\x12\x03\x19\x18.\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03\x199=\n\x0b\
    \n\x04\x06\0\x02\x07\x12\x03\x1a\x02=\n\x0c\n\x05\x06\0\x02\x07\x01\x12\
    \x03\x1a\x06\x14\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03\x1a\x16*\n\x0c\n\
    \x05\x06\0\x02\x07\x03\x12\x03\x1a59\n\x0b\n\x04\x06\0\x02\x08\x12\x03\
    \x1b\x02`\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03\x1b\x06&\n\x0c\n\x05\x06\
    \0\x02\x08\x02\x12\x03\x1b(M\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03\x1bX\
    \\\n\x0b\n\x04\x06\0\x02\t\x12\x03\x1c\x02]\n\x0c\n\x05\x06\0\x02\t\x01\
    \x12\x03\x1c\x06%\n\x0c\n\x05\x06\0\x02\t\x02\x12\x03\x1c'J\n\x0c\n\x05\
    \x06\0\x02\t\x03\x12\x03\x1cUY\n\x0c\n\x04\x06\0\x02\n\x12\x04\x1d\x02\
    \x1f\x03\n\x0c\n\x05\x06\0\x02\n\x01\x12\x03\x1d\x06\x0e\n\x0c\n\x05\x06\
    \0\x02\n\x02\x12\x03\x1d\x10\x1e\n\x0c\n\x05\x06\0\x02\n\x03\x12\x03\x1d\
    )8\n\x0c\n\x05\x06\0\x02\n\x04\x12\x03\x1e\x04*\n\x0e\n\x07\x06\0\x02\n\
    \x04\x8f\x08\x12\x03\x1e\x04*\n\x0b\n\x04\x06\0\x02\x0b\x12\x03\x20\x02?\
    \n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03\x20\x06\x15\n\x0c\n\x05\x06\0\x02\
    \x0b\x02\x12\x03\x20\x17,\n\x0c\n\x05\x06\0\x02\x0b\x03\x12\x03\x207;\n\
    \x0b\n\x04\x06\0\x02\x0c\x12\x03\"\x02;\n\x0c\n\x05\x06\0\x02\x0c\x01\
    \x12\x03\"\x06\x13\n\x0c\n\x05\x06\0\x02\x0c\x02\x12\x03\"\x15(\n\x0c\n\
    \x05\x06\0\x02\x0c\x03\x12\x03\"37\n\x0b\n\x04\x06\0\x02\r\x12\x03#\x027\
    \n\x0c\n\x05\x06\0\x02\r\x01\x12\x03#\x06\x11\n\x0c\n\x05\x06\0\x02\r\
    \x02\x12\x03#\x13$\n\x0c\n\x05\x06\0\x02\r\x03\x12\x03#/3\n\x0b\n\x04\
    \x06\0\x02\x0e\x12\x03$\x02;\n\x0c\n\x05\x06\0\x02\x0e\x01\x12\x03$\x06\
    \x13\n\x0c\n\x05\x06\0\x02\x0e\x02\x12\x03$\x15(\n\x0c\n\x05\x06\0\x02\
    \x0e\x03\x12\x03$37\n\x0b\n\x04\x06\0\x02\x0f\x12\x03%\x02=\n\x0c\n\x05\
    \x06\0\x02\x0f\x01\x12\x03%\x06\x14\n\x0c\n\x05\x06\0\x02\x0f\x02\x12\
    \x03%\x16*\n\x0c\n\x05\x06\0\x02\x0f\x03\x12\x03%59\n\x0b\n\x04\x06\0\
    \x02\x10\x12\x03&\x029\n\x0c\n\x05\x06\0\x02\x10\x01\x12\x03&\x06\x12\n\
    \x0c\n\x05\x06\0\x02\x10\x02\x12\x03&\x14&\n\x0c\n\x05\x06\0\x02\x10\x03\
    \x12\x03&15\n\x0b\n\x04\x06\0\x02\x11\x12\x03'\x02?\n\x0c\n\x05\x06\0\
    \x02\x11\x01\x12\x03'\x06\x15\n\x0c\n\x05\x06\0\x02\x11\x02\x12\x03'\x17\
    ,\n\x0c\n\x05\x06\0\x02\x11\x03\x12\x03'7;\n\x0b\n\x04\x06\0\x02\x12\x12\
    \x03(\x02=\n\x0c\n\x05\x06\0\x02\x12\x01\x12\x03(\x06\x14\n\x0c\n\x05\
    \x06\0\x02\x12\x02\x12\x03(\x16*\n\x0c\n\x05\x06\0\x02\x12\x03\x12\x03(5\
    9\n\x0b\n\x04\x06\0\x02\x13\x12\x03)\x02=\n\x0c\n\x05\x06\0\x02\x13\x01\
    \x12\x03)\x06\x14\n\x0c\n\x05\x06\0\x02\x13\x02\x12\x03)\x16*\n\x0c\n\
    \x05\x06\0\x02\x13\x03\x12\x03)59\n\x0b\n\x04\x06\0\x02\x14\x12\x03*\x02\
    =\n\x0c\n\x05\x06\0\x02\x14\x01\x12\x03*\x06\x14\n\x0c\n\x05\x06\0\x02\
    \x14\x02\x12\x03*\x16*\n\x0c\n\x05\x06\0\x02\x14\x03\x12\x03*59\n\x0b\n\
    \x04\x06\0\x02\x15\x12\x03+\x029\n\x0c\n\x05\x06\0\x02\x15\x01\x12\x03+\
    \x06\x12\n\x0c\n\x05\x06\0\x02\x15\x02\x12\x03+\x14&\n\x0c\n\x05\x06\0\
    \x02\x15\x03\x12\x03+15\n\xff\x08\n\x02\x04\0\x12\x04D\0N\x01\x1a~\x20Me\
    ssage\x20sent\x20at\x20the\x20beginning\x20of\x20each\x20connection\n\
    \x20Can\x20only\x20be\x20sent\x20by\x20the\x20client\x20and\x20only\x20a\
    t\x20the\x20beginning\x20of\x20the\x20connection\n28\x20================\
    ====\x20BASE\x20PACKETS\x20====================\n2\xfd\x02\x20The\x20Hom\
    e\x20Assistant\x20protocol\x20is\x20structured\x20as\x20a\x20simple\n\
    \x20TCP\x20socket\x20with\x20short\x20binary\x20messages\x20encoded\x20i\
    n\x20the\x20protocol\x20buffers\x20format\n\x20First,\x20a\x20message\
    \x20in\x20this\x20protocol\x20has\x20a\x20specific\x20format:\n\x20\x20*\
    \x20A\x20zero\x20byte.\n\x20\x20*\x20VarInt\x20denoting\x20the\x20size\
    \x20of\x20the\x20message\x20object.\x20(type\x20is\x20not\x20part\x20of\
    \x20this)\n\x20\x20*\x20VarInt\x20denoting\x20the\x20type\x20of\x20messa\
    ge.\n\x20\x20*\x20The\x20message\x20object\x20encoded\x20as\x20a\x20Prot\
    oBuf\x20message\n2\xb8\x04\x20The\x20connection\x20is\x20established\x20\
    in\x204\x20steps:\n\x20\x20*\x20First,\x20the\x20client\x20connects\x20t\
    o\x20the\x20server\x20and\x20sends\x20a\x20\"Hello\x20Request\"\x20ident\
    ifying\x20itself\n\x20\x20*\x20The\x20server\x20responds\x20with\x20a\
    \x20\"Hello\x20Response\"\x20and\x20selects\x20the\x20protocol\x20versio\
    n\n\x20\x20*\x20After\x20receiving\x20this\x20message,\x20the\x20client\
    \x20attempts\x20to\x20authenticate\x20itself\x20using\n\x20\x20\x20\x20t\
    he\x20password\x20and\x20a\x20\"Connect\x20Request\"\n\x20\x20*\x20The\
    \x20server\x20responds\x20with\x20a\x20\"Connect\x20Response\"\x20and\
    \x20notifies\x20of\x20invalid\x20password.\n\x20If\x20anything\x20in\x20\
    this\x20initial\x20process\x20fails,\x20the\x20connection\x20must\x20imm\
    ediately\x20closed\n\x20by\x20both\x20sides\x20and\x20_no_\x20disconnect\
    ion\x20message\x20is\x20to\x20be\x20sent.\n\n\n\n\x03\x04\0\x01\x12\x03D\
    \x08\x14\n\n\n\x03\x04\0\x07\x12\x03E\x02\x12\n\x0c\n\x05\x04\0\x07\x8c\
    \x08\x12\x03E\x02\x12\n\n\n\x03\x04\0\x07\x12\x03F\x02\"\n\x0c\n\x05\x04\
    \0\x07\x8d\x08\x12\x03F\x02\"\n\n\n\x03\x04\0\x07\x12\x03G\x02\x1b\n\x0c\
    \n\x05\x04\0\x07\x90\x08\x12\x03G\x02\x1b\n\x97\x01\n\x04\x04\0\x02\0\
    \x12\x03M\x02\x19\x1a\x89\x01\x20Description\x20of\x20client\x20(like\
    \x20User\x20Agent)\n\x20For\x20example\x20\"Home\x20Assistant\"\n\x20Not\
    \x20strictly\x20necessary\x20to\x20send\x20but\x20nice\x20for\x20debuggi\
    ng\n\x20purposes.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03M\x02\x08\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03M\t\x14\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03M\
    \x17\x18\n\x88\x01\n\x02\x04\x01\x12\x04R\0e\x01\x1a|\x20Confirmation\
    \x20of\x20successful\x20connection\x20request.\n\x20Can\x20only\x20be\
    \x20sent\x20by\x20the\x20server\x20and\x20only\x20at\x20the\x20beginning\
    \x20of\x20the\x20connection\n\n\n\n\x03\x04\x01\x01\x12\x03R\x08\x15\n\n\
    \n\x03\x04\x01\x07\x12\x03S\x02\x12\n\x0c\n\x05\x04\x01\x07\x8c\x08\x12\
    \x03S\x02\x12\n\n\n\x03\x04\x01\x07\x12\x03T\x02\"\n\x0c\n\x05\x04\x01\
    \x07\x8d\x08\x12\x03T\x02\"\n\n\n\x03\x04\x01\x07\x12\x03U\x02\x1b\n\x0c\
    \n\x05\x04\x01\x07\x90\x08\x12\x03U\x02\x1b\n\xef\x02\n\x04\x04\x01\x02\
    \0\x12\x03[\x02\x1f\x1a\xe1\x02\x20The\x20version\x20of\x20the\x20API\
    \x20to\x20use.\x20The\x20_client_\x20(for\x20example\x20Home\x20Assistan\
    t)\x20needs\x20to\x20check\n\x20for\x20compatibility\x20and\x20if\x20nec\
    essary\x20adopt\x20to\x20an\x20older\x20API.\n\x20Major\x20is\x20for\x20\
    breaking\x20changes\x20in\x20the\x20base\x20protocol\x20-\x20a\x20mismat\
    ch\x20will\x20lead\x20to\x20immediate\x20disconnect_client_\n\x20Minor\
    \x20is\x20for\x20breaking\x20changes\x20in\x20individual\x20messages\x20\
    -\x20a\x20mismatch\x20will\x20lead\x20to\x20a\x20warning\x20message\n\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\x01\x02\0\
    \x01\x12\x03[\t\x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03[\x1d\x1e\n\x0b\
    \n\x04\x04\x01\x02\x01\x12\x03\\\x02\x1f\n\x0c\n\x05\x04\x01\x02\x01\x05\
    \x12\x03\\\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\\\t\x1a\n\x0c\
    \n\x05\x04\x01\x02\x01\x03\x12\x03\\\x1d\x1e\n\xb4\x01\n\x04\x04\x01\x02\
    \x02\x12\x03a\x02\x19\x1a\xa6\x01\x20A\x20string\x20identifying\x20the\
    \x20server\x20(ESP);\x20like\x20client\x20info\x20this\x20may\x20be\x20e\
    mpty\n\x20and\x20only\x20exists\x20for\x20debugging/logging\x20purposes.\
    \n\x20For\x20example\x20\"ESPHome\x20v1.10.0\x20on\x20ESP8266\"\n\n\x0c\
    \n\x05\x04\x01\x02\x02\x05\x12\x03a\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\
    \x01\x12\x03a\t\x14\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03a\x17\x18\n6\
    \n\x04\x04\x01\x02\x03\x12\x03d\x02\x12\x1a)\x20The\x20name\x20of\x20the\
    \x20server\x20(App.get_name())\n\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\
    d\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03d\t\r\n\x0c\n\x05\x04\
    \x01\x02\x03\x03\x12\x03d\x10\x11\n\xa6\x01\n\x02\x04\x02\x12\x04i\0p\
    \x01\x1a\x99\x01\x20Message\x20sent\x20at\x20the\x20beginning\x20of\x20e\
    ach\x20connection\x20to\x20authenticate\x20the\x20client\n\x20Can\x20onl\
    y\x20be\x20sent\x20by\x20the\x20client\x20and\x20only\x20at\x20the\x20be\
    ginning\x20of\x20the\x20connection\n\n\n\n\x03\x04\x02\x01\x12\x03i\x08\
    \x16\n\n\n\x03\x04\x02\x07\x12\x03j\x02\x12\n\x0c\n\x05\x04\x02\x07\x8c\
    \x08\x12\x03j\x02\x12\n\n\n\x03\x04\x02\x07\x12\x03k\x02\"\n\x0c\n\x05\
    \x04\x02\x07\x8d\x08\x12\x03k\x02\"\n\n\n\x03\x04\x02\x07\x12\x03l\x02\
    \x1b\n\x0c\n\x05\x04\x02\x07\x90\x08\x12\x03l\x02\x1b\n*\n\x04\x04\x02\
    \x02\0\x12\x03o\x02\x16\x1a\x1d\x20The\x20password\x20to\x20log\x20in\
    \x20with\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03o\x02\x08\n\x0c\n\x05\
    \x04\x02\x02\0\x01\x12\x03o\t\x11\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03o\
    \x14\x15\n\xb9\x01\n\x02\x04\x03\x12\x04t\0z\x01\x1a\xac\x01\x20Confirma\
    tion\x20of\x20successful\x20connection.\x20After\x20this\x20the\x20conne\
    ction\x20is\x20available\x20for\x20all\x20traffic.\n\x20Can\x20only\x20b\
    e\x20sent\x20by\x20the\x20server\x20and\x20only\x20at\x20the\x20beginnin\
    g\x20of\x20the\x20connection\n\n\n\n\x03\x04\x03\x01\x12\x03t\x08\x17\n\
    \n\n\x03\x04\x03\x07\x12\x03u\x02\x12\n\x0c\n\x05\x04\x03\x07\x8c\x08\
    \x12\x03u\x02\x12\n\n\n\x03\x04\x03\x07\x12\x03v\x02\"\n\x0c\n\x05\x04\
    \x03\x07\x8d\x08\x12\x03v\x02\"\n\n\n\x03\x04\x03\x07\x12\x03w\x02\x1b\n\
    \x0c\n\x05\x04\x03\x07\x90\x08\x12\x03w\x02\x1b\n\x0b\n\x04\x04\x03\x02\
    \0\x12\x03y\x02\x1c\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03y\x02\x06\n\x0c\
    \n\x05\x04\x03\x02\0\x01\x12\x03y\x07\x17\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03y\x1a\x1b\nZ\n\x02\x04\x04\x12\x05~\0\x84\x01\x01\x1aM\x20Reques\
    t\x20to\x20close\x20the\x20connection.\n\x20Can\x20be\x20sent\x20by\x20b\
    oth\x20the\x20client\x20and\x20server\n\n\n\n\x03\x04\x04\x01\x12\x03~\
    \x08\x19\n\n\n\x03\x04\x04\x07\x12\x03\x7f\x02\x12\n\x0c\n\x05\x04\x04\
    \x07\x8c\x08\x12\x03\x7f\x02\x12\n\x0b\n\x03\x04\x04\x07\x12\x04\x80\x01\
    \x02\x20\n\r\n\x05\x04\x04\x07\x8d\x08\x12\x04\x80\x01\x02\x20\n\x0b\n\
    \x03\x04\x04\x07\x12\x04\x81\x01\x02\x1b\n\r\n\x05\x04\x04\x07\x90\x08\
    \x12\x04\x81\x01\x02\x1b\n\x0c\n\x02\x04\x05\x12\x06\x86\x01\0\x8d\x01\
    \x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x86\x01\x08\x1a\n\x0b\n\x03\x04\x05\
    \x07\x12\x04\x87\x01\x02\x12\n\r\n\x05\x04\x05\x07\x8c\x08\x12\x04\x87\
    \x01\x02\x12\n\x0b\n\x03\x04\x05\x07\x12\x04\x88\x01\x02\x20\n\r\n\x05\
    \x04\x05\x07\x8d\x08\x12\x04\x88\x01\x02\x20\n\x0b\n\x03\x04\x05\x07\x12\
    \x04\x89\x01\x02\x1b\n\r\n\x05\x04\x05\x07\x90\x08\x12\x04\x89\x01\x02\
    \x1b\n\x0c\n\x02\x04\x06\x12\x06\x8f\x01\0\x93\x01\x01\n\x0b\n\x03\x04\
    \x06\x01\x12\x04\x8f\x01\x08\x13\n\x0b\n\x03\x04\x06\x07\x12\x04\x90\x01\
    \x02\x12\n\r\n\x05\x04\x06\x07\x8c\x08\x12\x04\x90\x01\x02\x12\n\x0b\n\
    \x03\x04\x06\x07\x12\x04\x91\x01\x02\x20\n\x16\n\x05\x04\x06\x07\x8d\x08\
    \x12\x04\x91\x01\x02\x20\"\x07\x20Empty\n\n\x0c\n\x02\x04\x07\x12\x06\
    \x95\x01\0\x99\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x95\x01\x08\x14\n\
    \x0b\n\x03\x04\x07\x07\x12\x04\x96\x01\x02\x12\n\r\n\x05\x04\x07\x07\x8c\
    \x08\x12\x04\x96\x01\x02\x12\n\x0b\n\x03\x04\x07\x07\x12\x04\x97\x01\x02\
    \x20\n\x16\n\x05\x04\x07\x07\x8d\x08\x12\x04\x97\x01\x02\x20\"\x07\x20Em\
    pty\n\n\x0c\n\x02\x04\x08\x12\x06\x9b\x01\0\x9f\x01\x01\n\x0b\n\x03\x04\
    \x08\x01\x12\x04\x9b\x01\x08\x19\n\x0b\n\x03\x04\x08\x07\x12\x04\x9c\x01\
    \x02\x12\n\r\n\x05\x04\x08\x07\x8c\x08\x12\x04\x9c\x01\x02\x12\n\x0b\n\
    \x03\x04\x08\x07\x12\x04\x9d\x01\x02\"\n\x16\n\x05\x04\x08\x07\x8d\x08\
    \x12\x04\x9d\x01\x02\"\"\x07\x20Empty\n\n\x0c\n\x02\x04\t\x12\x06\xa1\
    \x01\0\xbf\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xa1\x01\x08\x1a\n\x0b\n\
    \x03\x04\t\x07\x12\x04\xa2\x01\x02\x13\n\r\n\x05\x04\t\x07\x8c\x08\x12\
    \x04\xa2\x01\x02\x13\n\x0b\n\x03\x04\t\x07\x12\x04\xa3\x01\x02\"\n\r\n\
    \x05\x04\t\x07\x8d\x08\x12\x04\xa3\x01\x02\"\n\x0c\n\x04\x04\t\x02\0\x12\
    \x04\xa5\x01\x02\x19\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xa5\x01\x02\x06\n\
    \r\n\x05\x04\t\x02\0\x01\x12\x04\xa5\x01\x07\x14\n\r\n\x05\x04\t\x02\0\
    \x03\x12\x04\xa5\x01\x17\x18\n?\n\x04\x04\t\x02\x01\x12\x04\xa8\x01\x02\
    \x12\x1a1\x20The\x20name\x20of\x20the\x20node,\x20given\x20by\x20\"App.s\
    et_name()\"\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xa8\x01\x02\x08\n\r\n\
    \x05\x04\t\x02\x01\x01\x12\x04\xa8\x01\t\r\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\xa8\x01\x10\x11\nN\n\x04\x04\t\x02\x02\x12\x04\xab\x01\x02\x19\
    \x1a@\x20The\x20mac\x20address\x20of\x20the\x20device.\x20For\x20example\
    \x20\"AC:BC:32:89:0E:A9\"\n\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xab\x01\
    \x02\x08\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xab\x01\t\x14\n\r\n\x05\x04\
    \t\x02\x02\x03\x12\x04\xab\x01\x17\x18\nM\n\x04\x04\t\x02\x03\x12\x04\
    \xae\x01\x02\x1d\x1a?\x20A\x20string\x20describing\x20the\x20ESPHome\x20\
    version.\x20For\x20example\x20\"1.10.0\"\n\n\r\n\x05\x04\t\x02\x03\x05\
    \x12\x04\xae\x01\x02\x08\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xae\x01\t\
    \x18\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xae\x01\x1b\x1c\n\xd7\x01\n\x04\
    \x04\t\x02\x04\x12\x04\xb3\x01\x02\x1e\x1a\xc8\x01\x20A\x20string\x20des\
    cribing\x20the\x20date\x20of\x20compilation,\x20this\x20is\x20generated\
    \x20by\x20the\x20compiler\n\x20and\x20therefore\x20may\x20not\x20be\x20i\
    n\x20the\x20same\x20format\x20all\x20the\x20time.\n\x20If\x20the\x20user\
    \x20isn't\x20using\x20ESPHome,\x20this\x20will\x20also\x20not\x20be\x20s\
    et.\n\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xb3\x01\x02\x08\n\r\n\x05\x04\
    \t\x02\x04\x01\x12\x04\xb3\x01\t\x19\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\
    \xb3\x01\x1c\x1d\n;\n\x04\x04\t\x02\x05\x12\x04\xb6\x01\x02\x13\x1a-\x20\
    The\x20model\x20of\x20the\x20board.\x20For\x20example\x20NodeMCU\n\n\r\n\
    \x05\x04\t\x02\x05\x05\x12\x04\xb6\x01\x02\x08\n\r\n\x05\x04\t\x02\x05\
    \x01\x12\x04\xb6\x01\t\x0e\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xb6\x01\
    \x11\x12\n\x0c\n\x04\x04\t\x02\x06\x12\x04\xb8\x01\x02\x1a\n\r\n\x05\x04\
    \t\x02\x06\x05\x12\x04\xb8\x01\x02\x06\n\r\n\x05\x04\t\x02\x06\x01\x12\
    \x04\xb8\x01\x07\x15\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\xb8\x01\x18\x19\
    \n2\n\x04\x04\t\x02\x07\x12\x04\xbb\x01\x02\x1a\x1a$\x20The\x20esphome\
    \x20project\x20details\x20if\x20set\n\n\r\n\x05\x04\t\x02\x07\x05\x12\
    \x04\xbb\x01\x02\x08\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xbb\x01\t\x15\n\
    \r\n\x05\x04\t\x02\x07\x03\x12\x04\xbb\x01\x18\x19\n\x0c\n\x04\x04\t\x02\
    \x08\x12\x04\xbc\x01\x02\x1d\n\r\n\x05\x04\t\x02\x08\x05\x12\x04\xbc\x01\
    \x02\x08\n\r\n\x05\x04\t\x02\x08\x01\x12\x04\xbc\x01\t\x18\n\r\n\x05\x04\
    \t\x02\x08\x03\x12\x04\xbc\x01\x1b\x1c\n\x0c\n\x04\x04\t\x02\t\x12\x04\
    \xbe\x01\x02\x1d\n\r\n\x05\x04\t\x02\t\x05\x12\x04\xbe\x01\x02\x08\n\r\n\
    \x05\x04\t\x02\t\x01\x12\x04\xbe\x01\t\x17\n\r\n\x05\x04\t\x02\t\x03\x12\
    \x04\xbe\x01\x1a\x1c\n\x0c\n\x02\x04\n\x12\x06\xc1\x01\0\xc5\x01\x01\n\
    \x0b\n\x03\x04\n\x01\x12\x04\xc1\x01\x08\x1b\n\x0b\n\x03\x04\n\x07\x12\
    \x04\xc2\x01\x02\x13\n\r\n\x05\x04\n\x07\x8c\x08\x12\x04\xc2\x01\x02\x13\
    \n\x0b\n\x03\x04\n\x07\x12\x04\xc3\x01\x02\"\n\x16\n\x05\x04\n\x07\x8d\
    \x08\x12\x04\xc3\x01\x02\"\"\x07\x20Empty\n\n\x0c\n\x02\x04\x0b\x12\x06\
    \xc6\x01\0\xcb\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xc6\x01\x08\x20\n\
    \x0b\n\x03\x04\x0b\x07\x12\x04\xc7\x01\x02\x13\n\r\n\x05\x04\x0b\x07\x8c\
    \x08\x12\x04\xc7\x01\x02\x13\n\x0b\n\x03\x04\x0b\x07\x12\x04\xc8\x01\x02\
    \"\n\r\n\x05\x04\x0b\x07\x8d\x08\x12\x04\xc8\x01\x02\"\n\x0b\n\x03\x04\
    \x0b\x07\x12\x04\xc9\x01\x02\x1b\n\x16\n\x05\x04\x0b\x07\x90\x08\x12\x04\
    \xc9\x01\x02\x1b\"\x07\x20Empty\n\n\x0c\n\x02\x04\x0c\x12\x06\xcc\x01\0\
    \xd0\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xcc\x01\x08\x1e\n\x0b\n\x03\
    \x04\x0c\x07\x12\x04\xcd\x01\x02\x13\n\r\n\x05\x04\x0c\x07\x8c\x08\x12\
    \x04\xcd\x01\x02\x13\n\x0b\n\x03\x04\x0c\x07\x12\x04\xce\x01\x02\"\n\x16\
    \n\x05\x04\x0c\x07\x8d\x08\x12\x04\xce\x01\x02\"\"\x07\x20Empty\n\nA\n\
    \x02\x05\0\x12\x06\xd4\x01\0\xd8\x01\x0123\x20====================\x20CO\
    MMON\x20=====================\n\n\x0b\n\x03\x05\0\x01\x12\x04\xd4\x01\
    \x05\x13\n\x0c\n\x04\x05\0\x02\0\x12\x04\xd5\x01\x02\x1b\n\r\n\x05\x05\0\
    \x02\0\x01\x12\x04\xd5\x01\x02\x16\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xd5\
    \x01\x19\x1a\n\x0c\n\x04\x05\0\x02\x01\x12\x04\xd6\x01\x02\x1d\n\r\n\x05\
    \x05\0\x02\x01\x01\x12\x04\xd6\x01\x02\x18\n\r\n\x05\x05\0\x02\x01\x02\
    \x12\x04\xd6\x01\x1b\x1c\n\x0c\n\x04\x05\0\x02\x02\x12\x04\xd7\x01\x02!\
    \n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xd7\x01\x02\x1c\n\r\n\x05\x05\0\x02\
    \x02\x02\x12\x04\xd7\x01\x1f\x20\nG\n\x02\x04\r\x12\x06\xdb\x01\0\xea\
    \x01\x01\x1a9\x20====================\x20BINARY\x20SENSOR\x20===========\
    =========\n\n\x0b\n\x03\x04\r\x01\x12\x04\xdb\x01\x08(\n\x0b\n\x03\x04\r\
    \x07\x12\x04\xdc\x01\x02\x13\n\r\n\x05\x04\r\x07\x8c\x08\x12\x04\xdc\x01\
    \x02\x13\n\x0b\n\x03\x04\r\x07\x12\x04\xdd\x01\x02\"\n\r\n\x05\x04\r\x07\
    \x8d\x08\x12\x04\xdd\x01\x02\"\n\x0b\n\x03\x04\r\x07\x12\x04\xde\x01\x02\
    '\n\r\n\x05\x04\r\x07\x8e\x08\x12\x04\xde\x01\x02'\n\x0c\n\x04\x04\r\x02\
    \0\x12\x04\xe0\x01\x02\x17\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xe0\x01\x02\
    \x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xe0\x01\t\x12\n\r\n\x05\x04\r\x02\
    \0\x03\x12\x04\xe0\x01\x15\x16\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xe1\x01\
    \x02\x12\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xe1\x01\x02\t\n\r\n\x05\x04\
    \r\x02\x01\x01\x12\x04\xe1\x01\n\r\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\
    \xe1\x01\x10\x11\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xe2\x01\x02\x12\n\r\n\
    \x05\x04\r\x02\x02\x05\x12\x04\xe2\x01\x02\x08\n\r\n\x05\x04\r\x02\x02\
    \x01\x12\x04\xe2\x01\t\r\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xe2\x01\x10\
    \x11\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xe3\x01\x02\x17\n\r\n\x05\x04\r\
    \x02\x03\x05\x12\x04\xe3\x01\x02\x08\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\
    \xe3\x01\t\x12\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xe3\x01\x15\x16\n\x0c\
    \n\x04\x04\r\x02\x04\x12\x04\xe5\x01\x02\x1a\n\r\n\x05\x04\r\x02\x04\x05\
    \x12\x04\xe5\x01\x02\x08\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xe5\x01\t\
    \x15\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\xe5\x01\x18\x19\n\x0c\n\x04\x04\
    \r\x02\x05\x12\x04\xe6\x01\x02#\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\xe6\
    \x01\x02\x06\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\xe6\x01\x07\x1e\n\r\n\
    \x05\x04\r\x02\x05\x03\x12\x04\xe6\x01!\"\n\x0c\n\x04\x04\r\x02\x06\x12\
    \x04\xe7\x01\x02\x1f\n\r\n\x05\x04\r\x02\x06\x05\x12\x04\xe7\x01\x02\x06\
    \n\r\n\x05\x04\r\x02\x06\x01\x12\x04\xe7\x01\x07\x1a\n\r\n\x05\x04\r\x02\
    \x06\x03\x12\x04\xe7\x01\x1d\x1e\n\x0c\n\x04\x04\r\x02\x07\x12\x04\xe8\
    \x01\x02\x12\n\r\n\x05\x04\r\x02\x07\x05\x12\x04\xe8\x01\x02\x08\n\r\n\
    \x05\x04\r\x02\x07\x01\x12\x04\xe8\x01\t\r\n\r\n\x05\x04\r\x02\x07\x03\
    \x12\x04\xe8\x01\x10\x11\n\x0c\n\x04\x04\r\x02\x08\x12\x04\xe9\x01\x02%\
    \n\r\n\x05\x04\r\x02\x08\x06\x12\x04\xe9\x01\x02\x10\n\r\n\x05\x04\r\x02\
    \x08\x01\x12\x04\xe9\x01\x11\x20\n\r\n\x05\x04\r\x02\x08\x03\x12\x04\xe9\
    \x01#$\n\x0c\n\x02\x04\x0e\x12\x06\xeb\x01\0\xf6\x01\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xeb\x01\x08!\n\x0b\n\x03\x04\x0e\x07\x12\x04\xec\x01\
    \x02\x13\n\r\n\x05\x04\x0e\x07\x8c\x08\x12\x04\xec\x01\x02\x13\n\x0b\n\
    \x03\x04\x0e\x07\x12\x04\xed\x01\x02\"\n\r\n\x05\x04\x0e\x07\x8d\x08\x12\
    \x04\xed\x01\x02\"\n\x0b\n\x03\x04\x0e\x07\x12\x04\xee\x01\x02'\n\r\n\
    \x05\x04\x0e\x07\x8e\x08\x12\x04\xee\x01\x02'\n\x0b\n\x03\x04\x0e\x07\
    \x12\x04\xef\x01\x02\x1b\n\r\n\x05\x04\x0e\x07\x90\x08\x12\x04\xef\x01\
    \x02\x1b\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xf1\x01\x02\x12\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\xf1\x01\x02\t\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xf1\x01\n\r\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xf1\x01\x10\x11\n\x0c\n\
    \x04\x04\x0e\x02\x01\x12\x04\xf2\x01\x02\x11\n\r\n\x05\x04\x0e\x02\x01\
    \x05\x12\x04\xf2\x01\x02\x06\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xf2\
    \x01\x07\x0c\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xf2\x01\x0f\x10\n\x97\
    \x01\n\x04\x04\x0e\x02\x02\x12\x04\xf5\x01\x02\x19\x1a\x88\x01\x20If\x20\
    the\x20binary\x20sensor\x20does\x20not\x20have\x20a\x20valid\x20state\
    \x20yet.\n\x20Equivalent\x20to\x20`!obj->has_state()`\x20-\x20inverse\
    \x20logic\x20to\x20make\x20state\x20packets\x20smaller\n\n\r\n\x05\x04\
    \x0e\x02\x02\x05\x12\x04\xf5\x01\x02\x06\n\r\n\x05\x04\x0e\x02\x02\x01\
    \x12\x04\xf5\x01\x07\x14\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xf5\x01\
    \x17\x18\n?\n\x02\x04\x0f\x12\x06\xf9\x01\0\x8a\x02\x01\x1a1\x20========\
    ============\x20COVER\x20====================\n\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xf9\x01\x08!\n\x0b\n\x03\x04\x0f\x07\x12\x04\xfa\x01\x02\x13\n\
    \r\n\x05\x04\x0f\x07\x8c\x08\x12\x04\xfa\x01\x02\x13\n\x0b\n\x03\x04\x0f\
    \x07\x12\x04\xfb\x01\x02\"\n\r\n\x05\x04\x0f\x07\x8d\x08\x12\x04\xfb\x01\
    \x02\"\n\x0b\n\x03\x04\x0f\x07\x12\x04\xfc\x01\x02\x1f\n\r\n\x05\x04\x0f\
    \x07\x8e\x08\x12\x04\xfc\x01\x02\x1f\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\
    \xfe\x01\x02\x17\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xfe\x01\x02\x08\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\xfe\x01\t\x12\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xfe\x01\x15\x16\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xff\x01\
    \x02\x12\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xff\x01\x02\t\n\r\n\x05\
    \x04\x0f\x02\x01\x01\x12\x04\xff\x01\n\r\n\r\n\x05\x04\x0f\x02\x01\x03\
    \x12\x04\xff\x01\x10\x11\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\x80\x02\x02\
    \x12\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\x80\x02\x02\x08\n\r\n\x05\x04\
    \x0f\x02\x02\x01\x12\x04\x80\x02\t\r\n\r\n\x05\x04\x0f\x02\x02\x03\x12\
    \x04\x80\x02\x10\x11\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\x81\x02\x02\x17\
    \n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\x81\x02\x02\x08\n\r\n\x05\x04\x0f\
    \x02\x03\x01\x12\x04\x81\x02\t\x12\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\
    \x81\x02\x15\x16\n\x0c\n\x04\x04\x0f\x02\x04\x12\x04\x83\x02\x02\x19\n\r\
    \n\x05\x04\x0f\x02\x04\x05\x12\x04\x83\x02\x02\x06\n\r\n\x05\x04\x0f\x02\
    \x04\x01\x12\x04\x83\x02\x07\x14\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\
    \x83\x02\x17\x18\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\x84\x02\x02\x1d\n\r\
    \n\x05\x04\x0f\x02\x05\x05\x12\x04\x84\x02\x02\x06\n\r\n\x05\x04\x0f\x02\
    \x05\x01\x12\x04\x84\x02\x07\x18\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\
    \x84\x02\x1b\x1c\n\x0c\n\x04\x04\x0f\x02\x06\x12\x04\x85\x02\x02\x19\n\r\
    \n\x05\x04\x0f\x02\x06\x05\x12\x04\x85\x02\x02\x06\n\r\n\x05\x04\x0f\x02\
    \x06\x01\x12\x04\x85\x02\x07\x14\n\r\n\x05\x04\x0f\x02\x06\x03\x12\x04\
    \x85\x02\x17\x18\n\x0c\n\x04\x04\x0f\x02\x07\x12\x04\x86\x02\x02\x1a\n\r\
    \n\x05\x04\x0f\x02\x07\x05\x12\x04\x86\x02\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x07\x01\x12\x04\x86\x02\t\x15\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\x86\
    \x02\x18\x19\n\x0c\n\x04\x04\x0f\x02\x08\x12\x04\x87\x02\x02\x1f\n\r\n\
    \x05\x04\x0f\x02\x08\x05\x12\x04\x87\x02\x02\x06\n\r\n\x05\x04\x0f\x02\
    \x08\x01\x12\x04\x87\x02\x07\x1a\n\r\n\x05\x04\x0f\x02\x08\x03\x12\x04\
    \x87\x02\x1d\x1e\n\x0c\n\x04\x04\x0f\x02\t\x12\x04\x88\x02\x02\x13\n\r\n\
    \x05\x04\x0f\x02\t\x05\x12\x04\x88\x02\x02\x08\n\r\n\x05\x04\x0f\x02\t\
    \x01\x12\x04\x88\x02\t\r\n\r\n\x05\x04\x0f\x02\t\x03\x12\x04\x88\x02\x10\
    \x12\n\x0c\n\x04\x04\x0f\x02\n\x12\x04\x89\x02\x02&\n\r\n\x05\x04\x0f\
    \x02\n\x06\x12\x04\x89\x02\x02\x10\n\r\n\x05\x04\x0f\x02\n\x01\x12\x04\
    \x89\x02\x11\x20\n\r\n\x05\x04\x0f\x02\n\x03\x12\x04\x89\x02#%\n\x0c\n\
    \x02\x05\x01\x12\x06\x8c\x02\0\x8f\x02\x01\n\x0b\n\x03\x05\x01\x01\x12\
    \x04\x8c\x02\x05\x15\n\x0c\n\x04\x05\x01\x02\0\x12\x04\x8d\x02\x02\x1e\n\
    \r\n\x05\x05\x01\x02\0\x01\x12\x04\x8d\x02\x02\x19\n\r\n\x05\x05\x01\x02\
    \0\x02\x12\x04\x8d\x02\x1c\x1d\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\x8e\
    \x02\x02\x20\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\x8e\x02\x02\x1b\n\r\n\
    \x05\x05\x01\x02\x01\x02\x12\x04\x8e\x02\x1e\x1f\n\x0c\n\x02\x05\x02\x12\
    \x06\x90\x02\0\x94\x02\x01\n\x0b\n\x03\x05\x02\x01\x12\x04\x90\x02\x05\
    \x13\n\x0c\n\x04\x05\x02\x02\0\x12\x04\x91\x02\x02\x1b\n\r\n\x05\x05\x02\
    \x02\0\x01\x12\x04\x91\x02\x02\x16\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\
    \x91\x02\x19\x1a\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\x92\x02\x02!\n\r\n\
    \x05\x05\x02\x02\x01\x01\x12\x04\x92\x02\x02\x1c\n\r\n\x05\x05\x02\x02\
    \x01\x02\x12\x04\x92\x02\x1f\x20\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\x93\
    \x02\x02!\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\x93\x02\x02\x1c\n\r\n\
    \x05\x05\x02\x02\x02\x02\x12\x04\x93\x02\x1f\x20\n\x0c\n\x02\x04\x10\x12\
    \x06\x95\x02\0\xa3\x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x95\x02\x08\
    \x1a\n\x0b\n\x03\x04\x10\x07\x12\x04\x96\x02\x02\x13\n\r\n\x05\x04\x10\
    \x07\x8c\x08\x12\x04\x96\x02\x02\x13\n\x0b\n\x03\x04\x10\x07\x12\x04\x97\
    \x02\x02\"\n\r\n\x05\x04\x10\x07\x8d\x08\x12\x04\x97\x02\x02\"\n\x0b\n\
    \x03\x04\x10\x07\x12\x04\x98\x02\x02\x1f\n\r\n\x05\x04\x10\x07\x8e\x08\
    \x12\x04\x98\x02\x02\x1f\n\x0b\n\x03\x04\x10\x07\x12\x04\x99\x02\x02\x1b\
    \n\r\n\x05\x04\x10\x07\x90\x08\x12\x04\x99\x02\x02\x1b\n\x0c\n\x04\x04\
    \x10\x02\0\x12\x04\x9b\x02\x02\x12\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\
    \x9b\x02\x02\t\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x9b\x02\n\r\n\r\n\x05\
    \x04\x10\x02\0\x03\x12\x04\x9b\x02\x10\x11\n\x80\x01\n\x04\x04\x10\x02\
    \x01\x12\x04\x9e\x02\x02$\x1ar\x20legacy:\x20state\x20has\x20been\x20rem\
    oved\x20in\x201.13\n\x20clients/servers\x20must\x20still\x20send/accept\
    \x20it\x20until\x20the\x20next\x20protocol\x20change\n\n\r\n\x05\x04\x10\
    \x02\x01\x06\x12\x04\x9e\x02\x02\x12\n\r\n\x05\x04\x10\x02\x01\x01\x12\
    \x04\x9e\x02\x13\x1f\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x9e\x02\"#\n\
    \x0c\n\x04\x04\x10\x02\x02\x12\x04\xa0\x02\x02\x15\n\r\n\x05\x04\x10\x02\
    \x02\x05\x12\x04\xa0\x02\x02\x07\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\
    \xa0\x02\x08\x10\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xa0\x02\x13\x14\n\
    \x0c\n\x04\x04\x10\x02\x03\x12\x04\xa1\x02\x02\x11\n\r\n\x05\x04\x10\x02\
    \x03\x05\x12\x04\xa1\x02\x02\x07\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\
    \xa1\x02\x08\x0c\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xa1\x02\x0f\x10\n\
    \x0c\n\x04\x04\x10\x02\x04\x12\x04\xa2\x02\x02'\n\r\n\x05\x04\x10\x02\
    \x04\x06\x12\x04\xa2\x02\x02\x10\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\
    \xa2\x02\x11\"\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\xa2\x02%&\n\x0c\n\
    \x02\x05\x03\x12\x06\xa5\x02\0\xa9\x02\x01\n\x0b\n\x03\x05\x03\x01\x12\
    \x04\xa5\x02\x05\x17\n\x0c\n\x04\x05\x03\x02\0\x12\x04\xa6\x02\x02\x20\n\
    \r\n\x05\x05\x03\x02\0\x01\x12\x04\xa6\x02\x02\x1b\n\r\n\x05\x05\x03\x02\
    \0\x02\x12\x04\xa6\x02\x1e\x1f\n\x0c\n\x04\x05\x03\x02\x01\x12\x04\xa7\
    \x02\x02!\n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\xa7\x02\x02\x1c\n\r\n\
    \x05\x05\x03\x02\x01\x02\x12\x04\xa7\x02\x1f\x20\n\x0c\n\x04\x05\x03\x02\
    \x02\x12\x04\xa8\x02\x02\x20\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\xa8\
    \x02\x02\x1b\n\r\n\x05\x05\x03\x02\x02\x02\x12\x04\xa8\x02\x1e\x1f\n\x0c\
    \n\x02\x04\x11\x12\x06\xaa\x02\0\xbc\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\xaa\x02\x08\x1b\n\x0b\n\x03\x04\x11\x07\x12\x04\xab\x02\x02\x13\n\r\
    \n\x05\x04\x11\x07\x8c\x08\x12\x04\xab\x02\x02\x13\n\x0b\n\x03\x04\x11\
    \x07\x12\x04\xac\x02\x02\"\n\r\n\x05\x04\x11\x07\x8d\x08\x12\x04\xac\x02\
    \x02\"\n\x0b\n\x03\x04\x11\x07\x12\x04\xad\x02\x02\x1f\n\r\n\x05\x04\x11\
    \x07\x8e\x08\x12\x04\xad\x02\x02\x1f\n\x0b\n\x03\x04\x11\x07\x12\x04\xae\
    \x02\x02\x1b\n\r\n\x05\x04\x11\x07\x90\x08\x12\x04\xae\x02\x02\x1b\n\x0c\
    \n\x04\x04\x11\x02\0\x12\x04\xb0\x02\x02\x12\n\r\n\x05\x04\x11\x02\0\x05\
    \x12\x04\xb0\x02\x02\t\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb0\x02\n\r\n\
    \r\n\x05\x04\x11\x02\0\x03\x12\x04\xb0\x02\x10\x11\n\x82\x01\n\x04\x04\
    \x11\x02\x01\x12\x04\xb4\x02\x02\x1e\x1at\x20legacy:\x20command\x20has\
    \x20been\x20removed\x20in\x201.13\n\x20clients/servers\x20must\x20still\
    \x20send/accept\x20it\x20until\x20the\x20next\x20protocol\x20change\n\n\
    \r\n\x05\x04\x11\x02\x01\x05\x12\x04\xb4\x02\x02\x06\n\r\n\x05\x04\x11\
    \x02\x01\x01\x12\x04\xb4\x02\x07\x19\n\r\n\x05\x04\x11\x02\x01\x03\x12\
    \x04\xb4\x02\x1c\x1d\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xb5\x02\x02(\n\
    \r\n\x05\x04\x11\x02\x02\x06\x12\x04\xb5\x02\x02\x14\n\r\n\x05\x04\x11\
    \x02\x02\x01\x12\x04\xb5\x02\x15#\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\
    \xb5\x02&'\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\xb7\x02\x02\x18\n\r\n\x05\
    \x04\x11\x02\x03\x05\x12\x04\xb7\x02\x02\x06\n\r\n\x05\x04\x11\x02\x03\
    \x01\x12\x04\xb7\x02\x07\x13\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xb7\
    \x02\x16\x17\n\x0c\n\x04\x04\x11\x02\x04\x12\x04\xb8\x02\x02\x15\n\r\n\
    \x05\x04\x11\x02\x04\x05\x12\x04\xb8\x02\x02\x07\n\r\n\x05\x04\x11\x02\
    \x04\x01\x12\x04\xb8\x02\x08\x10\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\
    \xb8\x02\x13\x14\n\x0c\n\x04\x04\x11\x02\x05\x12\x04\xb9\x02\x02\x14\n\r\
    \n\x05\x04\x11\x02\x05\x05\x12\x04\xb9\x02\x02\x06\n\r\n\x05\x04\x11\x02\
    \x05\x01\x12\x04\xb9\x02\x07\x0f\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\
    \xb9\x02\x12\x13\n\x0c\n\x04\x04\x11\x02\x06\x12\x04\xba\x02\x02\x11\n\r\
    \n\x05\x04\x11\x02\x06\x05\x12\x04\xba\x02\x02\x07\n\r\n\x05\x04\x11\x02\
    \x06\x01\x12\x04\xba\x02\x08\x0c\n\r\n\x05\x04\x11\x02\x06\x03\x12\x04\
    \xba\x02\x0f\x10\n\x0c\n\x04\x04\x11\x02\x07\x12\x04\xbb\x02\x02\x10\n\r\
    \n\x05\x04\x11\x02\x07\x05\x12\x04\xbb\x02\x02\x06\n\r\n\x05\x04\x11\x02\
    \x07\x01\x12\x04\xbb\x02\x07\x0b\n\r\n\x05\x04\x11\x02\x07\x03\x12\x04\
    \xbb\x02\x0e\x0f\n=\n\x02\x04\x12\x12\x06\xbf\x02\0\xd0\x02\x01\x1a/\x20\
    ====================\x20FAN\x20====================\n\n\x0b\n\x03\x04\
    \x12\x01\x12\x04\xbf\x02\x08\x1f\n\x0b\n\x03\x04\x12\x07\x12\x04\xc0\x02\
    \x02\x13\n\r\n\x05\x04\x12\x07\x8c\x08\x12\x04\xc0\x02\x02\x13\n\x0b\n\
    \x03\x04\x12\x07\x12\x04\xc1\x02\x02\"\n\r\n\x05\x04\x12\x07\x8d\x08\x12\
    \x04\xc1\x02\x02\"\n\x0b\n\x03\x04\x12\x07\x12\x04\xc2\x02\x02\x1d\n\r\n\
    \x05\x04\x12\x07\x8e\x08\x12\x04\xc2\x02\x02\x1d\n\x0c\n\x04\x04\x12\x02\
    \0\x12\x04\xc4\x02\x02\x17\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xc4\x02\
    \x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xc4\x02\t\x12\n\r\n\x05\x04\
    \x12\x02\0\x03\x12\x04\xc4\x02\x15\x16\n\x0c\n\x04\x04\x12\x02\x01\x12\
    \x04\xc5\x02\x02\x12\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xc5\x02\x02\t\
    \n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xc5\x02\n\r\n\r\n\x05\x04\x12\x02\
    \x01\x03\x12\x04\xc5\x02\x10\x11\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xc6\
    \x02\x02\x12\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xc6\x02\x02\x08\n\r\n\
    \x05\x04\x12\x02\x02\x01\x12\x04\xc6\x02\t\r\n\r\n\x05\x04\x12\x02\x02\
    \x03\x12\x04\xc6\x02\x10\x11\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xc7\x02\
    \x02\x17\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\xc7\x02\x02\x08\n\r\n\x05\
    \x04\x12\x02\x03\x01\x12\x04\xc7\x02\t\x12\n\r\n\x05\x04\x12\x02\x03\x03\
    \x12\x04\xc7\x02\x15\x16\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\xc9\x02\x02\
    \x20\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xc9\x02\x02\x06\n\r\n\x05\x04\
    \x12\x02\x04\x01\x12\x04\xc9\x02\x07\x1b\n\r\n\x05\x04\x12\x02\x04\x03\
    \x12\x04\xc9\x02\x1e\x1f\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\xca\x02\x02\
    \x1a\n\r\n\x05\x04\x12\x02\x05\x05\x12\x04\xca\x02\x02\x06\n\r\n\x05\x04\
    \x12\x02\x05\x01\x12\x04\xca\x02\x07\x15\n\r\n\x05\x04\x12\x02\x05\x03\
    \x12\x04\xca\x02\x18\x19\n\x0c\n\x04\x04\x12\x02\x06\x12\x04\xcb\x02\x02\
    \x1e\n\r\n\x05\x04\x12\x02\x06\x05\x12\x04\xcb\x02\x02\x06\n\r\n\x05\x04\
    \x12\x02\x06\x01\x12\x04\xcb\x02\x07\x19\n\r\n\x05\x04\x12\x02\x06\x03\
    \x12\x04\xcb\x02\x1c\x1d\n\x0c\n\x04\x04\x12\x02\x07\x12\x04\xcc\x02\x02\
    \"\n\r\n\x05\x04\x12\x02\x07\x05\x12\x04\xcc\x02\x02\x07\n\r\n\x05\x04\
    \x12\x02\x07\x01\x12\x04\xcc\x02\x08\x1d\n\r\n\x05\x04\x12\x02\x07\x03\
    \x12\x04\xcc\x02\x20!\n\x0c\n\x04\x04\x12\x02\x08\x12\x04\xcd\x02\x02\
    \x1f\n\r\n\x05\x04\x12\x02\x08\x05\x12\x04\xcd\x02\x02\x06\n\r\n\x05\x04\
    \x12\x02\x08\x01\x12\x04\xcd\x02\x07\x1a\n\r\n\x05\x04\x12\x02\x08\x03\
    \x12\x04\xcd\x02\x1d\x1e\n\x0c\n\x04\x04\x12\x02\t\x12\x04\xce\x02\x02\
    \x13\n\r\n\x05\x04\x12\x02\t\x05\x12\x04\xce\x02\x02\x08\n\r\n\x05\x04\
    \x12\x02\t\x01\x12\x04\xce\x02\t\r\n\r\n\x05\x04\x12\x02\t\x03\x12\x04\
    \xce\x02\x10\x12\n\x0c\n\x04\x04\x12\x02\n\x12\x04\xcf\x02\x02&\n\r\n\
    \x05\x04\x12\x02\n\x06\x12\x04\xcf\x02\x02\x10\n\r\n\x05\x04\x12\x02\n\
    \x01\x12\x04\xcf\x02\x11\x20\n\r\n\x05\x04\x12\x02\n\x03\x12\x04\xcf\x02\
    #%\n\x0c\n\x02\x05\x04\x12\x06\xd1\x02\0\xd5\x02\x01\n\x0b\n\x03\x05\x04\
    \x01\x12\x04\xd1\x02\x05\r\n\x0c\n\x04\x05\x04\x02\0\x12\x04\xd2\x02\x02\
    \x14\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xd2\x02\x02\x0f\n\r\n\x05\x05\
    \x04\x02\0\x02\x12\x04\xd2\x02\x12\x13\n\x0c\n\x04\x05\x04\x02\x01\x12\
    \x04\xd3\x02\x02\x17\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\xd3\x02\x02\
    \x12\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\xd3\x02\x15\x16\n\x0c\n\x04\
    \x05\x04\x02\x02\x12\x04\xd4\x02\x02\x15\n\r\n\x05\x05\x04\x02\x02\x01\
    \x12\x04\xd4\x02\x02\x10\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\xd4\x02\
    \x13\x14\n\x0c\n\x02\x05\x05\x12\x06\xd6\x02\0\xd9\x02\x01\n\x0b\n\x03\
    \x05\x05\x01\x12\x04\xd6\x02\x05\x11\n\x0c\n\x04\x05\x05\x02\0\x12\x04\
    \xd7\x02\x02\x1c\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xd7\x02\x02\x17\n\r\
    \n\x05\x05\x05\x02\0\x02\x12\x04\xd7\x02\x1a\x1b\n\x0c\n\x04\x05\x05\x02\
    \x01\x12\x04\xd8\x02\x02\x1c\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xd8\
    \x02\x02\x17\n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\xd8\x02\x1a\x1b\n\x0c\
    \n\x02\x04\x13\x12\x06\xda\x02\0\xe6\x02\x01\n\x0b\n\x03\x04\x13\x01\x12\
    \x04\xda\x02\x08\x18\n\x0b\n\x03\x04\x13\x07\x12\x04\xdb\x02\x02\x13\n\r\
    \n\x05\x04\x13\x07\x8c\x08\x12\x04\xdb\x02\x02\x13\n\x0b\n\x03\x04\x13\
    \x07\x12\x04\xdc\x02\x02\"\n\r\n\x05\x04\x13\x07\x8d\x08\x12\x04\xdc\x02\
    \x02\"\n\x0b\n\x03\x04\x13\x07\x12\x04\xdd\x02\x02\x1d\n\r\n\x05\x04\x13\
    \x07\x8e\x08\x12\x04\xdd\x02\x02\x1d\n\x0b\n\x03\x04\x13\x07\x12\x04\xde\
    \x02\x02\x1b\n\r\n\x05\x04\x13\x07\x90\x08\x12\x04\xde\x02\x02\x1b\n\x0c\
    \n\x04\x04\x13\x02\0\x12\x04\xe0\x02\x02\x12\n\r\n\x05\x04\x13\x02\0\x05\
    \x12\x04\xe0\x02\x02\t\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xe0\x02\n\r\n\
    \r\n\x05\x04\x13\x02\0\x03\x12\x04\xe0\x02\x10\x11\n\x0c\n\x04\x04\x13\
    \x02\x01\x12\x04\xe1\x02\x02\x11\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\
    \xe1\x02\x02\x06\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xe1\x02\x07\x0c\n\
    \r\n\x05\x04\x13\x02\x01\x03\x12\x04\xe1\x02\x0f\x10\n\x0c\n\x04\x04\x13\
    \x02\x02\x12\x04\xe2\x02\x02\x17\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\
    \xe2\x02\x02\x06\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xe2\x02\x07\x12\n\
    \r\n\x05\x04\x13\x02\x02\x03\x12\x04\xe2\x02\x15\x16\n\x0c\n\x04\x04\x13\
    \x02\x03\x12\x04\xe3\x02\x02)\n\r\n\x05\x04\x13\x02\x03\x06\x12\x04\xe3\
    \x02\x02\n\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xe3\x02\x0b\x10\n\r\n\
    \x05\x04\x13\x02\x03\x03\x12\x04\xe3\x02\x13\x14\n\r\n\x05\x04\x13\x02\
    \x03\x08\x12\x04\xe3\x02\x15(\n\x0e\n\x06\x04\x13\x02\x03\x08\x03\x12\
    \x04\xe3\x02\x16'\n\x0c\n\x04\x04\x13\x02\x04\x12\x04\xe4\x02\x02\x1d\n\
    \r\n\x05\x04\x13\x02\x04\x06\x12\x04\xe4\x02\x02\x0e\n\r\n\x05\x04\x13\
    \x02\x04\x01\x12\x04\xe4\x02\x0f\x18\n\r\n\x05\x04\x13\x02\x04\x03\x12\
    \x04\xe4\x02\x1b\x1c\n\x0c\n\x04\x04\x13\x02\x05\x12\x04\xe5\x02\x02\x18\
    \n\r\n\x05\x04\x13\x02\x05\x05\x12\x04\xe5\x02\x02\x07\n\r\n\x05\x04\x13\
    \x02\x05\x01\x12\x04\xe5\x02\x08\x13\n\r\n\x05\x04\x13\x02\x05\x03\x12\
    \x04\xe5\x02\x16\x17\n\x0c\n\x02\x04\x14\x12\x06\xe7\x02\0\xf8\x02\x01\n\
    \x0b\n\x03\x04\x14\x01\x12\x04\xe7\x02\x08\x19\n\x0b\n\x03\x04\x14\x07\
    \x12\x04\xe8\x02\x02\x13\n\r\n\x05\x04\x14\x07\x8c\x08\x12\x04\xe8\x02\
    \x02\x13\n\x0b\n\x03\x04\x14\x07\x12\x04\xe9\x02\x02\"\n\r\n\x05\x04\x14\
    \x07\x8d\x08\x12\x04\xe9\x02\x02\"\n\x0b\n\x03\x04\x14\x07\x12\x04\xea\
    \x02\x02\x1d\n\r\n\x05\x04\x14\x07\x8e\x08\x12\x04\xea\x02\x02\x1d\n\x0b\
    \n\x03\x04\x14\x07\x12\x04\xeb\x02\x02\x1b\n\r\n\x05\x04\x14\x07\x90\x08\
    \x12\x04\xeb\x02\x02\x1b\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xed\x02\x02\
    \x12\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xed\x02\x02\t\n\r\n\x05\x04\x14\
    \x02\0\x01\x12\x04\xed\x02\n\r\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xed\
    \x02\x10\x11\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xee\x02\x02\x15\n\r\n\
    \x05\x04\x14\x02\x01\x05\x12\x04\xee\x02\x02\x06\n\r\n\x05\x04\x14\x02\
    \x01\x01\x12\x04\xee\x02\x07\x10\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\
    \xee\x02\x13\x14\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xef\x02\x02\x11\n\r\
    \n\x05\x04\x14\x02\x02\x05\x12\x04\xef\x02\x02\x06\n\r\n\x05\x04\x14\x02\
    \x02\x01\x12\x04\xef\x02\x07\x0c\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\
    \xef\x02\x0f\x10\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xf0\x02\x02)\n\r\n\
    \x05\x04\x14\x02\x03\x05\x12\x04\xf0\x02\x02\x06\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\xf0\x02\x07\x10\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\
    \xf0\x02\x13\x14\n\r\n\x05\x04\x14\x02\x03\x08\x12\x04\xf0\x02\x15(\n\
    \x0e\n\x06\x04\x14\x02\x03\x08\x03\x12\x04\xf0\x02\x16'\n\x0c\n\x04\x04\
    \x14\x02\x04\x12\x04\xf1\x02\x02)\n\r\n\x05\x04\x14\x02\x04\x06\x12\x04\
    \xf1\x02\x02\n\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xf1\x02\x0b\x10\n\r\
    \n\x05\x04\x14\x02\x04\x03\x12\x04\xf1\x02\x13\x14\n\r\n\x05\x04\x14\x02\
    \x04\x08\x12\x04\xf1\x02\x15(\n\x0e\n\x06\x04\x14\x02\x04\x08\x03\x12\
    \x04\xf1\x02\x16'\n\x0c\n\x04\x04\x14\x02\x05\x12\x04\xf2\x02\x02\x1b\n\
    \r\n\x05\x04\x14\x02\x05\x05\x12\x04\xf2\x02\x02\x06\n\r\n\x05\x04\x14\
    \x02\x05\x01\x12\x04\xf2\x02\x07\x16\n\r\n\x05\x04\x14\x02\x05\x03\x12\
    \x04\xf2\x02\x19\x1a\n\x0c\n\x04\x04\x14\x02\x06\x12\x04\xf3\x02\x02\x17\
    \n\r\n\x05\x04\x14\x02\x06\x05\x12\x04\xf3\x02\x02\x06\n\r\n\x05\x04\x14\
    \x02\x06\x01\x12\x04\xf3\x02\x07\x12\n\r\n\x05\x04\x14\x02\x06\x03\x12\
    \x04\xf3\x02\x15\x16\n\x0c\n\x04\x04\x14\x02\x07\x12\x04\xf4\x02\x02\x19\
    \n\r\n\x05\x04\x14\x02\x07\x05\x12\x04\xf4\x02\x02\x06\n\r\n\x05\x04\x14\
    \x02\x07\x01\x12\x04\xf4\x02\x07\x14\n\r\n\x05\x04\x14\x02\x07\x03\x12\
    \x04\xf4\x02\x17\x18\n\x0c\n\x04\x04\x14\x02\x08\x12\x04\xf5\x02\x02\x1d\
    \n\r\n\x05\x04\x14\x02\x08\x06\x12\x04\xf5\x02\x02\x0e\n\r\n\x05\x04\x14\
    \x02\x08\x01\x12\x04\xf5\x02\x0f\x18\n\r\n\x05\x04\x14\x02\x08\x03\x12\
    \x04\xf5\x02\x1b\x1c\n\x0c\n\x04\x04\x14\x02\t\x12\x04\xf6\x02\x02\x1c\n\
    \r\n\x05\x04\x14\x02\t\x05\x12\x04\xf6\x02\x02\x06\n\r\n\x05\x04\x14\x02\
    \t\x01\x12\x04\xf6\x02\x07\x16\n\r\n\x05\x04\x14\x02\t\x03\x12\x04\xf6\
    \x02\x19\x1b\n\x0c\n\x04\x04\x14\x02\n\x12\x04\xf7\x02\x02\x19\n\r\n\x05\
    \x04\x14\x02\n\x05\x12\x04\xf7\x02\x02\x07\n\r\n\x05\x04\x14\x02\n\x01\
    \x12\x04\xf7\x02\x08\x13\n\r\n\x05\x04\x14\x02\n\x03\x12\x04\xf7\x02\x16\
    \x18\n?\n\x02\x05\x06\x12\x06\xfb\x02\0\x86\x03\x01\x1a1\x20============\
    ========\x20LIGHT\x20====================\n\n\x0b\n\x03\x05\x06\x01\x12\
    \x04\xfb\x02\x05\x0e\n\x0c\n\x04\x05\x06\x02\0\x12\x04\xfc\x02\x02\x19\n\
    \r\n\x05\x05\x06\x02\0\x01\x12\x04\xfc\x02\x02\x14\n\r\n\x05\x05\x06\x02\
    \0\x02\x12\x04\xfc\x02\x17\x18\n\x0c\n\x04\x05\x06\x02\x01\x12\x04\xfd\
    \x02\x02\x18\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\xfd\x02\x02\x13\n\r\n\
    \x05\x05\x06\x02\x01\x02\x12\x04\xfd\x02\x16\x17\n\x0c\n\x04\x05\x06\x02\
    \x02\x12\x04\xfe\x02\x02\x1c\n\r\n\x05\x05\x06\x02\x02\x01\x12\x04\xfe\
    \x02\x02\x17\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\xfe\x02\x1a\x1b\n\x0c\
    \n\x04\x05\x06\x02\x03\x12\x04\xff\x02\x02\x17\n\r\n\x05\x05\x06\x02\x03\
    \x01\x12\x04\xff\x02\x02\x12\n\r\n\x05\x05\x06\x02\x03\x02\x12\x04\xff\
    \x02\x15\x16\n\x0c\n\x04\x05\x06\x02\x04\x12\x04\x80\x03\x02$\n\r\n\x05\
    \x05\x06\x02\x04\x01\x12\x04\x80\x03\x02\x1e\n\r\n\x05\x05\x06\x02\x04\
    \x02\x12\x04\x80\x03!#\n\x0c\n\x04\x05\x06\x02\x05\x12\x04\x81\x03\x02\"\
    \n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\x81\x03\x02\x1c\n\r\n\x05\x05\x06\
    \x02\x05\x02\x12\x04\x81\x03\x1f!\n\x0c\n\x04\x05\x06\x02\x06\x12\x04\
    \x82\x03\x02\x16\n\r\n\x05\x05\x06\x02\x06\x01\x12\x04\x82\x03\x02\x10\n\
    \r\n\x05\x05\x06\x02\x06\x02\x12\x04\x82\x03\x13\x15\n\x0c\n\x04\x05\x06\
    \x02\x07\x12\x04\x83\x03\x02\x1c\n\r\n\x05\x05\x06\x02\x07\x01\x12\x04\
    \x83\x03\x02\x16\n\r\n\x05\x05\x06\x02\x07\x02\x12\x04\x83\x03\x19\x1b\n\
    \x0c\n\x04\x05\x06\x02\x08\x12\x04\x84\x03\x02(\n\r\n\x05\x05\x06\x02\
    \x08\x01\x12\x04\x84\x03\x02\"\n\r\n\x05\x05\x06\x02\x08\x02\x12\x04\x84\
    \x03%'\n\x0c\n\x04\x05\x06\x02\t\x12\x04\x85\x03\x02&\n\r\n\x05\x05\x06\
    \x02\t\x01\x12\x04\x85\x03\x02\x20\n\r\n\x05\x05\x06\x02\t\x02\x12\x04\
    \x85\x03#%\n\x0c\n\x02\x04\x15\x12\x06\x87\x03\0\x9d\x03\x01\n\x0b\n\x03\
    \x04\x15\x01\x12\x04\x87\x03\x08!\n\x0b\n\x03\x04\x15\x07\x12\x04\x88\
    \x03\x02\x13\n\r\n\x05\x04\x15\x07\x8c\x08\x12\x04\x88\x03\x02\x13\n\x0b\
    \n\x03\x04\x15\x07\x12\x04\x89\x03\x02\"\n\r\n\x05\x04\x15\x07\x8d\x08\
    \x12\x04\x89\x03\x02\"\n\x0b\n\x03\x04\x15\x07\x12\x04\x8a\x03\x02\x1f\n\
    \r\n\x05\x04\x15\x07\x8e\x08\x12\x04\x8a\x03\x02\x1f\n\x0c\n\x04\x04\x15\
    \x02\0\x12\x04\x8c\x03\x02\x17\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x8c\
    \x03\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x8c\x03\t\x12\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\x8c\x03\x15\x16\n\x0c\n\x04\x04\x15\x02\x01\
    \x12\x04\x8d\x03\x02\x12\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x8d\x03\
    \x02\t\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x8d\x03\n\r\n\r\n\x05\x04\
    \x15\x02\x01\x03\x12\x04\x8d\x03\x10\x11\n\x0c\n\x04\x04\x15\x02\x02\x12\
    \x04\x8e\x03\x02\x12\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\x8e\x03\x02\
    \x08\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x8e\x03\t\r\n\r\n\x05\x04\x15\
    \x02\x02\x03\x12\x04\x8e\x03\x10\x11\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\
    \x8f\x03\x02\x17\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\x8f\x03\x02\x08\n\
    \r\n\x05\x04\x15\x02\x03\x01\x12\x04\x8f\x03\t\x12\n\r\n\x05\x04\x15\x02\
    \x03\x03\x12\x04\x8f\x03\x15\x16\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\x91\
    \x03\x020\n\r\n\x05\x04\x15\x02\x04\x04\x12\x04\x91\x03\x02\n\n\r\n\x05\
    \x04\x15\x02\x04\x06\x12\x04\x91\x03\x0b\x14\n\r\n\x05\x04\x15\x02\x04\
    \x01\x12\x04\x91\x03\x15*\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\x91\x03-\
    /\na\n\x04\x04\x15\x02\x05\x12\x04\x93\x03\x028\x1aS\x20next\x20four\x20\
    supports_*\x20are\x20for\x20legacy\x20clients,\x20newer\x20clients\x20sh\
    ould\x20use\x20color\x20modes\n\n\r\n\x05\x04\x15\x02\x05\x05\x12\x04\
    \x93\x03\x02\x06\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\x93\x03\x07!\n\r\
    \n\x05\x04\x15\x02\x05\x03\x12\x04\x93\x03$%\n\r\n\x05\x04\x15\x02\x05\
    \x08\x12\x04\x93\x03&7\n\x0e\n\x06\x04\x15\x02\x05\x08\x03\x12\x04\x93\
    \x03'6\n\x0c\n\x04\x04\x15\x02\x06\x12\x04\x94\x03\x021\n\r\n\x05\x04\
    \x15\x02\x06\x05\x12\x04\x94\x03\x02\x06\n\r\n\x05\x04\x15\x02\x06\x01\
    \x12\x04\x94\x03\x07\x1a\n\r\n\x05\x04\x15\x02\x06\x03\x12\x04\x94\x03\
    \x1d\x1e\n\r\n\x05\x04\x15\x02\x06\x08\x12\x04\x94\x03\x1f0\n\x0e\n\x06\
    \x04\x15\x02\x06\x08\x03\x12\x04\x94\x03\x20/\n\x0c\n\x04\x04\x15\x02\
    \x07\x12\x04\x95\x03\x029\n\r\n\x05\x04\x15\x02\x07\x05\x12\x04\x95\x03\
    \x02\x06\n\r\n\x05\x04\x15\x02\x07\x01\x12\x04\x95\x03\x07\"\n\r\n\x05\
    \x04\x15\x02\x07\x03\x12\x04\x95\x03%&\n\r\n\x05\x04\x15\x02\x07\x08\x12\
    \x04\x95\x03'8\n\x0e\n\x06\x04\x15\x02\x07\x08\x03\x12\x04\x95\x03(7\n\
    \x0c\n\x04\x04\x15\x02\x08\x12\x04\x96\x03\x02?\n\r\n\x05\x04\x15\x02\
    \x08\x05\x12\x04\x96\x03\x02\x06\n\r\n\x05\x04\x15\x02\x08\x01\x12\x04\
    \x96\x03\x07(\n\r\n\x05\x04\x15\x02\x08\x03\x12\x04\x96\x03+,\n\r\n\x05\
    \x04\x15\x02\x08\x08\x12\x04\x96\x03->\n\x0e\n\x06\x04\x15\x02\x08\x08\
    \x03\x12\x04\x96\x03.=\n\x0c\n\x04\x04\x15\x02\t\x12\x04\x97\x03\x02\x17\
    \n\r\n\x05\x04\x15\x02\t\x05\x12\x04\x97\x03\x02\x07\n\r\n\x05\x04\x15\
    \x02\t\x01\x12\x04\x97\x03\x08\x12\n\r\n\x05\x04\x15\x02\t\x03\x12\x04\
    \x97\x03\x15\x16\n\x0c\n\x04\x04\x15\x02\n\x12\x04\x98\x03\x02\x18\n\r\n\
    \x05\x04\x15\x02\n\x05\x12\x04\x98\x03\x02\x07\n\r\n\x05\x04\x15\x02\n\
    \x01\x12\x04\x98\x03\x08\x12\n\r\n\x05\x04\x15\x02\n\x03\x12\x04\x98\x03\
    \x15\x17\n\x0c\n\x04\x04\x15\x02\x0b\x12\x04\x99\x03\x02\x1f\n\r\n\x05\
    \x04\x15\x02\x0b\x04\x12\x04\x99\x03\x02\n\n\r\n\x05\x04\x15\x02\x0b\x05\
    \x12\x04\x99\x03\x0b\x11\n\r\n\x05\x04\x15\x02\x0b\x01\x12\x04\x99\x03\
    \x12\x19\n\r\n\x05\x04\x15\x02\x0b\x03\x12\x04\x99\x03\x1c\x1e\n\x0c\n\
    \x04\x04\x15\x02\x0c\x12\x04\x9a\x03\x02\x20\n\r\n\x05\x04\x15\x02\x0c\
    \x05\x12\x04\x9a\x03\x02\x06\n\r\n\x05\x04\x15\x02\x0c\x01\x12\x04\x9a\
    \x03\x07\x1a\n\r\n\x05\x04\x15\x02\x0c\x03\x12\x04\x9a\x03\x1d\x1f\n\x0c\
    \n\x04\x04\x15\x02\r\x12\x04\x9b\x03\x02\x13\n\r\n\x05\x04\x15\x02\r\x05\
    \x12\x04\x9b\x03\x02\x08\n\r\n\x05\x04\x15\x02\r\x01\x12\x04\x9b\x03\t\r\
    \n\r\n\x05\x04\x15\x02\r\x03\x12\x04\x9b\x03\x10\x12\n\x0c\n\x04\x04\x15\
    \x02\x0e\x12\x04\x9c\x03\x02&\n\r\n\x05\x04\x15\x02\x0e\x06\x12\x04\x9c\
    \x03\x02\x10\n\r\n\x05\x04\x15\x02\x0e\x01\x12\x04\x9c\x03\x11\x20\n\r\n\
    \x05\x04\x15\x02\x0e\x03\x12\x04\x9c\x03#%\n\x0c\n\x02\x04\x16\x12\x06\
    \x9e\x03\0\xb1\x03\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\x9e\x03\x08\x1a\n\
    \x0b\n\x03\x04\x16\x07\x12\x04\x9f\x03\x02\x13\n\r\n\x05\x04\x16\x07\x8c\
    \x08\x12\x04\x9f\x03\x02\x13\n\x0b\n\x03\x04\x16\x07\x12\x04\xa0\x03\x02\
    \"\n\r\n\x05\x04\x16\x07\x8d\x08\x12\x04\xa0\x03\x02\"\n\x0b\n\x03\x04\
    \x16\x07\x12\x04\xa1\x03\x02\x1f\n\r\n\x05\x04\x16\x07\x8e\x08\x12\x04\
    \xa1\x03\x02\x1f\n\x0b\n\x03\x04\x16\x07\x12\x04\xa2\x03\x02\x1b\n\r\n\
    \x05\x04\x16\x07\x90\x08\x12\x04\xa2\x03\x02\x1b\n\x0c\n\x04\x04\x16\x02\
    \0\x12\x04\xa4\x03\x02\x12\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xa4\x03\
    \x02\t\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xa4\x03\n\r\n\r\n\x05\x04\x16\
    \x02\0\x03\x12\x04\xa4\x03\x10\x11\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\
    \xa5\x03\x02\x11\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xa5\x03\x02\x06\n\
    \r\n\x05\x04\x16\x02\x01\x01\x12\x04\xa5\x03\x07\x0c\n\r\n\x05\x04\x16\
    \x02\x01\x03\x12\x04\xa5\x03\x0f\x10\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\
    \xa6\x03\x02\x17\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xa6\x03\x02\x07\n\
    \r\n\x05\x04\x16\x02\x02\x01\x12\x04\xa6\x03\x08\x12\n\r\n\x05\x04\x16\
    \x02\x02\x03\x12\x04\xa6\x03\x15\x16\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\
    \xa7\x03\x02\x1c\n\r\n\x05\x04\x16\x02\x03\x06\x12\x04\xa7\x03\x02\x0b\n\
    \r\n\x05\x04\x16\x02\x03\x01\x12\x04\xa7\x03\x0c\x16\n\r\n\x05\x04\x16\
    \x02\x03\x03\x12\x04\xa7\x03\x19\x1b\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\
    \xa8\x03\x02\x1e\n\r\n\x05\x04\x16\x02\x04\x05\x12\x04\xa8\x03\x02\x07\n\
    \r\n\x05\x04\x16\x02\x04\x01\x12\x04\xa8\x03\x08\x18\n\r\n\x05\x04\x16\
    \x02\x04\x03\x12\x04\xa8\x03\x1b\x1d\n\x0c\n\x04\x04\x16\x02\x05\x12\x04\
    \xa9\x03\x02\x10\n\r\n\x05\x04\x16\x02\x05\x05\x12\x04\xa9\x03\x02\x07\n\
    \r\n\x05\x04\x16\x02\x05\x01\x12\x04\xa9\x03\x08\x0b\n\r\n\x05\x04\x16\
    \x02\x05\x03\x12\x04\xa9\x03\x0e\x0f\n\x0c\n\x04\x04\x16\x02\x06\x12\x04\
    \xaa\x03\x02\x12\n\r\n\x05\x04\x16\x02\x06\x05\x12\x04\xaa\x03\x02\x07\n\
    \r\n\x05\x04\x16\x02\x06\x01\x12\x04\xaa\x03\x08\r\n\r\n\x05\x04\x16\x02\
    \x06\x03\x12\x04\xaa\x03\x10\x11\n\x0c\n\x04\x04\x16\x02\x07\x12\x04\xab\
    \x03\x02\x11\n\r\n\x05\x04\x16\x02\x07\x05\x12\x04\xab\x03\x02\x07\n\r\n\
    \x05\x04\x16\x02\x07\x01\x12\x04\xab\x03\x08\x0c\n\r\n\x05\x04\x16\x02\
    \x07\x03\x12\x04\xab\x03\x0f\x10\n\x0c\n\x04\x04\x16\x02\x08\x12\x04\xac\
    \x03\x02\x12\n\r\n\x05\x04\x16\x02\x08\x05\x12\x04\xac\x03\x02\x07\n\r\n\
    \x05\x04\x16\x02\x08\x01\x12\x04\xac\x03\x08\r\n\r\n\x05\x04\x16\x02\x08\
    \x03\x12\x04\xac\x03\x10\x11\n\x0c\n\x04\x04\x16\x02\t\x12\x04\xad\x03\
    \x02\x1e\n\r\n\x05\x04\x16\x02\t\x05\x12\x04\xad\x03\x02\x07\n\r\n\x05\
    \x04\x16\x02\t\x01\x12\x04\xad\x03\x08\x19\n\r\n\x05\x04\x16\x02\t\x03\
    \x12\x04\xad\x03\x1c\x1d\n\x0c\n\x04\x04\x16\x02\n\x12\x04\xae\x03\x02\
    \x18\n\r\n\x05\x04\x16\x02\n\x05\x12\x04\xae\x03\x02\x07\n\r\n\x05\x04\
    \x16\x02\n\x01\x12\x04\xae\x03\x08\x12\n\r\n\x05\x04\x16\x02\n\x03\x12\
    \x04\xae\x03\x15\x17\n\x0c\n\x04\x04\x16\x02\x0b\x12\x04\xaf\x03\x02\x18\
    \n\r\n\x05\x04\x16\x02\x0b\x05\x12\x04\xaf\x03\x02\x07\n\r\n\x05\x04\x16\
    \x02\x0b\x01\x12\x04\xaf\x03\x08\x12\n\r\n\x05\x04\x16\x02\x0b\x03\x12\
    \x04\xaf\x03\x15\x17\n\x0c\n\x04\x04\x16\x02\x0c\x12\x04\xb0\x03\x02\x14\
    \n\r\n\x05\x04\x16\x02\x0c\x05\x12\x04\xb0\x03\x02\x08\n\r\n\x05\x04\x16\
    \x02\x0c\x01\x12\x04\xb0\x03\t\x0f\n\r\n\x05\x04\x16\x02\x0c\x03\x12\x04\
    \xb0\x03\x12\x13\n\x0c\n\x02\x04\x17\x12\x06\xb2\x03\0\xd3\x03\x01\n\x0b\
    \n\x03\x04\x17\x01\x12\x04\xb2\x03\x08\x1b\n\x0b\n\x03\x04\x17\x07\x12\
    \x04\xb3\x03\x02\x13\n\r\n\x05\x04\x17\x07\x8c\x08\x12\x04\xb3\x03\x02\
    \x13\n\x0b\n\x03\x04\x17\x07\x12\x04\xb4\x03\x02\"\n\r\n\x05\x04\x17\x07\
    \x8d\x08\x12\x04\xb4\x03\x02\"\n\x0b\n\x03\x04\x17\x07\x12\x04\xb5\x03\
    \x02\x1f\n\r\n\x05\x04\x17\x07\x8e\x08\x12\x04\xb5\x03\x02\x1f\n\x0b\n\
    \x03\x04\x17\x07\x12\x04\xb6\x03\x02\x1b\n\r\n\x05\x04\x17\x07\x90\x08\
    \x12\x04\xb6\x03\x02\x1b\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xb8\x03\x02\
    \x12\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xb8\x03\x02\t\n\r\n\x05\x04\x17\
    \x02\0\x01\x12\x04\xb8\x03\n\r\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xb8\
    \x03\x10\x11\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xb9\x03\x02\x15\n\r\n\
    \x05\x04\x17\x02\x01\x05\x12\x04\xb9\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\xb9\x03\x07\x10\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \xb9\x03\x13\x14\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xba\x03\x02\x11\n\r\
    \n\x05\x04\x17\x02\x02\x05\x12\x04\xba\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x02\x01\x12\x04\xba\x03\x07\x0c\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\
    \xba\x03\x0f\x10\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\xbb\x03\x02\x1a\n\r\
    \n\x05\x04\x17\x02\x03\x05\x12\x04\xbb\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x03\x01\x12\x04\xbb\x03\x07\x15\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\
    \xbb\x03\x18\x19\n\x0c\n\x04\x04\x17\x02\x04\x12\x04\xbc\x03\x02\x17\n\r\
    \n\x05\x04\x17\x02\x04\x05\x12\x04\xbc\x03\x02\x07\n\r\n\x05\x04\x17\x02\
    \x04\x01\x12\x04\xbc\x03\x08\x12\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\
    \xbc\x03\x15\x16\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xbd\x03\x02\x1b\n\r\
    \n\x05\x04\x17\x02\x05\x05\x12\x04\xbd\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x05\x01\x12\x04\xbd\x03\x07\x15\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\
    \xbd\x03\x18\x1a\n\x0c\n\x04\x04\x17\x02\x06\x12\x04\xbe\x03\x02\x1c\n\r\
    \n\x05\x04\x17\x02\x06\x06\x12\x04\xbe\x03\x02\x0b\n\r\n\x05\x04\x17\x02\
    \x06\x01\x12\x04\xbe\x03\x0c\x16\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\
    \xbe\x03\x19\x1b\n\x0c\n\x04\x04\x17\x02\x07\x12\x04\xbf\x03\x02!\n\r\n\
    \x05\x04\x17\x02\x07\x05\x12\x04\xbf\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x07\x01\x12\x04\xbf\x03\x07\x1b\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\
    \xbf\x03\x1e\x20\n\x0c\n\x04\x04\x17\x02\x08\x12\x04\xc0\x03\x02\x1e\n\r\
    \n\x05\x04\x17\x02\x08\x05\x12\x04\xc0\x03\x02\x07\n\r\n\x05\x04\x17\x02\
    \x08\x01\x12\x04\xc0\x03\x08\x18\n\r\n\x05\x04\x17\x02\x08\x03\x12\x04\
    \xc0\x03\x1b\x1d\n\x0c\n\x04\x04\x17\x02\t\x12\x04\xc1\x03\x02\x13\n\r\n\
    \x05\x04\x17\x02\t\x05\x12\x04\xc1\x03\x02\x06\n\r\n\x05\x04\x17\x02\t\
    \x01\x12\x04\xc1\x03\x07\x0e\n\r\n\x05\x04\x17\x02\t\x03\x12\x04\xc1\x03\
    \x11\x12\n\x0c\n\x04\x04\x17\x02\n\x12\x04\xc2\x03\x02\x10\n\r\n\x05\x04\
    \x17\x02\n\x05\x12\x04\xc2\x03\x02\x07\n\r\n\x05\x04\x17\x02\n\x01\x12\
    \x04\xc2\x03\x08\x0b\n\r\n\x05\x04\x17\x02\n\x03\x12\x04\xc2\x03\x0e\x0f\
    \n\x0c\n\x04\x04\x17\x02\x0b\x12\x04\xc3\x03\x02\x12\n\r\n\x05\x04\x17\
    \x02\x0b\x05\x12\x04\xc3\x03\x02\x07\n\r\n\x05\x04\x17\x02\x0b\x01\x12\
    \x04\xc3\x03\x08\r\n\r\n\x05\x04\x17\x02\x0b\x03\x12\x04\xc3\x03\x10\x11\
    \n\x0c\n\x04\x04\x17\x02\x0c\x12\x04\xc4\x03\x02\x11\n\r\n\x05\x04\x17\
    \x02\x0c\x05\x12\x04\xc4\x03\x02\x07\n\r\n\x05\x04\x17\x02\x0c\x01\x12\
    \x04\xc4\x03\x08\x0c\n\r\n\x05\x04\x17\x02\x0c\x03\x12\x04\xc4\x03\x0f\
    \x10\n\x0c\n\x04\x04\x17\x02\r\x12\x04\xc5\x03\x02\x16\n\r\n\x05\x04\x17\
    \x02\r\x05\x12\x04\xc5\x03\x02\x06\n\r\n\x05\x04\x17\x02\r\x01\x12\x04\
    \xc5\x03\x07\x10\n\r\n\x05\x04\x17\x02\r\x03\x12\x04\xc5\x03\x13\x15\n\
    \x0c\n\x04\x04\x17\x02\x0e\x12\x04\xc6\x03\x02\x13\n\r\n\x05\x04\x17\x02\
    \x0e\x05\x12\x04\xc6\x03\x02\x07\n\r\n\x05\x04\x17\x02\x0e\x01\x12\x04\
    \xc6\x03\x08\r\n\r\n\x05\x04\x17\x02\x0e\x03\x12\x04\xc6\x03\x10\x12\n\
    \x0c\n\x04\x04\x17\x02\x0f\x12\x04\xc7\x03\x02\"\n\r\n\x05\x04\x17\x02\
    \x0f\x05\x12\x04\xc7\x03\x02\x06\n\r\n\x05\x04\x17\x02\x0f\x01\x12\x04\
    \xc7\x03\x07\x1c\n\r\n\x05\x04\x17\x02\x0f\x03\x12\x04\xc7\x03\x1f!\n\
    \x0c\n\x04\x04\x17\x02\x10\x12\x04\xc8\x03\x02\x1f\n\r\n\x05\x04\x17\x02\
    \x10\x05\x12\x04\xc8\x03\x02\x07\n\r\n\x05\x04\x17\x02\x10\x01\x12\x04\
    \xc8\x03\x08\x19\n\r\n\x05\x04\x17\x02\x10\x03\x12\x04\xc8\x03\x1c\x1e\n\
    \x0c\n\x04\x04\x17\x02\x11\x12\x04\xc9\x03\x02\x1b\n\r\n\x05\x04\x17\x02\
    \x11\x05\x12\x04\xc9\x03\x02\x06\n\r\n\x05\x04\x17\x02\x11\x01\x12\x04\
    \xc9\x03\x07\x15\n\r\n\x05\x04\x17\x02\x11\x03\x12\x04\xc9\x03\x18\x1a\n\
    \x0c\n\x04\x04\x17\x02\x12\x12\x04\xca\x03\x02\x18\n\r\n\x05\x04\x17\x02\
    \x12\x05\x12\x04\xca\x03\x02\x07\n\r\n\x05\x04\x17\x02\x12\x01\x12\x04\
    \xca\x03\x08\x12\n\r\n\x05\x04\x17\x02\x12\x03\x12\x04\xca\x03\x15\x17\n\
    \x0c\n\x04\x04\x17\x02\x13\x12\x04\xcb\x03\x02\x1b\n\r\n\x05\x04\x17\x02\
    \x13\x05\x12\x04\xcb\x03\x02\x06\n\r\n\x05\x04\x17\x02\x13\x01\x12\x04\
    \xcb\x03\x07\x15\n\r\n\x05\x04\x17\x02\x13\x03\x12\x04\xcb\x03\x18\x1a\n\
    \x0c\n\x04\x04\x17\x02\x14\x12\x04\xcc\x03\x02\x18\n\r\n\x05\x04\x17\x02\
    \x14\x05\x12\x04\xcc\x03\x02\x07\n\r\n\x05\x04\x17\x02\x14\x01\x12\x04\
    \xcc\x03\x08\x12\n\r\n\x05\x04\x17\x02\x14\x03\x12\x04\xcc\x03\x15\x17\n\
    \x0c\n\x04\x04\x17\x02\x15\x12\x04\xcd\x03\x02\"\n\r\n\x05\x04\x17\x02\
    \x15\x05\x12\x04\xcd\x03\x02\x06\n\r\n\x05\x04\x17\x02\x15\x01\x12\x04\
    \xcd\x03\x07\x1c\n\r\n\x05\x04\x17\x02\x15\x03\x12\x04\xcd\x03\x1f!\n\
    \x0c\n\x04\x04\x17\x02\x16\x12\x04\xce\x03\x02\x20\n\r\n\x05\x04\x17\x02\
    \x16\x05\x12\x04\xce\x03\x02\x08\n\r\n\x05\x04\x17\x02\x16\x01\x12\x04\
    \xce\x03\t\x1a\n\r\n\x05\x04\x17\x02\x16\x03\x12\x04\xce\x03\x1d\x1f\n\
    \x0c\n\x04\x04\x17\x02\x17\x12\x04\xcf\x03\x02\x1d\n\r\n\x05\x04\x17\x02\
    \x17\x05\x12\x04\xcf\x03\x02\x06\n\r\n\x05\x04\x17\x02\x17\x01\x12\x04\
    \xcf\x03\x07\x17\n\r\n\x05\x04\x17\x02\x17\x03\x12\x04\xcf\x03\x1a\x1c\n\
    \x0c\n\x04\x04\x17\x02\x18\x12\x04\xd0\x03\x02\x1b\n\r\n\x05\x04\x17\x02\
    \x18\x05\x12\x04\xd0\x03\x02\x08\n\r\n\x05\x04\x17\x02\x18\x01\x12\x04\
    \xd0\x03\t\x15\n\r\n\x05\x04\x17\x02\x18\x03\x12\x04\xd0\x03\x18\x1a\n\
    \x0c\n\x04\x04\x17\x02\x19\x12\x04\xd1\x03\x02\x17\n\r\n\x05\x04\x17\x02\
    \x19\x05\x12\x04\xd1\x03\x02\x06\n\r\n\x05\x04\x17\x02\x19\x01\x12\x04\
    \xd1\x03\x07\x11\n\r\n\x05\x04\x17\x02\x19\x03\x12\x04\xd1\x03\x14\x16\n\
    \x0c\n\x04\x04\x17\x02\x1a\x12\x04\xd2\x03\x02\x15\n\r\n\x05\x04\x17\x02\
    \x1a\x05\x12\x04\xd2\x03\x02\x08\n\r\n\x05\x04\x17\x02\x1a\x01\x12\x04\
    \xd2\x03\t\x0f\n\r\n\x05\x04\x17\x02\x1a\x03\x12\x04\xd2\x03\x12\x14\n@\
    \n\x02\x05\x07\x12\x06\xd6\x03\0\xda\x03\x01\x1a2\x20===================\
    =\x20SENSOR\x20====================\n\n\x0b\n\x03\x05\x07\x01\x12\x04\
    \xd6\x03\x05\x15\n\x0c\n\x04\x05\x07\x02\0\x12\x04\xd7\x03\x02\x17\n\r\n\
    \x05\x05\x07\x02\0\x01\x12\x04\xd7\x03\x02\x12\n\r\n\x05\x05\x07\x02\0\
    \x02\x12\x04\xd7\x03\x15\x16\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\xd8\x03\
    \x02\x1e\n\r\n\x05\x05\x07\x02\x01\x01\x12\x04\xd8\x03\x02\x19\n\r\n\x05\
    \x05\x07\x02\x01\x02\x12\x04\xd8\x03\x1c\x1d\n\x0c\n\x04\x05\x07\x02\x02\
    \x12\x04\xd9\x03\x02#\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\xd9\x03\x02\
    \x1e\n\r\n\x05\x05\x07\x02\x02\x02\x12\x04\xd9\x03!\"\n\x0c\n\x02\x05\
    \x08\x12\x06\xdc\x03\0\xe0\x03\x01\n\x0b\n\x03\x05\x08\x01\x12\x04\xdc\
    \x03\x05\x18\n\x0c\n\x04\x05\x08\x02\0\x12\x04\xdd\x03\x02\x16\n\r\n\x05\
    \x05\x08\x02\0\x01\x12\x04\xdd\x03\x02\x11\n\r\n\x05\x05\x08\x02\0\x02\
    \x12\x04\xdd\x03\x14\x15\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\xde\x03\x02\
    \x17\n\r\n\x05\x05\x08\x02\x01\x01\x12\x04\xde\x03\x02\x12\n\r\n\x05\x05\
    \x08\x02\x01\x02\x12\x04\xde\x03\x15\x16\n\x0c\n\x04\x05\x08\x02\x02\x12\
    \x04\xdf\x03\x02\x16\n\r\n\x05\x05\x08\x02\x02\x01\x12\x04\xdf\x03\x02\
    \x11\n\r\n\x05\x05\x08\x02\x02\x02\x12\x04\xdf\x03\x14\x15\n\x0c\n\x02\
    \x04\x18\x12\x06\xe2\x03\0\xf6\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \xe2\x03\x08\"\n\x0b\n\x03\x04\x18\x07\x12\x04\xe3\x03\x02\x13\n\r\n\x05\
    \x04\x18\x07\x8c\x08\x12\x04\xe3\x03\x02\x13\n\x0b\n\x03\x04\x18\x07\x12\
    \x04\xe4\x03\x02\"\n\r\n\x05\x04\x18\x07\x8d\x08\x12\x04\xe4\x03\x02\"\n\
    \x0b\n\x03\x04\x18\x07\x12\x04\xe5\x03\x02\x20\n\r\n\x05\x04\x18\x07\x8e\
    \x08\x12\x04\xe5\x03\x02\x20\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xe7\x03\
    \x02\x17\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xe7\x03\x02\x08\n\r\n\x05\
    \x04\x18\x02\0\x01\x12\x04\xe7\x03\t\x12\n\r\n\x05\x04\x18\x02\0\x03\x12\
    \x04\xe7\x03\x15\x16\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xe8\x03\x02\x12\
    \n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xe8\x03\x02\t\n\r\n\x05\x04\x18\
    \x02\x01\x01\x12\x04\xe8\x03\n\r\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\
    \xe8\x03\x10\x11\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xe9\x03\x02\x12\n\r\
    \n\x05\x04\x18\x02\x02\x05\x12\x04\xe9\x03\x02\x08\n\r\n\x05\x04\x18\x02\
    \x02\x01\x12\x04\xe9\x03\t\r\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xe9\
    \x03\x10\x11\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\xea\x03\x02\x17\n\r\n\
    \x05\x04\x18\x02\x03\x05\x12\x04\xea\x03\x02\x08\n\r\n\x05\x04\x18\x02\
    \x03\x01\x12\x04\xea\x03\t\x12\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xea\
    \x03\x15\x16\n\x0c\n\x04\x04\x18\x02\x04\x12\x04\xec\x03\x02\x12\n\r\n\
    \x05\x04\x18\x02\x04\x05\x12\x04\xec\x03\x02\x08\n\r\n\x05\x04\x18\x02\
    \x04\x01\x12\x04\xec\x03\t\r\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\xec\
    \x03\x10\x11\n\x0c\n\x04\x04\x18\x02\x05\x12\x04\xed\x03\x02!\n\r\n\x05\
    \x04\x18\x02\x05\x05\x12\x04\xed\x03\x02\x08\n\r\n\x05\x04\x18\x02\x05\
    \x01\x12\x04\xed\x03\t\x1c\n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\xed\x03\
    \x1f\x20\n\x0c\n\x04\x04\x18\x02\x06\x12\x04\xee\x03\x02\x1e\n\r\n\x05\
    \x04\x18\x02\x06\x05\x12\x04\xee\x03\x02\x07\n\r\n\x05\x04\x18\x02\x06\
    \x01\x12\x04\xee\x03\x08\x19\n\r\n\x05\x04\x18\x02\x06\x03\x12\x04\xee\
    \x03\x1c\x1d\n\x0c\n\x04\x04\x18\x02\x07\x12\x04\xef\x03\x02\x18\n\r\n\
    \x05\x04\x18\x02\x07\x05\x12\x04\xef\x03\x02\x06\n\r\n\x05\x04\x18\x02\
    \x07\x01\x12\x04\xef\x03\x07\x13\n\r\n\x05\x04\x18\x02\x07\x03\x12\x04\
    \xef\x03\x16\x17\n\x0c\n\x04\x04\x18\x02\x08\x12\x04\xf0\x03\x02\x1a\n\r\
    \n\x05\x04\x18\x02\x08\x05\x12\x04\xf0\x03\x02\x08\n\r\n\x05\x04\x18\x02\
    \x08\x01\x12\x04\xf0\x03\t\x15\n\r\n\x05\x04\x18\x02\x08\x03\x12\x04\xf0\
    \x03\x18\x19\n\x0c\n\x04\x04\x18\x02\t\x12\x04\xf1\x03\x02$\n\r\n\x05\
    \x04\x18\x02\t\x06\x12\x04\xf1\x03\x02\x12\n\r\n\x05\x04\x18\x02\t\x01\
    \x12\x04\xf1\x03\x13\x1e\n\r\n\x05\x04\x18\x02\t\x03\x12\x04\xf1\x03!#\n\
    3\n\x04\x04\x18\x02\n\x12\x04\xf3\x03\x022\x1a%\x20Last\x20reset\x20type\
    \x20removed\x20in\x202021.9.0\n\n\r\n\x05\x04\x18\x02\n\x06\x12\x04\xf3\
    \x03\x02\x15\n\r\n\x05\x04\x18\x02\n\x01\x12\x04\xf3\x03\x16,\n\r\n\x05\
    \x04\x18\x02\n\x03\x12\x04\xf3\x03/1\n\x0c\n\x04\x04\x18\x02\x0b\x12\x04\
    \xf4\x03\x02\x20\n\r\n\x05\x04\x18\x02\x0b\x05\x12\x04\xf4\x03\x02\x06\n\
    \r\n\x05\x04\x18\x02\x0b\x01\x12\x04\xf4\x03\x07\x1a\n\r\n\x05\x04\x18\
    \x02\x0b\x03\x12\x04\xf4\x03\x1d\x1f\n\x0c\n\x04\x04\x18\x02\x0c\x12\x04\
    \xf5\x03\x02&\n\r\n\x05\x04\x18\x02\x0c\x06\x12\x04\xf5\x03\x02\x10\n\r\
    \n\x05\x04\x18\x02\x0c\x01\x12\x04\xf5\x03\x11\x20\n\r\n\x05\x04\x18\x02\
    \x0c\x03\x12\x04\xf5\x03#%\n\x0c\n\x02\x04\x19\x12\x06\xf7\x03\0\x82\x04\
    \x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xf7\x03\x08\x1b\n\x0b\n\x03\x04\x19\
    \x07\x12\x04\xf8\x03\x02\x13\n\r\n\x05\x04\x19\x07\x8c\x08\x12\x04\xf8\
    \x03\x02\x13\n\x0b\n\x03\x04\x19\x07\x12\x04\xf9\x03\x02\"\n\r\n\x05\x04\
    \x19\x07\x8d\x08\x12\x04\xf9\x03\x02\"\n\x0b\n\x03\x04\x19\x07\x12\x04\
    \xfa\x03\x02\x20\n\r\n\x05\x04\x19\x07\x8e\x08\x12\x04\xfa\x03\x02\x20\n\
    \x0b\n\x03\x04\x19\x07\x12\x04\xfb\x03\x02\x1b\n\r\n\x05\x04\x19\x07\x90\
    \x08\x12\x04\xfb\x03\x02\x1b\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xfd\x03\
    \x02\x12\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xfd\x03\x02\t\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\xfd\x03\n\r\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \xfd\x03\x10\x11\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xfe\x03\x02\x12\n\r\
    \n\x05\x04\x19\x02\x01\x05\x12\x04\xfe\x03\x02\x07\n\r\n\x05\x04\x19\x02\
    \x01\x01\x12\x04\xfe\x03\x08\r\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xfe\
    \x03\x10\x11\n\x90\x01\n\x04\x04\x19\x02\x02\x12\x04\x81\x04\x02\x19\x1a\
    \x81\x01\x20If\x20the\x20sensor\x20does\x20not\x20have\x20a\x20valid\x20\
    state\x20yet.\n\x20Equivalent\x20to\x20`!obj->has_state()`\x20-\x20inver\
    se\x20logic\x20to\x20make\x20state\x20packets\x20smaller\n\n\r\n\x05\x04\
    \x19\x02\x02\x05\x12\x04\x81\x04\x02\x06\n\r\n\x05\x04\x19\x02\x02\x01\
    \x12\x04\x81\x04\x07\x14\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\x81\x04\
    \x17\x18\n@\n\x02\x04\x1a\x12\x06\x85\x04\0\x94\x04\x01\x1a2\x20========\
    ============\x20SWITCH\x20====================\n\n\x0b\n\x03\x04\x1a\x01\
    \x12\x04\x85\x04\x08\"\n\x0b\n\x03\x04\x1a\x07\x12\x04\x86\x04\x02\x13\n\
    \r\n\x05\x04\x1a\x07\x8c\x08\x12\x04\x86\x04\x02\x13\n\x0b\n\x03\x04\x1a\
    \x07\x12\x04\x87\x04\x02\"\n\r\n\x05\x04\x1a\x07\x8d\x08\x12\x04\x87\x04\
    \x02\"\n\x0b\n\x03\x04\x1a\x07\x12\x04\x88\x04\x02\x20\n\r\n\x05\x04\x1a\
    \x07\x8e\x08\x12\x04\x88\x04\x02\x20\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\
    \x8a\x04\x02\x17\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\x8a\x04\x02\x08\n\r\
    \n\x05\x04\x1a\x02\0\x01\x12\x04\x8a\x04\t\x12\n\r\n\x05\x04\x1a\x02\0\
    \x03\x12\x04\x8a\x04\x15\x16\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\x8b\x04\
    \x02\x12\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\x8b\x04\x02\t\n\r\n\x05\
    \x04\x1a\x02\x01\x01\x12\x04\x8b\x04\n\r\n\r\n\x05\x04\x1a\x02\x01\x03\
    \x12\x04\x8b\x04\x10\x11\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\x8c\x04\x02\
    \x12\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\x8c\x04\x02\x08\n\r\n\x05\x04\
    \x1a\x02\x02\x01\x12\x04\x8c\x04\t\r\n\r\n\x05\x04\x1a\x02\x02\x03\x12\
    \x04\x8c\x04\x10\x11\n\x0c\n\x04\x04\x1a\x02\x03\x12\x04\x8d\x04\x02\x17\
    \n\r\n\x05\x04\x1a\x02\x03\x05\x12\x04\x8d\x04\x02\x08\n\r\n\x05\x04\x1a\
    \x02\x03\x01\x12\x04\x8d\x04\t\x12\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\
    \x8d\x04\x15\x16\n\x0c\n\x04\x04\x1a\x02\x04\x12\x04\x8f\x04\x02\x12\n\r\
    \n\x05\x04\x1a\x02\x04\x05\x12\x04\x8f\x04\x02\x08\n\r\n\x05\x04\x1a\x02\
    \x04\x01\x12\x04\x8f\x04\t\r\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\x8f\
    \x04\x10\x11\n\x0c\n\x04\x04\x1a\x02\x05\x12\x04\x90\x04\x02\x19\n\r\n\
    \x05\x04\x1a\x02\x05\x05\x12\x04\x90\x04\x02\x06\n\r\n\x05\x04\x1a\x02\
    \x05\x01\x12\x04\x90\x04\x07\x14\n\r\n\x05\x04\x1a\x02\x05\x03\x12\x04\
    \x90\x04\x17\x18\n\x0c\n\x04\x04\x1a\x02\x06\x12\x04\x91\x04\x02\x1f\n\r\
    \n\x05\x04\x1a\x02\x06\x05\x12\x04\x91\x04\x02\x06\n\r\n\x05\x04\x1a\x02\
    \x06\x01\x12\x04\x91\x04\x07\x1a\n\r\n\x05\x04\x1a\x02\x06\x03\x12\x04\
    \x91\x04\x1d\x1e\n\x0c\n\x04\x04\x1a\x02\x07\x12\x04\x92\x04\x02%\n\r\n\
    \x05\x04\x1a\x02\x07\x06\x12\x04\x92\x04\x02\x10\n\r\n\x05\x04\x1a\x02\
    \x07\x01\x12\x04\x92\x04\x11\x20\n\r\n\x05\x04\x1a\x02\x07\x03\x12\x04\
    \x92\x04#$\n\x0c\n\x04\x04\x1a\x02\x08\x12\x04\x93\x04\x02\x1a\n\r\n\x05\
    \x04\x1a\x02\x08\x05\x12\x04\x93\x04\x02\x08\n\r\n\x05\x04\x1a\x02\x08\
    \x01\x12\x04\x93\x04\t\x15\n\r\n\x05\x04\x1a\x02\x08\x03\x12\x04\x93\x04\
    \x18\x19\n\x0c\n\x02\x04\x1b\x12\x06\x95\x04\0\x9d\x04\x01\n\x0b\n\x03\
    \x04\x1b\x01\x12\x04\x95\x04\x08\x1b\n\x0b\n\x03\x04\x1b\x07\x12\x04\x96\
    \x04\x02\x13\n\r\n\x05\x04\x1b\x07\x8c\x08\x12\x04\x96\x04\x02\x13\n\x0b\
    \n\x03\x04\x1b\x07\x12\x04\x97\x04\x02\"\n\r\n\x05\x04\x1b\x07\x8d\x08\
    \x12\x04\x97\x04\x02\"\n\x0b\n\x03\x04\x1b\x07\x12\x04\x98\x04\x02\x20\n\
    \r\n\x05\x04\x1b\x07\x8e\x08\x12\x04\x98\x04\x02\x20\n\x0b\n\x03\x04\x1b\
    \x07\x12\x04\x99\x04\x02\x1b\n\r\n\x05\x04\x1b\x07\x90\x08\x12\x04\x99\
    \x04\x02\x1b\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\x9b\x04\x02\x12\n\r\n\x05\
    \x04\x1b\x02\0\x05\x12\x04\x9b\x04\x02\t\n\r\n\x05\x04\x1b\x02\0\x01\x12\
    \x04\x9b\x04\n\r\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\x9b\x04\x10\x11\n\
    \x0c\n\x04\x04\x1b\x02\x01\x12\x04\x9c\x04\x02\x11\n\r\n\x05\x04\x1b\x02\
    \x01\x05\x12\x04\x9c\x04\x02\x06\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\
    \x9c\x04\x07\x0c\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\x9c\x04\x0f\x10\n\
    \x0c\n\x02\x04\x1c\x12\x06\x9e\x04\0\xa6\x04\x01\n\x0b\n\x03\x04\x1c\x01\
    \x12\x04\x9e\x04\x08\x1c\n\x0b\n\x03\x04\x1c\x07\x12\x04\x9f\x04\x02\x13\
    \n\r\n\x05\x04\x1c\x07\x8c\x08\x12\x04\x9f\x04\x02\x13\n\x0b\n\x03\x04\
    \x1c\x07\x12\x04\xa0\x04\x02\"\n\r\n\x05\x04\x1c\x07\x8d\x08\x12\x04\xa0\
    \x04\x02\"\n\x0b\n\x03\x04\x1c\x07\x12\x04\xa1\x04\x02\x20\n\r\n\x05\x04\
    \x1c\x07\x8e\x08\x12\x04\xa1\x04\x02\x20\n\x0b\n\x03\x04\x1c\x07\x12\x04\
    \xa2\x04\x02\x1b\n\r\n\x05\x04\x1c\x07\x90\x08\x12\x04\xa2\x04\x02\x1b\n\
    \x0c\n\x04\x04\x1c\x02\0\x12\x04\xa4\x04\x02\x12\n\r\n\x05\x04\x1c\x02\0\
    \x05\x12\x04\xa4\x04\x02\t\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xa4\x04\n\
    \r\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xa4\x04\x10\x11\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\xa5\x04\x02\x11\n\r\n\x05\x04\x1c\x02\x01\x05\x12\
    \x04\xa5\x04\x02\x06\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xa5\x04\x07\
    \x0c\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xa5\x04\x0f\x10\nE\n\x02\x04\
    \x1d\x12\x06\xa9\x04\0\xb6\x04\x01\x1a7\x20====================\x20TEXT\
    \x20SENSOR\x20====================\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xa9\
    \x04\x08&\n\x0b\n\x03\x04\x1d\x07\x12\x04\xaa\x04\x02\x13\n\r\n\x05\x04\
    \x1d\x07\x8c\x08\x12\x04\xaa\x04\x02\x13\n\x0b\n\x03\x04\x1d\x07\x12\x04\
    \xab\x04\x02\"\n\r\n\x05\x04\x1d\x07\x8d\x08\x12\x04\xab\x04\x02\"\n\x0b\
    \n\x03\x04\x1d\x07\x12\x04\xac\x04\x02%\n\r\n\x05\x04\x1d\x07\x8e\x08\
    \x12\x04\xac\x04\x02%\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xae\x04\x02\x17\
    \n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xae\x04\x02\x08\n\r\n\x05\x04\x1d\
    \x02\0\x01\x12\x04\xae\x04\t\x12\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xae\
    \x04\x15\x16\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xaf\x04\x02\x12\n\r\n\
    \x05\x04\x1d\x02\x01\x05\x12\x04\xaf\x04\x02\t\n\r\n\x05\x04\x1d\x02\x01\
    \x01\x12\x04\xaf\x04\n\r\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xaf\x04\
    \x10\x11\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xb0\x04\x02\x12\n\r\n\x05\
    \x04\x1d\x02\x02\x05\x12\x04\xb0\x04\x02\x08\n\r\n\x05\x04\x1d\x02\x02\
    \x01\x12\x04\xb0\x04\t\r\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xb0\x04\
    \x10\x11\n\x0c\n\x04\x04\x1d\x02\x03\x12\x04\xb1\x04\x02\x17\n\r\n\x05\
    \x04\x1d\x02\x03\x05\x12\x04\xb1\x04\x02\x08\n\r\n\x05\x04\x1d\x02\x03\
    \x01\x12\x04\xb1\x04\t\x12\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\xb1\x04\
    \x15\x16\n\x0c\n\x04\x04\x1d\x02\x04\x12\x04\xb3\x04\x02\x12\n\r\n\x05\
    \x04\x1d\x02\x04\x05\x12\x04\xb3\x04\x02\x08\n\r\n\x05\x04\x1d\x02\x04\
    \x01\x12\x04\xb3\x04\t\r\n\r\n\x05\x04\x1d\x02\x04\x03\x12\x04\xb3\x04\
    \x10\x11\n\x0c\n\x04\x04\x1d\x02\x05\x12\x04\xb4\x04\x02\x1f\n\r\n\x05\
    \x04\x1d\x02\x05\x05\x12\x04\xb4\x04\x02\x06\n\r\n\x05\x04\x1d\x02\x05\
    \x01\x12\x04\xb4\x04\x07\x1a\n\r\n\x05\x04\x1d\x02\x05\x03\x12\x04\xb4\
    \x04\x1d\x1e\n\x0c\n\x04\x04\x1d\x02\x06\x12\x04\xb5\x04\x02%\n\r\n\x05\
    \x04\x1d\x02\x06\x06\x12\x04\xb5\x04\x02\x10\n\r\n\x05\x04\x1d\x02\x06\
    \x01\x12\x04\xb5\x04\x11\x20\n\r\n\x05\x04\x1d\x02\x06\x03\x12\x04\xb5\
    \x04#$\n\x0c\n\x02\x04\x1e\x12\x06\xb7\x04\0\xc2\x04\x01\n\x0b\n\x03\x04\
    \x1e\x01\x12\x04\xb7\x04\x08\x1f\n\x0b\n\x03\x04\x1e\x07\x12\x04\xb8\x04\
    \x02\x13\n\r\n\x05\x04\x1e\x07\x8c\x08\x12\x04\xb8\x04\x02\x13\n\x0b\n\
    \x03\x04\x1e\x07\x12\x04\xb9\x04\x02\"\n\r\n\x05\x04\x1e\x07\x8d\x08\x12\
    \x04\xb9\x04\x02\"\n\x0b\n\x03\x04\x1e\x07\x12\x04\xba\x04\x02%\n\r\n\
    \x05\x04\x1e\x07\x8e\x08\x12\x04\xba\x04\x02%\n\x0b\n\x03\x04\x1e\x07\
    \x12\x04\xbb\x04\x02\x1b\n\r\n\x05\x04\x1e\x07\x90\x08\x12\x04\xbb\x04\
    \x02\x1b\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xbd\x04\x02\x12\n\r\n\x05\x04\
    \x1e\x02\0\x05\x12\x04\xbd\x04\x02\t\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\
    \xbd\x04\n\r\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xbd\x04\x10\x11\n\x0c\n\
    \x04\x04\x1e\x02\x01\x12\x04\xbe\x04\x02\x13\n\r\n\x05\x04\x1e\x02\x01\
    \x05\x12\x04\xbe\x04\x02\x08\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xbe\
    \x04\t\x0e\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xbe\x04\x11\x12\n\x95\
    \x01\n\x04\x04\x1e\x02\x02\x12\x04\xc1\x04\x02\x19\x1a\x86\x01\x20If\x20\
    the\x20text\x20sensor\x20does\x20not\x20have\x20a\x20valid\x20state\x20y\
    et.\n\x20Equivalent\x20to\x20`!obj->has_state()`\x20-\x20inverse\x20logi\
    c\x20to\x20make\x20state\x20packets\x20smaller\n\n\r\n\x05\x04\x1e\x02\
    \x02\x05\x12\x04\xc1\x04\x02\x06\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\
    \xc1\x04\x07\x14\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xc1\x04\x17\x18\n\
    H\n\x02\x05\t\x12\x06\xc5\x04\0\xce\x04\x01\x1a:\x20====================\
    \x20SUBSCRIBE\x20LOGS\x20====================\n\n\x0b\n\x03\x05\t\x01\
    \x12\x04\xc5\x04\x05\r\n\x0c\n\x04\x05\t\x02\0\x12\x04\xc6\x04\x02\x15\n\
    \r\n\x05\x05\t\x02\0\x01\x12\x04\xc6\x04\x02\x10\n\r\n\x05\x05\t\x02\0\
    \x02\x12\x04\xc6\x04\x13\x14\n\x0c\n\x04\x05\t\x02\x01\x12\x04\xc7\x04\
    \x02\x16\n\r\n\x05\x05\t\x02\x01\x01\x12\x04\xc7\x04\x02\x11\n\r\n\x05\
    \x05\t\x02\x01\x02\x12\x04\xc7\x04\x14\x15\n\x0c\n\x04\x05\t\x02\x02\x12\
    \x04\xc8\x04\x02\x15\n\r\n\x05\x05\t\x02\x02\x01\x12\x04\xc8\x04\x02\x10\
    \n\r\n\x05\x05\t\x02\x02\x02\x12\x04\xc8\x04\x13\x14\n\x0c\n\x04\x05\t\
    \x02\x03\x12\x04\xc9\x04\x02\x15\n\r\n\x05\x05\t\x02\x03\x01\x12\x04\xc9\
    \x04\x02\x10\n\r\n\x05\x05\t\x02\x03\x02\x12\x04\xc9\x04\x13\x14\n\x0c\n\
    \x04\x05\t\x02\x04\x12\x04\xca\x04\x02\x17\n\r\n\x05\x05\t\x02\x04\x01\
    \x12\x04\xca\x04\x02\x12\n\r\n\x05\x05\t\x02\x04\x02\x12\x04\xca\x04\x15\
    \x16\n\x0c\n\x04\x05\t\x02\x05\x12\x04\xcb\x04\x02\x16\n\r\n\x05\x05\t\
    \x02\x05\x01\x12\x04\xcb\x04\x02\x11\n\r\n\x05\x05\t\x02\x05\x02\x12\x04\
    \xcb\x04\x14\x15\n\x0c\n\x04\x05\t\x02\x06\x12\x04\xcc\x04\x02\x18\n\r\n\
    \x05\x05\t\x02\x06\x01\x12\x04\xcc\x04\x02\x13\n\r\n\x05\x05\t\x02\x06\
    \x02\x12\x04\xcc\x04\x16\x17\n\x0c\n\x04\x05\t\x02\x07\x12\x04\xcd\x04\
    \x02\x1d\n\r\n\x05\x05\t\x02\x07\x01\x12\x04\xcd\x04\x02\x18\n\r\n\x05\
    \x05\t\x02\x07\x02\x12\x04\xcd\x04\x1b\x1c\n\x0c\n\x02\x04\x1f\x12\x06\
    \xcf\x04\0\xd4\x04\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xcf\x04\x08\x1c\n\
    \x0b\n\x03\x04\x1f\x07\x12\x04\xd0\x04\x02\x13\n\r\n\x05\x04\x1f\x07\x8c\
    \x08\x12\x04\xd0\x04\x02\x13\n\x0b\n\x03\x04\x1f\x07\x12\x04\xd1\x04\x02\
    \"\n\r\n\x05\x04\x1f\x07\x8d\x08\x12\x04\xd1\x04\x02\"\n\x0c\n\x04\x04\
    \x1f\x02\0\x12\x04\xd2\x04\x02\x15\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\
    \xd2\x04\x02\n\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xd2\x04\x0b\x10\n\r\n\
    \x05\x04\x1f\x02\0\x03\x12\x04\xd2\x04\x13\x14\n\x0c\n\x04\x04\x1f\x02\
    \x01\x12\x04\xd3\x04\x02\x17\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xd3\
    \x04\x02\x06\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xd3\x04\x07\x12\n\r\n\
    \x05\x04\x1f\x02\x01\x03\x12\x04\xd3\x04\x15\x16\n\x0c\n\x02\x04\x20\x12\
    \x06\xd5\x04\0\xde\x04\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xd5\x04\x08\
    \x1d\n\x0b\n\x03\x04\x20\x07\x12\x04\xd6\x04\x02\x13\n\r\n\x05\x04\x20\
    \x07\x8c\x08\x12\x04\xd6\x04\x02\x13\n\x0b\n\x03\x04\x20\x07\x12\x04\xd7\
    \x04\x02\"\n\r\n\x05\x04\x20\x07\x8d\x08\x12\x04\xd7\x04\x02\"\n\x0b\n\
    \x03\x04\x20\x07\x12\x04\xd8\x04\x02\x17\n\r\n\x05\x04\x20\x07\x8f\x08\
    \x12\x04\xd8\x04\x02\x17\n\x0b\n\x03\x04\x20\x07\x12\x04\xd9\x04\x02\x1c\
    \n\r\n\x05\x04\x20\x07\x90\x08\x12\x04\xd9\x04\x02\x1c\n\x0c\n\x04\x04\
    \x20\x02\0\x12\x04\xdb\x04\x02\x15\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\
    \xdb\x04\x02\n\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xdb\x04\x0b\x10\n\r\n\
    \x05\x04\x20\x02\0\x03\x12\x04\xdb\x04\x13\x14\n\x0c\n\x04\x04\x20\x02\
    \x01\x12\x04\xdc\x04\x02\x15\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xdc\
    \x04\x02\x08\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xdc\x04\t\x10\n\r\n\
    \x05\x04\x20\x02\x01\x03\x12\x04\xdc\x04\x13\x14\n\x0c\n\x04\x04\x20\x02\
    \x02\x12\x04\xdd\x04\x02\x17\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\xdd\
    \x04\x02\x06\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\xdd\x04\x07\x12\n\r\n\
    \x05\x04\x20\x02\x02\x03\x12\x04\xdd\x04\x15\x16\nO\n\x02\x04!\x12\x06\
    \xe1\x04\0\xe4\x04\x01\x1aA\x20====================\x20HOMEASSISTANT.SER\
    VICE\x20====================\n\n\x0b\n\x03\x04!\x01\x12\x04\xe1\x04\x08-\
    \n\x0b\n\x03\x04!\x07\x12\x04\xe2\x04\x02\x13\n\r\n\x05\x04!\x07\x8c\x08\
    \x12\x04\xe2\x04\x02\x13\n\x0b\n\x03\x04!\x07\x12\x04\xe3\x04\x02\"\n\r\
    \n\x05\x04!\x07\x8d\x08\x12\x04\xe3\x04\x02\"\n\x0c\n\x02\x04\"\x12\x06\
    \xe6\x04\0\xe9\x04\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xe6\x04\x08\x1f\n\
    \x0c\n\x04\x04\"\x02\0\x12\x04\xe7\x04\x02\x11\n\r\n\x05\x04\"\x02\0\x05\
    \x12\x04\xe7\x04\x02\x08\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xe7\x04\t\x0c\
    \n\r\n\x05\x04\"\x02\0\x03\x12\x04\xe7\x04\x0f\x10\n\x0c\n\x04\x04\"\x02\
    \x01\x12\x04\xe8\x04\x02\x13\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xe8\x04\
    \x02\x08\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xe8\x04\t\x0e\n\r\n\x05\x04\
    \"\x02\x01\x03\x12\x04\xe8\x04\x11\x12\n\x0c\n\x02\x04#\x12\x06\xeb\x04\
    \0\xf5\x04\x01\n\x0b\n\x03\x04#\x01\x12\x04\xeb\x04\x08$\n\x0b\n\x03\x04\
    #\x07\x12\x04\xec\x04\x02\x13\n\r\n\x05\x04#\x07\x8c\x08\x12\x04\xec\x04\
    \x02\x13\n\x0b\n\x03\x04#\x07\x12\x04\xed\x04\x02\"\n\r\n\x05\x04#\x07\
    \x8d\x08\x12\x04\xed\x04\x02\"\n\x0b\n\x03\x04#\x07\x12\x04\xee\x04\x02\
    \x1b\n\r\n\x05\x04#\x07\x90\x08\x12\x04\xee\x04\x02\x1b\n\x0c\n\x04\x04#\
    \x02\0\x12\x04\xf0\x04\x02\x15\n\r\n\x05\x04#\x02\0\x05\x12\x04\xf0\x04\
    \x02\x08\n\r\n\x05\x04#\x02\0\x01\x12\x04\xf0\x04\t\x10\n\r\n\x05\x04#\
    \x02\0\x03\x12\x04\xf0\x04\x13\x14\n\x0c\n\x04\x04#\x02\x01\x12\x04\xf1\
    \x04\x02,\n\r\n\x05\x04#\x02\x01\x04\x12\x04\xf1\x04\x02\n\n\r\n\x05\x04\
    #\x02\x01\x06\x12\x04\xf1\x04\x0b\"\n\r\n\x05\x04#\x02\x01\x01\x12\x04\
    \xf1\x04#'\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xf1\x04*+\n\x0c\n\x04\x04#\
    \x02\x02\x12\x04\xf2\x04\x025\n\r\n\x05\x04#\x02\x02\x04\x12\x04\xf2\x04\
    \x02\n\n\r\n\x05\x04#\x02\x02\x06\x12\x04\xf2\x04\x0b\"\n\r\n\x05\x04#\
    \x02\x02\x01\x12\x04\xf2\x04#0\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xf2\
    \x0434\n\x0c\n\x04\x04#\x02\x03\x12\x04\xf3\x04\x021\n\r\n\x05\x04#\x02\
    \x03\x04\x12\x04\xf3\x04\x02\n\n\r\n\x05\x04#\x02\x03\x06\x12\x04\xf3\
    \x04\x0b\"\n\r\n\x05\x04#\x02\x03\x01\x12\x04\xf3\x04#,\n\r\n\x05\x04#\
    \x02\x03\x03\x12\x04\xf3\x04/0\n\x0c\n\x04\x04#\x02\x04\x12\x04\xf4\x04\
    \x02\x14\n\r\n\x05\x04#\x02\x04\x05\x12\x04\xf4\x04\x02\x06\n\r\n\x05\
    \x04#\x02\x04\x01\x12\x04\xf4\x04\x07\x0f\n\r\n\x05\x04#\x02\x04\x03\x12\
    \x04\xf4\x04\x12\x13\n\x9d\x02\n\x02\x04$\x12\x06\xfb\x04\0\xfe\x04\x01\
    \x1a\x8e\x02\x20====================\x20IMPORT\x20HOME\x20ASSISTANT\x20S\
    TATES\x20====================\n\x201.\x20Client\x20sends\x20SubscribeHom\
    eAssistantStatesRequest\n\x202.\x20Server\x20responds\x20with\x20zero\
    \x20or\x20more\x20SubscribeHomeAssistantStateResponse\x20(async)\n\x203.\
    \x20Client\x20sends\x20HomeAssistantStateResponse\x20for\x20state\x20cha\
    nges.\n\n\x0b\n\x03\x04$\x01\x12\x04\xfb\x04\x08+\n\x0b\n\x03\x04$\x07\
    \x12\x04\xfc\x04\x02\x13\n\r\n\x05\x04$\x07\x8c\x08\x12\x04\xfc\x04\x02\
    \x13\n\x0b\n\x03\x04$\x07\x12\x04\xfd\x04\x02\"\n\r\n\x05\x04$\x07\x8d\
    \x08\x12\x04\xfd\x04\x02\"\n\x0c\n\x02\x04%\x12\x06\x80\x05\0\x85\x05\
    \x01\n\x0b\n\x03\x04%\x01\x12\x04\x80\x05\x08+\n\x0b\n\x03\x04%\x07\x12\
    \x04\x81\x05\x02\x13\n\r\n\x05\x04%\x07\x8c\x08\x12\x04\x81\x05\x02\x13\
    \n\x0b\n\x03\x04%\x07\x12\x04\x82\x05\x02\"\n\r\n\x05\x04%\x07\x8d\x08\
    \x12\x04\x82\x05\x02\"\n\x0c\n\x04\x04%\x02\0\x12\x04\x83\x05\x02\x17\n\
    \r\n\x05\x04%\x02\0\x05\x12\x04\x83\x05\x02\x08\n\r\n\x05\x04%\x02\0\x01\
    \x12\x04\x83\x05\t\x12\n\r\n\x05\x04%\x02\0\x03\x12\x04\x83\x05\x15\x16\
    \n\x0c\n\x04\x04%\x02\x01\x12\x04\x84\x05\x02\x17\n\r\n\x05\x04%\x02\x01\
    \x05\x12\x04\x84\x05\x02\x08\n\r\n\x05\x04%\x02\x01\x01\x12\x04\x84\x05\
    \t\x12\n\r\n\x05\x04%\x02\x01\x03\x12\x04\x84\x05\x15\x16\n\x0c\n\x02\
    \x04&\x12\x06\x87\x05\0\x8f\x05\x01\n\x0b\n\x03\x04&\x01\x12\x04\x87\x05\
    \x08\"\n\x0b\n\x03\x04&\x07\x12\x04\x88\x05\x02\x13\n\r\n\x05\x04&\x07\
    \x8c\x08\x12\x04\x88\x05\x02\x13\n\x0b\n\x03\x04&\x07\x12\x04\x89\x05\
    \x02\"\n\r\n\x05\x04&\x07\x8d\x08\x12\x04\x89\x05\x02\"\n\x0b\n\x03\x04&\
    \x07\x12\x04\x8a\x05\x02\x1b\n\r\n\x05\x04&\x07\x90\x08\x12\x04\x8a\x05\
    \x02\x1b\n\x0c\n\x04\x04&\x02\0\x12\x04\x8c\x05\x02\x17\n\r\n\x05\x04&\
    \x02\0\x05\x12\x04\x8c\x05\x02\x08\n\r\n\x05\x04&\x02\0\x01\x12\x04\x8c\
    \x05\t\x12\n\r\n\x05\x04&\x02\0\x03\x12\x04\x8c\x05\x15\x16\n\x0c\n\x04\
    \x04&\x02\x01\x12\x04\x8d\x05\x02\x13\n\r\n\x05\x04&\x02\x01\x05\x12\x04\
    \x8d\x05\x02\x08\n\r\n\x05\x04&\x02\x01\x01\x12\x04\x8d\x05\t\x0e\n\r\n\
    \x05\x04&\x02\x01\x03\x12\x04\x8d\x05\x11\x12\n\x0c\n\x04\x04&\x02\x02\
    \x12\x04\x8e\x05\x02\x17\n\r\n\x05\x04&\x02\x02\x05\x12\x04\x8e\x05\x02\
    \x08\n\r\n\x05\x04&\x02\x02\x01\x12\x04\x8e\x05\t\x12\n\r\n\x05\x04&\x02\
    \x02\x03\x12\x04\x8e\x05\x15\x16\nE\n\x02\x04'\x12\x06\x92\x05\0\x95\x05\
    \x01\x1a7\x20====================\x20IMPORT\x20TIME\x20=================\
    ===\n\n\x0b\n\x03\x04'\x01\x12\x04\x92\x05\x08\x16\n\x0b\n\x03\x04'\x07\
    \x12\x04\x93\x05\x02\x13\n\r\n\x05\x04'\x07\x8c\x08\x12\x04\x93\x05\x02\
    \x13\n\x0b\n\x03\x04'\x07\x12\x04\x94\x05\x02\x20\n\r\n\x05\x04'\x07\x8d\
    \x08\x12\x04\x94\x05\x02\x20\n\x0c\n\x02\x04(\x12\x06\x97\x05\0\x9d\x05\
    \x01\n\x0b\n\x03\x04(\x01\x12\x04\x97\x05\x08\x17\n\x0b\n\x03\x04(\x07\
    \x12\x04\x98\x05\x02\x13\n\r\n\x05\x04(\x07\x8c\x08\x12\x04\x98\x05\x02\
    \x13\n\x0b\n\x03\x04(\x07\x12\x04\x99\x05\x02\x20\n\r\n\x05\x04(\x07\x8d\
    \x08\x12\x04\x99\x05\x02\x20\n\x0b\n\x03\x04(\x07\x12\x04\x9a\x05\x02\
    \x1b\n\r\n\x05\x04(\x07\x90\x08\x12\x04\x9a\x05\x02\x1b\n\x0c\n\x04\x04(\
    \x02\0\x12\x04\x9c\x05\x02\x1c\n\r\n\x05\x04(\x02\0\x05\x12\x04\x9c\x05\
    \x02\t\n\r\n\x05\x04(\x02\0\x01\x12\x04\x9c\x05\n\x17\n\r\n\x05\x04(\x02\
    \0\x03\x12\x04\x9c\x05\x1a\x1b\nO\n\x02\x05\n\x12\x06\xa0\x05\0\xa9\x05\
    \x01\x1aA\x20====================\x20USER-DEFINES\x20SERVICES\x20=======\
    =============\n\n\x0b\n\x03\x05\n\x01\x12\x04\xa0\x05\x05\x13\n\x0c\n\
    \x04\x05\n\x02\0\x12\x04\xa1\x05\x02\x1c\n\r\n\x05\x05\n\x02\0\x01\x12\
    \x04\xa1\x05\x02\x17\n\r\n\x05\x05\n\x02\0\x02\x12\x04\xa1\x05\x1a\x1b\n\
    \x0c\n\x04\x05\n\x02\x01\x12\x04\xa2\x05\x02\x1b\n\r\n\x05\x05\n\x02\x01\
    \x01\x12\x04\xa2\x05\x02\x16\n\r\n\x05\x05\n\x02\x01\x02\x12\x04\xa2\x05\
    \x19\x1a\n\x0c\n\x04\x05\n\x02\x02\x12\x04\xa3\x05\x02\x1d\n\r\n\x05\x05\
    \n\x02\x02\x01\x12\x04\xa3\x05\x02\x18\n\r\n\x05\x05\n\x02\x02\x02\x12\
    \x04\xa3\x05\x1b\x1c\n\x0c\n\x04\x05\n\x02\x03\x12\x04\xa4\x05\x02\x1e\n\
    \r\n\x05\x05\n\x02\x03\x01\x12\x04\xa4\x05\x02\x19\n\r\n\x05\x05\n\x02\
    \x03\x02\x12\x04\xa4\x05\x1c\x1d\n\x0c\n\x04\x05\n\x02\x04\x12\x04\xa5\
    \x05\x02\"\n\r\n\x05\x05\n\x02\x04\x01\x12\x04\xa5\x05\x02\x1d\n\r\n\x05\
    \x05\n\x02\x04\x02\x12\x04\xa5\x05\x20!\n\x0c\n\x04\x05\n\x02\x05\x12\
    \x04\xa6\x05\x02!\n\r\n\x05\x05\n\x02\x05\x01\x12\x04\xa6\x05\x02\x1c\n\
    \r\n\x05\x05\n\x02\x05\x02\x12\x04\xa6\x05\x1f\x20\n\x0c\n\x04\x05\n\x02\
    \x06\x12\x04\xa7\x05\x02#\n\r\n\x05\x05\n\x02\x06\x01\x12\x04\xa7\x05\
    \x02\x1e\n\r\n\x05\x05\n\x02\x06\x02\x12\x04\xa7\x05!\"\n\x0c\n\x04\x05\
    \n\x02\x07\x12\x04\xa8\x05\x02$\n\r\n\x05\x05\n\x02\x07\x01\x12\x04\xa8\
    \x05\x02\x1f\n\r\n\x05\x05\n\x02\x07\x02\x12\x04\xa8\x05\"#\n\x0c\n\x02\
    \x04)\x12\x06\xaa\x05\0\xad\x05\x01\n\x0b\n\x03\x04)\x01\x12\x04\xaa\x05\
    \x08$\n\x0c\n\x04\x04)\x02\0\x12\x04\xab\x05\x02\x12\n\r\n\x05\x04)\x02\
    \0\x05\x12\x04\xab\x05\x02\x08\n\r\n\x05\x04)\x02\0\x01\x12\x04\xab\x05\
    \t\r\n\r\n\x05\x04)\x02\0\x03\x12\x04\xab\x05\x10\x11\n\x0c\n\x04\x04)\
    \x02\x01\x12\x04\xac\x05\x02\x1a\n\r\n\x05\x04)\x02\x01\x06\x12\x04\xac\
    \x05\x02\x10\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xac\x05\x11\x15\n\r\n\
    \x05\x04)\x02\x01\x03\x12\x04\xac\x05\x18\x19\n\x0c\n\x02\x04*\x12\x06\
    \xae\x05\0\xb5\x05\x01\n\x0b\n\x03\x04*\x01\x12\x04\xae\x05\x08$\n\x0b\n\
    \x03\x04*\x07\x12\x04\xaf\x05\x02\x13\n\r\n\x05\x04*\x07\x8c\x08\x12\x04\
    \xaf\x05\x02\x13\n\x0b\n\x03\x04*\x07\x12\x04\xb0\x05\x02\"\n\r\n\x05\
    \x04*\x07\x8d\x08\x12\x04\xb0\x05\x02\"\n\x0c\n\x04\x04*\x02\0\x12\x04\
    \xb2\x05\x02\x12\n\r\n\x05\x04*\x02\0\x05\x12\x04\xb2\x05\x02\x08\n\r\n\
    \x05\x04*\x02\0\x01\x12\x04\xb2\x05\t\r\n\r\n\x05\x04*\x02\0\x03\x12\x04\
    \xb2\x05\x10\x11\n\x0c\n\x04\x04*\x02\x01\x12\x04\xb3\x05\x02\x12\n\r\n\
    \x05\x04*\x02\x01\x05\x12\x04\xb3\x05\x02\t\n\r\n\x05\x04*\x02\x01\x01\
    \x12\x04\xb3\x05\n\r\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xb3\x05\x10\x11\
    \n\x0c\n\x04\x04*\x02\x02\x12\x04\xb4\x05\x021\n\r\n\x05\x04*\x02\x02\
    \x04\x12\x04\xb4\x05\x02\n\n\r\n\x05\x04*\x02\x02\x06\x12\x04\xb4\x05\
    \x0b'\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xb4\x05(,\n\r\n\x05\x04*\x02\
    \x02\x03\x12\x04\xb4\x05/0\n\x0c\n\x02\x04+\x12\x06\xb6\x05\0\xc1\x05\
    \x01\n\x0b\n\x03\x04+\x01\x12\x04\xb6\x05\x08\x1e\n\x0c\n\x04\x04+\x02\0\
    \x12\x04\xb7\x05\x02\x11\n\r\n\x05\x04+\x02\0\x05\x12\x04\xb7\x05\x02\
    \x06\n\r\n\x05\x04+\x02\0\x01\x12\x04\xb7\x05\x07\x0c\n\r\n\x05\x04+\x02\
    \0\x03\x12\x04\xb7\x05\x0f\x10\n\x0c\n\x04\x04+\x02\x01\x12\x04\xb8\x05\
    \x02\x17\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xb8\x05\x02\x07\n\r\n\x05\
    \x04+\x02\x01\x01\x12\x04\xb8\x05\x08\x12\n\r\n\x05\x04+\x02\x01\x03\x12\
    \x04\xb8\x05\x15\x16\n\x0c\n\x04\x04+\x02\x02\x12\x04\xb9\x05\x02\x13\n\
    \r\n\x05\x04+\x02\x02\x05\x12\x04\xb9\x05\x02\x07\n\r\n\x05\x04+\x02\x02\
    \x01\x12\x04\xb9\x05\x08\x0e\n\r\n\x05\x04+\x02\x02\x03\x12\x04\xb9\x05\
    \x11\x12\n\x0c\n\x04\x04+\x02\x03\x12\x04\xba\x05\x02\x15\n\r\n\x05\x04+\
    \x02\x03\x05\x12\x04\xba\x05\x02\x08\n\r\n\x05\x04+\x02\x03\x01\x12\x04\
    \xba\x05\t\x10\n\r\n\x05\x04+\x02\x03\x03\x12\x04\xba\x05\x13\x14\n?\n\
    \x04\x04+\x02\x04\x12\x04\xbc\x05\x02\x12\x1a1\x20ESPHome\x201.14\x20(ap\
    i\x20v1.3)\x20make\x20int\x20a\x20signed\x20value\n\n\r\n\x05\x04+\x02\
    \x04\x05\x12\x04\xbc\x05\x02\x08\n\r\n\x05\x04+\x02\x04\x01\x12\x04\xbc\
    \x05\t\r\n\r\n\x05\x04+\x02\x04\x03\x12\x04\xbc\x05\x10\x11\n\x0c\n\x04\
    \x04+\x02\x05\x12\x04\xbd\x05\x02.\n\r\n\x05\x04+\x02\x05\x04\x12\x04\
    \xbd\x05\x02\n\n\r\n\x05\x04+\x02\x05\x05\x12\x04\xbd\x05\x0b\x0f\n\r\n\
    \x05\x04+\x02\x05\x01\x12\x04\xbd\x05\x10\x1a\n\r\n\x05\x04+\x02\x05\x03\
    \x12\x04\xbd\x05\x1d\x1e\n\r\n\x05\x04+\x02\x05\x08\x12\x04\xbd\x05\x1f-\
    \n\x0e\n\x06\x04+\x02\x05\x08\x02\x12\x04\xbd\x05\x20,\n\x0c\n\x04\x04+\
    \x02\x06\x12\x04\xbe\x05\x02/\n\r\n\x05\x04+\x02\x06\x04\x12\x04\xbe\x05\
    \x02\n\n\r\n\x05\x04+\x02\x06\x05\x12\x04\xbe\x05\x0b\x11\n\r\n\x05\x04+\
    \x02\x06\x01\x12\x04\xbe\x05\x12\x1b\n\r\n\x05\x04+\x02\x06\x03\x12\x04\
    \xbe\x05\x1e\x1f\n\r\n\x05\x04+\x02\x06\x08\x12\x04\xbe\x05\x20.\n\x0e\n\
    \x06\x04+\x02\x06\x08\x02\x12\x04\xbe\x05!-\n\x0c\n\x04\x04+\x02\x07\x12\
    \x04\xbf\x05\x020\n\r\n\x05\x04+\x02\x07\x04\x12\x04\xbf\x05\x02\n\n\r\n\
    \x05\x04+\x02\x07\x05\x12\x04\xbf\x05\x0b\x10\n\r\n\x05\x04+\x02\x07\x01\
    \x12\x04\xbf\x05\x11\x1c\n\r\n\x05\x04+\x02\x07\x03\x12\x04\xbf\x05\x1f\
    \x20\n\r\n\x05\x04+\x02\x07\x08\x12\x04\xbf\x05!/\n\x0e\n\x06\x04+\x02\
    \x07\x08\x02\x12\x04\xbf\x05\".\n\x0c\n\x04\x04+\x02\x08\x12\x04\xc0\x05\
    \x02#\n\r\n\x05\x04+\x02\x08\x04\x12\x04\xc0\x05\x02\n\n\r\n\x05\x04+\
    \x02\x08\x05\x12\x04\xc0\x05\x0b\x11\n\r\n\x05\x04+\x02\x08\x01\x12\x04\
    \xc0\x05\x12\x1e\n\r\n\x05\x04+\x02\x08\x03\x12\x04\xc0\x05!\"\n\x0c\n\
    \x02\x04,\x12\x06\xc2\x05\0\xc9\x05\x01\n\x0b\n\x03\x04,\x01\x12\x04\xc2\
    \x05\x08\x1d\n\x0b\n\x03\x04,\x07\x12\x04\xc3\x05\x02\x13\n\r\n\x05\x04,\
    \x07\x8c\x08\x12\x04\xc3\x05\x02\x13\n\x0b\n\x03\x04,\x07\x12\x04\xc4\
    \x05\x02\"\n\r\n\x05\x04,\x07\x8d\x08\x12\x04\xc4\x05\x02\"\n\x0b\n\x03\
    \x04,\x07\x12\x04\xc5\x05\x02\x1b\n\r\n\x05\x04,\x07\x90\x08\x12\x04\xc5\
    \x05\x02\x1b\n\x0c\n\x04\x04,\x02\0\x12\x04\xc7\x05\x02\x12\n\r\n\x05\
    \x04,\x02\0\x05\x12\x04\xc7\x05\x02\t\n\r\n\x05\x04,\x02\0\x01\x12\x04\
    \xc7\x05\n\r\n\r\n\x05\x04,\x02\0\x03\x12\x04\xc7\x05\x10\x11\n\x0c\n\
    \x04\x04,\x02\x01\x12\x04\xc8\x05\x02+\n\r\n\x05\x04,\x02\x01\x04\x12\
    \x04\xc8\x05\x02\n\n\r\n\x05\x04,\x02\x01\x06\x12\x04\xc8\x05\x0b!\n\r\n\
    \x05\x04,\x02\x01\x01\x12\x04\xc8\x05\"&\n\r\n\x05\x04,\x02\x01\x03\x12\
    \x04\xc8\x05)*\n@\n\x02\x04-\x12\x06\xcc\x05\0\xd8\x05\x01\x1a2\x20=====\
    ===============\x20CAMERA\x20====================\n\n\x0b\n\x03\x04-\x01\
    \x12\x04\xcc\x05\x08\"\n\x0b\n\x03\x04-\x07\x12\x04\xcd\x05\x02\x13\n\r\
    \n\x05\x04-\x07\x8c\x08\x12\x04\xcd\x05\x02\x13\n\x0b\n\x03\x04-\x07\x12\
    \x04\xce\x05\x02\"\n\r\n\x05\x04-\x07\x8d\x08\x12\x04\xce\x05\x02\"\n\
    \x0b\n\x03\x04-\x07\x12\x04\xcf\x05\x02&\n\r\n\x05\x04-\x07\x8e\x08\x12\
    \x04\xcf\x05\x02&\n\x0c\n\x04\x04-\x02\0\x12\x04\xd1\x05\x02\x17\n\r\n\
    \x05\x04-\x02\0\x05\x12\x04\xd1\x05\x02\x08\n\r\n\x05\x04-\x02\0\x01\x12\
    \x04\xd1\x05\t\x12\n\r\n\x05\x04-\x02\0\x03\x12\x04\xd1\x05\x15\x16\n\
    \x0c\n\x04\x04-\x02\x01\x12\x04\xd2\x05\x02\x12\n\r\n\x05\x04-\x02\x01\
    \x05\x12\x04\xd2\x05\x02\t\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xd2\x05\n\
    \r\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xd2\x05\x10\x11\n\x0c\n\x04\x04-\
    \x02\x02\x12\x04\xd3\x05\x02\x12\n\r\n\x05\x04-\x02\x02\x05\x12\x04\xd3\
    \x05\x02\x08\n\r\n\x05\x04-\x02\x02\x01\x12\x04\xd3\x05\t\r\n\r\n\x05\
    \x04-\x02\x02\x03\x12\x04\xd3\x05\x10\x11\n\x0c\n\x04\x04-\x02\x03\x12\
    \x04\xd4\x05\x02\x17\n\r\n\x05\x04-\x02\x03\x05\x12\x04\xd4\x05\x02\x08\
    \n\r\n\x05\x04-\x02\x03\x01\x12\x04\xd4\x05\t\x12\n\r\n\x05\x04-\x02\x03\
    \x03\x12\x04\xd4\x05\x15\x16\n\x0c\n\x04\x04-\x02\x04\x12\x04\xd5\x05\
    \x02\x1f\n\r\n\x05\x04-\x02\x04\x05\x12\x04\xd5\x05\x02\x06\n\r\n\x05\
    \x04-\x02\x04\x01\x12\x04\xd5\x05\x07\x1a\n\r\n\x05\x04-\x02\x04\x03\x12\
    \x04\xd5\x05\x1d\x1e\n\x0c\n\x04\x04-\x02\x05\x12\x04\xd6\x05\x02\x12\n\
    \r\n\x05\x04-\x02\x05\x05\x12\x04\xd6\x05\x02\x08\n\r\n\x05\x04-\x02\x05\
    \x01\x12\x04\xd6\x05\t\r\n\r\n\x05\x04-\x02\x05\x03\x12\x04\xd6\x05\x10\
    \x11\n\x0c\n\x04\x04-\x02\x06\x12\x04\xd7\x05\x02%\n\r\n\x05\x04-\x02\
    \x06\x06\x12\x04\xd7\x05\x02\x10\n\r\n\x05\x04-\x02\x06\x01\x12\x04\xd7\
    \x05\x11\x20\n\r\n\x05\x04-\x02\x06\x03\x12\x04\xd7\x05#$\n\x0c\n\x02\
    \x04.\x12\x06\xda\x05\0\xe2\x05\x01\n\x0b\n\x03\x04.\x01\x12\x04\xda\x05\
    \x08\x1b\n\x0b\n\x03\x04.\x07\x12\x04\xdb\x05\x02\x13\n\r\n\x05\x04.\x07\
    \x8c\x08\x12\x04\xdb\x05\x02\x13\n\x0b\n\x03\x04.\x07\x12\x04\xdc\x05\
    \x02\"\n\r\n\x05\x04.\x07\x8d\x08\x12\x04\xdc\x05\x02\"\n\x0b\n\x03\x04.\
    \x07\x12\x04\xdd\x05\x02&\n\r\n\x05\x04.\x07\x8e\x08\x12\x04\xdd\x05\x02\
    &\n\x0c\n\x04\x04.\x02\0\x12\x04\xdf\x05\x02\x12\n\r\n\x05\x04.\x02\0\
    \x05\x12\x04\xdf\x05\x02\t\n\r\n\x05\x04.\x02\0\x01\x12\x04\xdf\x05\n\r\
    \n\r\n\x05\x04.\x02\0\x03\x12\x04\xdf\x05\x10\x11\n\x0c\n\x04\x04.\x02\
    \x01\x12\x04\xe0\x05\x02\x11\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xe0\x05\
    \x02\x07\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xe0\x05\x08\x0c\n\r\n\x05\
    \x04.\x02\x01\x03\x12\x04\xe0\x05\x0f\x10\n\x0c\n\x04\x04.\x02\x02\x12\
    \x04\xe1\x05\x02\x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xe1\x05\x02\x06\
    \n\r\n\x05\x04.\x02\x02\x01\x12\x04\xe1\x05\x07\x0b\n\r\n\x05\x04.\x02\
    \x02\x03\x12\x04\xe1\x05\x0e\x0f\n\x0c\n\x02\x04/\x12\x06\xe3\x05\0\xeb\
    \x05\x01\n\x0b\n\x03\x04/\x01\x12\x04\xe3\x05\x08\x1a\n\x0b\n\x03\x04/\
    \x07\x12\x04\xe4\x05\x02\x13\n\r\n\x05\x04/\x07\x8c\x08\x12\x04\xe4\x05\
    \x02\x13\n\x0b\n\x03\x04/\x07\x12\x04\xe5\x05\x02\"\n\r\n\x05\x04/\x07\
    \x8d\x08\x12\x04\xe5\x05\x02\"\n\x0b\n\x03\x04/\x07\x12\x04\xe6\x05\x02&\
    \n\r\n\x05\x04/\x07\x8e\x08\x12\x04\xe6\x05\x02&\n\x0b\n\x03\x04/\x07\
    \x12\x04\xe7\x05\x02\x1b\n\r\n\x05\x04/\x07\x90\x08\x12\x04\xe7\x05\x02\
    \x1b\n\x0c\n\x04\x04/\x02\0\x12\x04\xe9\x05\x02\x12\n\r\n\x05\x04/\x02\0\
    \x05\x12\x04\xe9\x05\x02\x06\n\r\n\x05\x04/\x02\0\x01\x12\x04\xe9\x05\
    \x07\r\n\r\n\x05\x04/\x02\0\x03\x12\x04\xe9\x05\x10\x11\n\x0c\n\x04\x04/\
    \x02\x01\x12\x04\xea\x05\x02\x12\n\r\n\x05\x04/\x02\x01\x05\x12\x04\xea\
    \x05\x02\x06\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xea\x05\x07\r\n\r\n\x05\
    \x04/\x02\x01\x03\x12\x04\xea\x05\x10\x11\nA\n\x02\x05\x0b\x12\x06\xee\
    \x05\0\xf6\x05\x01\x1a3\x20====================\x20CLIMATE\x20==========\
    ==========\n\n\x0b\n\x03\x05\x0b\x01\x12\x04\xee\x05\x05\x10\n\x0c\n\x04\
    \x05\x0b\x02\0\x12\x04\xef\x05\x02\x17\n\r\n\x05\x05\x0b\x02\0\x01\x12\
    \x04\xef\x05\x02\x12\n\r\n\x05\x05\x0b\x02\0\x02\x12\x04\xef\x05\x15\x16\
    \n\x0c\n\x04\x05\x0b\x02\x01\x12\x04\xf0\x05\x02\x1d\n\r\n\x05\x05\x0b\
    \x02\x01\x01\x12\x04\xf0\x05\x02\x18\n\r\n\x05\x05\x0b\x02\x01\x02\x12\
    \x04\xf0\x05\x1b\x1c\n\x0c\n\x04\x05\x0b\x02\x02\x12\x04\xf1\x05\x02\x18\
    \n\r\n\x05\x05\x0b\x02\x02\x01\x12\x04\xf1\x05\x02\x13\n\r\n\x05\x05\x0b\
    \x02\x02\x02\x12\x04\xf1\x05\x16\x17\n\x0c\n\x04\x05\x0b\x02\x03\x12\x04\
    \xf2\x05\x02\x18\n\r\n\x05\x05\x0b\x02\x03\x01\x12\x04\xf2\x05\x02\x13\n\
    \r\n\x05\x05\x0b\x02\x03\x02\x12\x04\xf2\x05\x16\x17\n\x0c\n\x04\x05\x0b\
    \x02\x04\x12\x04\xf3\x05\x02\x1c\n\r\n\x05\x05\x0b\x02\x04\x01\x12\x04\
    \xf3\x05\x02\x17\n\r\n\x05\x05\x0b\x02\x04\x02\x12\x04\xf3\x05\x1a\x1b\n\
    \x0c\n\x04\x05\x0b\x02\x05\x12\x04\xf4\x05\x02\x17\n\r\n\x05\x05\x0b\x02\
    \x05\x01\x12\x04\xf4\x05\x02\x12\n\r\n\x05\x05\x0b\x02\x05\x02\x12\x04\
    \xf4\x05\x15\x16\n\x0c\n\x04\x05\x0b\x02\x06\x12\x04\xf5\x05\x02\x18\n\r\
    \n\x05\x05\x0b\x02\x06\x01\x12\x04\xf5\x05\x02\x13\n\r\n\x05\x05\x0b\x02\
    \x06\x02\x12\x04\xf5\x05\x16\x17\n\x0c\n\x02\x05\x0c\x12\x06\xf7\x05\0\
    \x81\x06\x01\n\x0b\n\x03\x05\x0c\x01\x12\x04\xf7\x05\x05\x13\n\x0c\n\x04\
    \x05\x0c\x02\0\x12\x04\xf8\x05\x02\x15\n\r\n\x05\x05\x0c\x02\0\x01\x12\
    \x04\xf8\x05\x02\x10\n\r\n\x05\x05\x0c\x02\0\x02\x12\x04\xf8\x05\x13\x14\
    \n\x0c\n\x04\x05\x0c\x02\x01\x12\x04\xf9\x05\x02\x16\n\r\n\x05\x05\x0c\
    \x02\x01\x01\x12\x04\xf9\x05\x02\x11\n\r\n\x05\x05\x0c\x02\x01\x02\x12\
    \x04\xf9\x05\x14\x15\n\x0c\n\x04\x05\x0c\x02\x02\x12\x04\xfa\x05\x02\x17\
    \n\r\n\x05\x05\x0c\x02\x02\x01\x12\x04\xfa\x05\x02\x12\n\r\n\x05\x05\x0c\
    \x02\x02\x02\x12\x04\xfa\x05\x15\x16\n\x0c\n\x04\x05\x0c\x02\x03\x12\x04\
    \xfb\x05\x02\x16\n\r\n\x05\x05\x0c\x02\x03\x01\x12\x04\xfb\x05\x02\x11\n\
    \r\n\x05\x05\x0c\x02\x03\x02\x12\x04\xfb\x05\x14\x15\n\x0c\n\x04\x05\x0c\
    \x02\x04\x12\x04\xfc\x05\x02\x19\n\r\n\x05\x05\x0c\x02\x04\x01\x12\x04\
    \xfc\x05\x02\x14\n\r\n\x05\x05\x0c\x02\x04\x02\x12\x04\xfc\x05\x17\x18\n\
    \x0c\n\x04\x05\x0c\x02\x05\x12\x04\xfd\x05\x02\x17\n\r\n\x05\x05\x0c\x02\
    \x05\x01\x12\x04\xfd\x05\x02\x12\n\r\n\x05\x05\x0c\x02\x05\x02\x12\x04\
    \xfd\x05\x15\x16\n\x0c\n\x04\x05\x0c\x02\x06\x12\x04\xfe\x05\x02\x19\n\r\
    \n\x05\x05\x0c\x02\x06\x01\x12\x04\xfe\x05\x02\x14\n\r\n\x05\x05\x0c\x02\
    \x06\x02\x12\x04\xfe\x05\x17\x18\n\x0c\n\x04\x05\x0c\x02\x07\x12\x04\xff\
    \x05\x02\x18\n\r\n\x05\x05\x0c\x02\x07\x01\x12\x04\xff\x05\x02\x13\n\r\n\
    \x05\x05\x0c\x02\x07\x02\x12\x04\xff\x05\x16\x17\n\x0c\n\x04\x05\x0c\x02\
    \x08\x12\x04\x80\x06\x02\x1a\n\r\n\x05\x05\x0c\x02\x08\x01\x12\x04\x80\
    \x06\x02\x15\n\r\n\x05\x05\x0c\x02\x08\x02\x12\x04\x80\x06\x18\x19\n\x0c\
    \n\x02\x05\r\x12\x06\x82\x06\0\x87\x06\x01\n\x0b\n\x03\x05\r\x01\x12\x04\
    \x82\x06\x05\x15\n\x0c\n\x04\x05\r\x02\0\x12\x04\x83\x06\x02\x18\n\r\n\
    \x05\x05\r\x02\0\x01\x12\x04\x83\x06\x02\x13\n\r\n\x05\x05\r\x02\0\x02\
    \x12\x04\x83\x06\x16\x17\n\x0c\n\x04\x05\r\x02\x01\x12\x04\x84\x06\x02\
    \x19\n\r\n\x05\x05\r\x02\x01\x01\x12\x04\x84\x06\x02\x14\n\r\n\x05\x05\r\
    \x02\x01\x02\x12\x04\x84\x06\x17\x18\n\x0c\n\x04\x05\r\x02\x02\x12\x04\
    \x85\x06\x02\x1d\n\r\n\x05\x05\r\x02\x02\x01\x12\x04\x85\x06\x02\x18\n\r\
    \n\x05\x05\r\x02\x02\x02\x12\x04\x85\x06\x1b\x1c\n\x0c\n\x04\x05\r\x02\
    \x03\x12\x04\x86\x06\x02\x1f\n\r\n\x05\x05\r\x02\x03\x01\x12\x04\x86\x06\
    \x02\x1a\n\r\n\x05\x05\r\x02\x03\x02\x12\x04\x86\x06\x1d\x1e\n\x0c\n\x02\
    \x05\x0e\x12\x06\x88\x06\0\x90\x06\x01\n\x0b\n\x03\x05\x0e\x01\x12\x04\
    \x88\x06\x05\x12\n\x0c\n\x04\x05\x0e\x02\0\x12\x04\x89\x06\x02\x19\n\r\n\
    \x05\x05\x0e\x02\0\x01\x12\x04\x89\x06\x02\x14\n\r\n\x05\x05\x0e\x02\0\
    \x02\x12\x04\x89\x06\x17\x18\n3\n\x04\x05\x0e\x02\x01\x12\x04\x8b\x06\
    \x02\x1d\x1a%\x20values\x20same\x20as\x20mode\x20for\x20readability\n\n\
    \r\n\x05\x05\x0e\x02\x01\x01\x12\x04\x8b\x06\x02\x18\n\r\n\x05\x05\x0e\
    \x02\x01\x02\x12\x04\x8b\x06\x1b\x1c\n\x0c\n\x04\x05\x0e\x02\x02\x12\x04\
    \x8c\x06\x02\x1d\n\r\n\x05\x05\x0e\x02\x02\x01\x12\x04\x8c\x06\x02\x18\n\
    \r\n\x05\x05\x0e\x02\x02\x02\x12\x04\x8c\x06\x1b\x1c\n\x0c\n\x04\x05\x0e\
    \x02\x03\x12\x04\x8d\x06\x02\x1a\n\r\n\x05\x05\x0e\x02\x03\x01\x12\x04\
    \x8d\x06\x02\x15\n\r\n\x05\x05\x0e\x02\x03\x02\x12\x04\x8d\x06\x18\x19\n\
    \x0c\n\x04\x05\x0e\x02\x04\x12\x04\x8e\x06\x02\x1c\n\r\n\x05\x05\x0e\x02\
    \x04\x01\x12\x04\x8e\x06\x02\x17\n\r\n\x05\x05\x0e\x02\x04\x02\x12\x04\
    \x8e\x06\x1a\x1b\n\x0c\n\x04\x05\x0e\x02\x05\x12\x04\x8f\x06\x02\x19\n\r\
    \n\x05\x05\x0e\x02\x05\x01\x12\x04\x8f\x06\x02\x14\n\r\n\x05\x05\x0e\x02\
    \x05\x02\x12\x04\x8f\x06\x17\x18\n\x0c\n\x02\x05\x0f\x12\x06\x91\x06\0\
    \x9a\x06\x01\n\x0b\n\x03\x05\x0f\x01\x12\x04\x91\x06\x05\x12\n\x0c\n\x04\
    \x05\x0f\x02\0\x12\x04\x92\x06\x02\x1a\n\r\n\x05\x05\x0f\x02\0\x01\x12\
    \x04\x92\x06\x02\x15\n\r\n\x05\x05\x0f\x02\0\x02\x12\x04\x92\x06\x18\x19\
    \n\x0c\n\x04\x05\x0f\x02\x01\x12\x04\x93\x06\x02\x1a\n\r\n\x05\x05\x0f\
    \x02\x01\x01\x12\x04\x93\x06\x02\x15\n\r\n\x05\x05\x0f\x02\x01\x02\x12\
    \x04\x93\x06\x18\x19\n\x0c\n\x04\x05\x0f\x02\x02\x12\x04\x94\x06\x02\x1a\
    \n\r\n\x05\x05\x0f\x02\x02\x01\x12\x04\x94\x06\x02\x15\n\r\n\x05\x05\x0f\
    \x02\x02\x02\x12\x04\x94\x06\x18\x19\n\x0c\n\x04\x05\x0f\x02\x03\x12\x04\
    \x95\x06\x02\x1b\n\r\n\x05\x05\x0f\x02\x03\x01\x12\x04\x95\x06\x02\x16\n\
    \r\n\x05\x05\x0f\x02\x03\x02\x12\x04\x95\x06\x19\x1a\n\x0c\n\x04\x05\x0f\
    \x02\x04\x12\x04\x96\x06\x02\x1d\n\r\n\x05\x05\x0f\x02\x04\x01\x12\x04\
    \x96\x06\x02\x18\n\r\n\x05\x05\x0f\x02\x04\x02\x12\x04\x96\x06\x1b\x1c\n\
    \x0c\n\x04\x05\x0f\x02\x05\x12\x04\x97\x06\x02\x19\n\r\n\x05\x05\x0f\x02\
    \x05\x01\x12\x04\x97\x06\x02\x14\n\r\n\x05\x05\x0f\x02\x05\x02\x12\x04\
    \x97\x06\x17\x18\n\x0c\n\x04\x05\x0f\x02\x06\x12\x04\x98\x06\x02\x1b\n\r\
    \n\x05\x05\x0f\x02\x06\x01\x12\x04\x98\x06\x02\x16\n\r\n\x05\x05\x0f\x02\
    \x06\x02\x12\x04\x98\x06\x19\x1a\n\x0c\n\x04\x05\x0f\x02\x07\x12\x04\x99\
    \x06\x02\x1e\n\r\n\x05\x05\x0f\x02\x07\x01\x12\x04\x99\x06\x02\x19\n\r\n\
    \x05\x05\x0f\x02\x07\x02\x12\x04\x99\x06\x1c\x1d\n\x0c\n\x02\x040\x12\
    \x06\x9b\x06\0\xb7\x06\x01\n\x0b\n\x03\x040\x01\x12\x04\x9b\x06\x08#\n\
    \x0b\n\x03\x040\x07\x12\x04\x9c\x06\x02\x13\n\r\n\x05\x040\x07\x8c\x08\
    \x12\x04\x9c\x06\x02\x13\n\x0b\n\x03\x040\x07\x12\x04\x9d\x06\x02\"\n\r\
    \n\x05\x040\x07\x8d\x08\x12\x04\x9d\x06\x02\"\n\x0b\n\x03\x040\x07\x12\
    \x04\x9e\x06\x02!\n\r\n\x05\x040\x07\x8e\x08\x12\x04\x9e\x06\x02!\n\x0c\
    \n\x04\x040\x02\0\x12\x04\xa0\x06\x02\x17\n\r\n\x05\x040\x02\0\x05\x12\
    \x04\xa0\x06\x02\x08\n\r\n\x05\x040\x02\0\x01\x12\x04\xa0\x06\t\x12\n\r\
    \n\x05\x040\x02\0\x03\x12\x04\xa0\x06\x15\x16\n\x0c\n\x04\x040\x02\x01\
    \x12\x04\xa1\x06\x02\x12\n\r\n\x05\x040\x02\x01\x05\x12\x04\xa1\x06\x02\
    \t\n\r\n\x05\x040\x02\x01\x01\x12\x04\xa1\x06\n\r\n\r\n\x05\x040\x02\x01\
    \x03\x12\x04\xa1\x06\x10\x11\n\x0c\n\x04\x040\x02\x02\x12\x04\xa2\x06\
    \x02\x12\n\r\n\x05\x040\x02\x02\x05\x12\x04\xa2\x06\x02\x08\n\r\n\x05\
    \x040\x02\x02\x01\x12\x04\xa2\x06\t\r\n\r\n\x05\x040\x02\x02\x03\x12\x04\
    \xa2\x06\x10\x11\n\x0c\n\x04\x040\x02\x03\x12\x04\xa3\x06\x02\x17\n\r\n\
    \x05\x040\x02\x03\x05\x12\x04\xa3\x06\x02\x08\n\r\n\x05\x040\x02\x03\x01\
    \x12\x04\xa3\x06\t\x12\n\r\n\x05\x040\x02\x03\x03\x12\x04\xa3\x06\x15\
    \x16\n\x0c\n\x04\x040\x02\x04\x12\x04\xa5\x06\x02(\n\r\n\x05\x040\x02\
    \x04\x05\x12\x04\xa5\x06\x02\x06\n\r\n\x05\x040\x02\x04\x01\x12\x04\xa5\
    \x06\x07#\n\r\n\x05\x040\x02\x04\x03\x12\x04\xa5\x06&'\n\x0c\n\x04\x040\
    \x02\x05\x12\x04\xa6\x06\x021\n\r\n\x05\x040\x02\x05\x05\x12\x04\xa6\x06\
    \x02\x06\n\r\n\x05\x040\x02\x05\x01\x12\x04\xa6\x06\x07,\n\r\n\x05\x040\
    \x02\x05\x03\x12\x04\xa6\x06/0\n\x0c\n\x04\x040\x02\x06\x12\x04\xa7\x06\
    \x02+\n\r\n\x05\x040\x02\x06\x04\x12\x04\xa7\x06\x02\n\n\r\n\x05\x040\
    \x02\x06\x06\x12\x04\xa7\x06\x0b\x16\n\r\n\x05\x040\x02\x06\x01\x12\x04\
    \xa7\x06\x17&\n\r\n\x05\x040\x02\x06\x03\x12\x04\xa7\x06)*\n\x0c\n\x04\
    \x040\x02\x07\x12\x04\xa8\x06\x02#\n\r\n\x05\x040\x02\x07\x05\x12\x04\
    \xa8\x06\x02\x07\n\r\n\x05\x040\x02\x07\x01\x12\x04\xa8\x06\x08\x1e\n\r\
    \n\x05\x040\x02\x07\x03\x12\x04\xa8\x06!\"\n\x0c\n\x04\x040\x02\x08\x12\
    \x04\xa9\x06\x02#\n\r\n\x05\x040\x02\x08\x05\x12\x04\xa9\x06\x02\x07\n\r\
    \n\x05\x040\x02\x08\x01\x12\x04\xa9\x06\x08\x1e\n\r\n\x05\x040\x02\x08\
    \x03\x12\x04\xa9\x06!\"\n\x0c\n\x04\x040\x02\t\x12\x04\xaa\x06\x02%\n\r\
    \n\x05\x040\x02\t\x05\x12\x04\xaa\x06\x02\x07\n\r\n\x05\x040\x02\t\x01\
    \x12\x04\xaa\x06\x08\x1f\n\r\n\x05\x040\x02\t\x03\x12\x04\xaa\x06\"$\ns\
    \n\x04\x040\x02\n\x12\x04\xad\x06\x02!\x1ae\x20for\x20older\x20peer\x20v\
    ersions\x20-\x20in\x20new\x20system\x20this\n\x20is\x20if\x20CLIMATE_PRE\
    SET_AWAY\x20exists\x20is\x20supported_presets\n\n\r\n\x05\x040\x02\n\x05\
    \x12\x04\xad\x06\x02\x06\n\r\n\x05\x040\x02\n\x01\x12\x04\xad\x06\x07\
    \x1b\n\r\n\x05\x040\x02\n\x03\x12\x04\xad\x06\x1e\x20\n\x0c\n\x04\x040\
    \x02\x0b\x12\x04\xae\x06\x02\x1c\n\r\n\x05\x040\x02\x0b\x05\x12\x04\xae\
    \x06\x02\x06\n\r\n\x05\x040\x02\x0b\x01\x12\x04\xae\x06\x07\x16\n\r\n\
    \x05\x040\x02\x0b\x03\x12\x04\xae\x06\x19\x1b\n\x0c\n\x04\x040\x02\x0c\
    \x12\x04\xaf\x06\x023\n\r\n\x05\x040\x02\x0c\x04\x12\x04\xaf\x06\x02\n\n\
    \r\n\x05\x040\x02\x0c\x06\x12\x04\xaf\x06\x0b\x19\n\r\n\x05\x040\x02\x0c\
    \x01\x12\x04\xaf\x06\x1a-\n\r\n\x05\x040\x02\x0c\x03\x12\x04\xaf\x0602\n\
    \x0c\n\x04\x040\x02\r\x12\x04\xb0\x06\x027\n\r\n\x05\x040\x02\r\x04\x12\
    \x04\xb0\x06\x02\n\n\r\n\x05\x040\x02\r\x06\x12\x04\xb0\x06\x0b\x1b\n\r\
    \n\x05\x040\x02\r\x01\x12\x04\xb0\x06\x1c1\n\r\n\x05\x040\x02\r\x03\x12\
    \x04\xb0\x0646\n\x0c\n\x04\x040\x02\x0e\x12\x04\xb1\x06\x022\n\r\n\x05\
    \x040\x02\x0e\x04\x12\x04\xb1\x06\x02\n\n\r\n\x05\x040\x02\x0e\x05\x12\
    \x04\xb1\x06\x0b\x11\n\r\n\x05\x040\x02\x0e\x01\x12\x04\xb1\x06\x12,\n\r\
    \n\x05\x040\x02\x0e\x03\x12\x04\xb1\x06/1\n\x0c\n\x04\x040\x02\x0f\x12\
    \x04\xb2\x06\x020\n\r\n\x05\x040\x02\x0f\x04\x12\x04\xb2\x06\x02\n\n\r\n\
    \x05\x040\x02\x0f\x06\x12\x04\xb2\x06\x0b\x18\n\r\n\x05\x040\x02\x0f\x01\
    \x12\x04\xb2\x06\x19*\n\r\n\x05\x040\x02\x0f\x03\x12\x04\xb2\x06-/\n\x0c\
    \n\x04\x040\x02\x10\x12\x04\xb3\x06\x020\n\r\n\x05\x040\x02\x10\x04\x12\
    \x04\xb3\x06\x02\n\n\r\n\x05\x040\x02\x10\x05\x12\x04\xb3\x06\x0b\x11\n\
    \r\n\x05\x040\x02\x10\x01\x12\x04\xb3\x06\x12*\n\r\n\x05\x040\x02\x10\
    \x03\x12\x04\xb3\x06-/\n\x0c\n\x04\x040\x02\x11\x12\x04\xb4\x06\x02\x20\
    \n\r\n\x05\x040\x02\x11\x05\x12\x04\xb4\x06\x02\x06\n\r\n\x05\x040\x02\
    \x11\x01\x12\x04\xb4\x06\x07\x1a\n\r\n\x05\x040\x02\x11\x03\x12\x04\xb4\
    \x06\x1d\x1f\n\x0c\n\x04\x040\x02\x12\x12\x04\xb5\x06\x02\x13\n\r\n\x05\
    \x040\x02\x12\x05\x12\x04\xb5\x06\x02\x08\n\r\n\x05\x040\x02\x12\x01\x12\
    \x04\xb5\x06\t\r\n\r\n\x05\x040\x02\x12\x03\x12\x04\xb5\x06\x10\x12\n\
    \x0c\n\x04\x040\x02\x13\x12\x04\xb6\x06\x02&\n\r\n\x05\x040\x02\x13\x06\
    \x12\x04\xb6\x06\x02\x10\n\r\n\x05\x040\x02\x13\x01\x12\x04\xb6\x06\x11\
    \x20\n\r\n\x05\x040\x02\x13\x03\x12\x04\xb6\x06#%\n\x0c\n\x02\x041\x12\
    \x06\xb8\x06\0\xcc\x06\x01\n\x0b\n\x03\x041\x01\x12\x04\xb8\x06\x08\x1c\
    \n\x0b\n\x03\x041\x07\x12\x04\xb9\x06\x02\x13\n\r\n\x05\x041\x07\x8c\x08\
    \x12\x04\xb9\x06\x02\x13\n\x0b\n\x03\x041\x07\x12\x04\xba\x06\x02\"\n\r\
    \n\x05\x041\x07\x8d\x08\x12\x04\xba\x06\x02\"\n\x0b\n\x03\x041\x07\x12\
    \x04\xbb\x06\x02!\n\r\n\x05\x041\x07\x8e\x08\x12\x04\xbb\x06\x02!\n\x0b\
    \n\x03\x041\x07\x12\x04\xbc\x06\x02\x1b\n\r\n\x05\x041\x07\x90\x08\x12\
    \x04\xbc\x06\x02\x1b\n\x0c\n\x04\x041\x02\0\x12\x04\xbe\x06\x02\x12\n\r\
    \n\x05\x041\x02\0\x05\x12\x04\xbe\x06\x02\t\n\r\n\x05\x041\x02\0\x01\x12\
    \x04\xbe\x06\n\r\n\r\n\x05\x041\x02\0\x03\x12\x04\xbe\x06\x10\x11\n\x0c\
    \n\x04\x041\x02\x01\x12\x04\xbf\x06\x02\x17\n\r\n\x05\x041\x02\x01\x06\
    \x12\x04\xbf\x06\x02\r\n\r\n\x05\x041\x02\x01\x01\x12\x04\xbf\x06\x0e\
    \x12\n\r\n\x05\x041\x02\x01\x03\x12\x04\xbf\x06\x15\x16\n\x0c\n\x04\x041\
    \x02\x02\x12\x04\xc0\x06\x02\x20\n\r\n\x05\x041\x02\x02\x05\x12\x04\xc0\
    \x06\x02\x07\n\r\n\x05\x041\x02\x02\x01\x12\x04\xc0\x06\x08\x1b\n\r\n\
    \x05\x041\x02\x02\x03\x12\x04\xc0\x06\x1e\x1f\n\x0c\n\x04\x041\x02\x03\
    \x12\x04\xc1\x06\x02\x1f\n\r\n\x05\x041\x02\x03\x05\x12\x04\xc1\x06\x02\
    \x07\n\r\n\x05\x041\x02\x03\x01\x12\x04\xc1\x06\x08\x1a\n\r\n\x05\x041\
    \x02\x03\x03\x12\x04\xc1\x06\x1d\x1e\n\x0c\n\x04\x041\x02\x04\x12\x04\
    \xc2\x06\x02#\n\r\n\x05\x041\x02\x04\x05\x12\x04\xc2\x06\x02\x07\n\r\n\
    \x05\x041\x02\x04\x01\x12\x04\xc2\x06\x08\x1e\n\r\n\x05\x041\x02\x04\x03\
    \x12\x04\xc2\x06!\"\n\x0c\n\x04\x041\x02\x05\x12\x04\xc3\x06\x02$\n\r\n\
    \x05\x041\x02\x05\x05\x12\x04\xc3\x06\x02\x07\n\r\n\x05\x041\x02\x05\x01\
    \x12\x04\xc3\x06\x08\x1f\n\r\n\x05\x041\x02\x05\x03\x12\x04\xc3\x06\"#\n\
    G\n\x04\x041\x02\x06\x12\x04\xc5\x06\x02\x17\x1a9\x20For\x20older\x20pee\
    rs,\x20equal\x20to\x20preset\x20==\x20CLIMATE_PRESET_AWAY\n\n\r\n\x05\
    \x041\x02\x06\x05\x12\x04\xc5\x06\x02\x06\n\r\n\x05\x041\x02\x06\x01\x12\
    \x04\xc5\x06\x07\x12\n\r\n\x05\x041\x02\x06\x03\x12\x04\xc5\x06\x15\x16\
    \n\x0c\n\x04\x041\x02\x07\x12\x04\xc6\x06\x02\x1b\n\r\n\x05\x041\x02\x07\
    \x06\x12\x04\xc6\x06\x02\x0f\n\r\n\x05\x041\x02\x07\x01\x12\x04\xc6\x06\
    \x10\x16\n\r\n\x05\x041\x02\x07\x03\x12\x04\xc6\x06\x19\x1a\n\x0c\n\x04\
    \x041\x02\x08\x12\x04\xc7\x06\x02\x1e\n\r\n\x05\x041\x02\x08\x06\x12\x04\
    \xc7\x06\x02\x10\n\r\n\x05\x041\x02\x08\x01\x12\x04\xc7\x06\x11\x19\n\r\
    \n\x05\x041\x02\x08\x03\x12\x04\xc7\x06\x1c\x1d\n\x0c\n\x04\x041\x02\t\
    \x12\x04\xc8\x06\x02#\n\r\n\x05\x041\x02\t\x06\x12\x04\xc8\x06\x02\x12\n\
    \r\n\x05\x041\x02\t\x01\x12\x04\xc8\x06\x13\x1d\n\r\n\x05\x041\x02\t\x03\
    \x12\x04\xc8\x06\x20\"\n\x0c\n\x04\x041\x02\n\x12\x04\xc9\x06\x02\x1e\n\
    \r\n\x05\x041\x02\n\x05\x12\x04\xc9\x06\x02\x08\n\r\n\x05\x041\x02\n\x01\
    \x12\x04\xc9\x06\t\x18\n\r\n\x05\x041\x02\n\x03\x12\x04\xc9\x06\x1b\x1d\
    \n\x0c\n\x04\x041\x02\x0b\x12\x04\xca\x06\x02\x1c\n\r\n\x05\x041\x02\x0b\
    \x06\x12\x04\xca\x06\x02\x0f\n\r\n\x05\x041\x02\x0b\x01\x12\x04\xca\x06\
    \x10\x16\n\r\n\x05\x041\x02\x0b\x03\x12\x04\xca\x06\x19\x1b\n\x0c\n\x04\
    \x041\x02\x0c\x12\x04\xcb\x06\x02\x1c\n\r\n\x05\x041\x02\x0c\x05\x12\x04\
    \xcb\x06\x02\x08\n\r\n\x05\x041\x02\x0c\x01\x12\x04\xcb\x06\t\x16\n\r\n\
    \x05\x041\x02\x0c\x03\x12\x04\xcb\x06\x19\x1b\n\x0c\n\x02\x042\x12\x06\
    \xcd\x06\0\xe9\x06\x01\n\x0b\n\x03\x042\x01\x12\x04\xcd\x06\x08\x1d\n\
    \x0b\n\x03\x042\x07\x12\x04\xce\x06\x02\x13\n\r\n\x05\x042\x07\x8c\x08\
    \x12\x04\xce\x06\x02\x13\n\x0b\n\x03\x042\x07\x12\x04\xcf\x06\x02\"\n\r\
    \n\x05\x042\x07\x8d\x08\x12\x04\xcf\x06\x02\"\n\x0b\n\x03\x042\x07\x12\
    \x04\xd0\x06\x02!\n\r\n\x05\x042\x07\x8e\x08\x12\x04\xd0\x06\x02!\n\x0b\
    \n\x03\x042\x07\x12\x04\xd1\x06\x02\x1b\n\r\n\x05\x042\x07\x90\x08\x12\
    \x04\xd1\x06\x02\x1b\n\x0c\n\x04\x042\x02\0\x12\x04\xd3\x06\x02\x12\n\r\
    \n\x05\x042\x02\0\x05\x12\x04\xd3\x06\x02\t\n\r\n\x05\x042\x02\0\x01\x12\
    \x04\xd3\x06\n\r\n\r\n\x05\x042\x02\0\x03\x12\x04\xd3\x06\x10\x11\n\x0c\
    \n\x04\x042\x02\x01\x12\x04\xd4\x06\x02\x14\n\r\n\x05\x042\x02\x01\x05\
    \x12\x04\xd4\x06\x02\x06\n\r\n\x05\x042\x02\x01\x01\x12\x04\xd4\x06\x07\
    \x0f\n\r\n\x05\x042\x02\x01\x03\x12\x04\xd4\x06\x12\x13\n\x0c\n\x04\x042\
    \x02\x02\x12\x04\xd5\x06\x02\x17\n\r\n\x05\x042\x02\x02\x06\x12\x04\xd5\
    \x06\x02\r\n\r\n\x05\x042\x02\x02\x01\x12\x04\xd5\x06\x0e\x12\n\r\n\x05\
    \x042\x02\x02\x03\x12\x04\xd5\x06\x15\x16\n\x0c\n\x04\x042\x02\x03\x12\
    \x04\xd6\x06\x02\"\n\r\n\x05\x042\x02\x03\x05\x12\x04\xd6\x06\x02\x06\n\
    \r\n\x05\x042\x02\x03\x01\x12\x04\xd6\x06\x07\x1d\n\r\n\x05\x042\x02\x03\
    \x03\x12\x04\xd6\x06\x20!\n\x0c\n\x04\x042\x02\x04\x12\x04\xd7\x06\x02\
    \x1f\n\r\n\x05\x042\x02\x04\x05\x12\x04\xd7\x06\x02\x07\n\r\n\x05\x042\
    \x02\x04\x01\x12\x04\xd7\x06\x08\x1a\n\r\n\x05\x042\x02\x04\x03\x12\x04\
    \xd7\x06\x1d\x1e\n\x0c\n\x04\x042\x02\x05\x12\x04\xd8\x06\x02&\n\r\n\x05\
    \x042\x02\x05\x05\x12\x04\xd8\x06\x02\x06\n\r\n\x05\x042\x02\x05\x01\x12\
    \x04\xd8\x06\x07!\n\r\n\x05\x042\x02\x05\x03\x12\x04\xd8\x06$%\n\x0c\n\
    \x04\x042\x02\x06\x12\x04\xd9\x06\x02#\n\r\n\x05\x042\x02\x06\x05\x12\
    \x04\xd9\x06\x02\x07\n\r\n\x05\x042\x02\x06\x01\x12\x04\xd9\x06\x08\x1e\
    \n\r\n\x05\x042\x02\x06\x03\x12\x04\xd9\x06!\"\n\x0c\n\x04\x042\x02\x07\
    \x12\x04\xda\x06\x02'\n\r\n\x05\x042\x02\x07\x05\x12\x04\xda\x06\x02\x06\
    \n\r\n\x05\x042\x02\x07\x01\x12\x04\xda\x06\x07\"\n\r\n\x05\x042\x02\x07\
    \x03\x12\x04\xda\x06%&\n\x0c\n\x04\x042\x02\x08\x12\x04\xdb\x06\x02$\n\r\
    \n\x05\x042\x02\x08\x05\x12\x04\xdb\x06\x02\x07\n\r\n\x05\x042\x02\x08\
    \x01\x12\x04\xdb\x06\x08\x1f\n\r\n\x05\x042\x02\x08\x03\x12\x04\xdb\x06\
    \"#\n\\\n\x04\x042\x02\t\x12\x04\xdd\x06\x02\x1c\x1aN\x20legacy,\x20for\
    \x20older\x20peers,\x20newer\x20ones\x20should\x20use\x20CLIMATE_PRESET_\
    AWAY\x20in\x20preset\n\n\r\n\x05\x042\x02\t\x05\x12\x04\xdd\x06\x02\x06\
    \n\r\n\x05\x042\x02\t\x01\x12\x04\xdd\x06\x07\x16\n\r\n\x05\x042\x02\t\
    \x03\x12\x04\xdd\x06\x19\x1b\n\x0c\n\x04\x042\x02\n\x12\x04\xde\x06\x02\
    \x18\n\r\n\x05\x042\x02\n\x05\x12\x04\xde\x06\x02\x06\n\r\n\x05\x042\x02\
    \n\x01\x12\x04\xde\x06\x07\x12\n\r\n\x05\x042\x02\n\x03\x12\x04\xde\x06\
    \x15\x17\n\x0c\n\x04\x042\x02\x0b\x12\x04\xdf\x06\x02\x19\n\r\n\x05\x042\
    \x02\x0b\x05\x12\x04\xdf\x06\x02\x06\n\r\n\x05\x042\x02\x0b\x01\x12\x04\
    \xdf\x06\x07\x13\n\r\n\x05\x042\x02\x0b\x03\x12\x04\xdf\x06\x16\x18\n\
    \x0c\n\x04\x042\x02\x0c\x12\x04\xe0\x06\x02\x1f\n\r\n\x05\x042\x02\x0c\
    \x06\x12\x04\xe0\x06\x02\x10\n\r\n\x05\x042\x02\x0c\x01\x12\x04\xe0\x06\
    \x11\x19\n\r\n\x05\x042\x02\x0c\x03\x12\x04\xe0\x06\x1c\x1e\n\x0c\n\x04\
    \x042\x02\r\x12\x04\xe1\x06\x02\x1b\n\r\n\x05\x042\x02\r\x05\x12\x04\xe1\
    \x06\x02\x06\n\r\n\x05\x042\x02\r\x01\x12\x04\xe1\x06\x07\x15\n\r\n\x05\
    \x042\x02\r\x03\x12\x04\xe1\x06\x18\x1a\n\x0c\n\x04\x042\x02\x0e\x12\x04\
    \xe2\x06\x02#\n\r\n\x05\x042\x02\x0e\x06\x12\x04\xe2\x06\x02\x12\n\r\n\
    \x05\x042\x02\x0e\x01\x12\x04\xe2\x06\x13\x1d\n\r\n\x05\x042\x02\x0e\x03\
    \x12\x04\xe2\x06\x20\"\n\x0c\n\x04\x042\x02\x0f\x12\x04\xe3\x06\x02\x20\
    \n\r\n\x05\x042\x02\x0f\x05\x12\x04\xe3\x06\x02\x06\n\r\n\x05\x042\x02\
    \x0f\x01\x12\x04\xe3\x06\x07\x1a\n\r\n\x05\x042\x02\x0f\x03\x12\x04\xe3\
    \x06\x1d\x1f\n\x0c\n\x04\x042\x02\x10\x12\x04\xe4\x06\x02\x1e\n\r\n\x05\
    \x042\x02\x10\x05\x12\x04\xe4\x06\x02\x08\n\r\n\x05\x042\x02\x10\x01\x12\
    \x04\xe4\x06\t\x18\n\r\n\x05\x042\x02\x10\x03\x12\x04\xe4\x06\x1b\x1d\n\
    \x0c\n\x04\x042\x02\x11\x12\x04\xe5\x06\x02\x17\n\r\n\x05\x042\x02\x11\
    \x05\x12\x04\xe5\x06\x02\x06\n\r\n\x05\x042\x02\x11\x01\x12\x04\xe5\x06\
    \x07\x11\n\r\n\x05\x042\x02\x11\x03\x12\x04\xe5\x06\x14\x16\n\x0c\n\x04\
    \x042\x02\x12\x12\x04\xe6\x06\x02\x1c\n\r\n\x05\x042\x02\x12\x06\x12\x04\
    \xe6\x06\x02\x0f\n\r\n\x05\x042\x02\x12\x01\x12\x04\xe6\x06\x10\x16\n\r\
    \n\x05\x042\x02\x12\x03\x12\x04\xe6\x06\x19\x1b\n\x0c\n\x04\x042\x02\x13\
    \x12\x04\xe7\x06\x02\x1e\n\r\n\x05\x042\x02\x13\x05\x12\x04\xe7\x06\x02\
    \x06\n\r\n\x05\x042\x02\x13\x01\x12\x04\xe7\x06\x07\x18\n\r\n\x05\x042\
    \x02\x13\x03\x12\x04\xe7\x06\x1b\x1d\n\x0c\n\x04\x042\x02\x14\x12\x04\
    \xe8\x06\x02\x1c\n\r\n\x05\x042\x02\x14\x05\x12\x04\xe8\x06\x02\x08\n\r\
    \n\x05\x042\x02\x14\x01\x12\x04\xe8\x06\t\x16\n\r\n\x05\x042\x02\x14\x03\
    \x12\x04\xe8\x06\x19\x1b\n@\n\x02\x05\x10\x12\x06\xec\x06\0\xf0\x06\x01\
    \x1a2\x20====================\x20NUMBER\x20====================\n\n\x0b\
    \n\x03\x05\x10\x01\x12\x04\xec\x06\x05\x0f\n\x0c\n\x04\x05\x10\x02\0\x12\
    \x04\xed\x06\x02\x17\n\r\n\x05\x05\x10\x02\0\x01\x12\x04\xed\x06\x02\x12\
    \n\r\n\x05\x05\x10\x02\0\x02\x12\x04\xed\x06\x15\x16\n\x0c\n\x04\x05\x10\
    \x02\x01\x12\x04\xee\x06\x02\x16\n\r\n\x05\x05\x10\x02\x01\x01\x12\x04\
    \xee\x06\x02\x11\n\r\n\x05\x05\x10\x02\x01\x02\x12\x04\xee\x06\x14\x15\n\
    \x0c\n\x04\x05\x10\x02\x02\x12\x04\xef\x06\x02\x19\n\r\n\x05\x05\x10\x02\
    \x02\x01\x12\x04\xef\x06\x02\x14\n\r\n\x05\x05\x10\x02\x02\x02\x12\x04\
    \xef\x06\x17\x18\n\x0c\n\x02\x043\x12\x06\xf1\x06\0\x83\x07\x01\n\x0b\n\
    \x03\x043\x01\x12\x04\xf1\x06\x08\"\n\x0b\n\x03\x043\x07\x12\x04\xf2\x06\
    \x02\x13\n\r\n\x05\x043\x07\x8c\x08\x12\x04\xf2\x06\x02\x13\n\x0b\n\x03\
    \x043\x07\x12\x04\xf3\x06\x02\"\n\r\n\x05\x043\x07\x8d\x08\x12\x04\xf3\
    \x06\x02\"\n\x0b\n\x03\x043\x07\x12\x04\xf4\x06\x02\x20\n\r\n\x05\x043\
    \x07\x8e\x08\x12\x04\xf4\x06\x02\x20\n\x0c\n\x04\x043\x02\0\x12\x04\xf6\
    \x06\x02\x17\n\r\n\x05\x043\x02\0\x05\x12\x04\xf6\x06\x02\x08\n\r\n\x05\
    \x043\x02\0\x01\x12\x04\xf6\x06\t\x12\n\r\n\x05\x043\x02\0\x03\x12\x04\
    \xf6\x06\x15\x16\n\x0c\n\x04\x043\x02\x01\x12\x04\xf7\x06\x02\x12\n\r\n\
    \x05\x043\x02\x01\x05\x12\x04\xf7\x06\x02\t\n\r\n\x05\x043\x02\x01\x01\
    \x12\x04\xf7\x06\n\r\n\r\n\x05\x043\x02\x01\x03\x12\x04\xf7\x06\x10\x11\
    \n\x0c\n\x04\x043\x02\x02\x12\x04\xf8\x06\x02\x12\n\r\n\x05\x043\x02\x02\
    \x05\x12\x04\xf8\x06\x02\x08\n\r\n\x05\x043\x02\x02\x01\x12\x04\xf8\x06\
    \t\r\n\r\n\x05\x043\x02\x02\x03\x12\x04\xf8\x06\x10\x11\n\x0c\n\x04\x043\
    \x02\x03\x12\x04\xf9\x06\x02\x17\n\r\n\x05\x043\x02\x03\x05\x12\x04\xf9\
    \x06\x02\x08\n\r\n\x05\x043\x02\x03\x01\x12\x04\xf9\x06\t\x12\n\r\n\x05\
    \x043\x02\x03\x03\x12\x04\xf9\x06\x15\x16\n\x0c\n\x04\x043\x02\x04\x12\
    \x04\xfb\x06\x02\x12\n\r\n\x05\x043\x02\x04\x05\x12\x04\xfb\x06\x02\x08\
    \n\r\n\x05\x043\x02\x04\x01\x12\x04\xfb\x06\t\r\n\r\n\x05\x043\x02\x04\
    \x03\x12\x04\xfb\x06\x10\x11\n\x0c\n\x04\x043\x02\x05\x12\x04\xfc\x06\
    \x02\x16\n\r\n\x05\x043\x02\x05\x05\x12\x04\xfc\x06\x02\x07\n\r\n\x05\
    \x043\x02\x05\x01\x12\x04\xfc\x06\x08\x11\n\r\n\x05\x043\x02\x05\x03\x12\
    \x04\xfc\x06\x14\x15\n\x0c\n\x04\x043\x02\x06\x12\x04\xfd\x06\x02\x16\n\
    \r\n\x05\x043\x02\x06\x05\x12\x04\xfd\x06\x02\x07\n\r\n\x05\x043\x02\x06\
    \x01\x12\x04\xfd\x06\x08\x11\n\r\n\x05\x043\x02\x06\x03\x12\x04\xfd\x06\
    \x14\x15\n\x0c\n\x04\x043\x02\x07\x12\x04\xfe\x06\x02\x11\n\r\n\x05\x043\
    \x02\x07\x05\x12\x04\xfe\x06\x02\x07\n\r\n\x05\x043\x02\x07\x01\x12\x04\
    \xfe\x06\x08\x0c\n\r\n\x05\x043\x02\x07\x03\x12\x04\xfe\x06\x0f\x10\n\
    \x0c\n\x04\x043\x02\x08\x12\x04\xff\x06\x02\x1f\n\r\n\x05\x043\x02\x08\
    \x05\x12\x04\xff\x06\x02\x06\n\r\n\x05\x043\x02\x08\x01\x12\x04\xff\x06\
    \x07\x1a\n\r\n\x05\x043\x02\x08\x03\x12\x04\xff\x06\x1d\x1e\n\x0c\n\x04\
    \x043\x02\t\x12\x04\x80\x07\x02&\n\r\n\x05\x043\x02\t\x06\x12\x04\x80\
    \x07\x02\x10\n\r\n\x05\x043\x02\t\x01\x12\x04\x80\x07\x11\x20\n\r\n\x05\
    \x043\x02\t\x03\x12\x04\x80\x07#%\n\x0c\n\x04\x043\x02\n\x12\x04\x81\x07\
    \x02\"\n\r\n\x05\x043\x02\n\x05\x12\x04\x81\x07\x02\x08\n\r\n\x05\x043\
    \x02\n\x01\x12\x04\x81\x07\t\x1c\n\r\n\x05\x043\x02\n\x03\x12\x04\x81\
    \x07\x1f!\n\x0c\n\x04\x043\x02\x0b\x12\x04\x82\x07\x02\x17\n\r\n\x05\x04\
    3\x02\x0b\x06\x12\x04\x82\x07\x02\x0c\n\r\n\x05\x043\x02\x0b\x01\x12\x04\
    \x82\x07\r\x11\n\r\n\x05\x043\x02\x0b\x03\x12\x04\x82\x07\x14\x16\n\x0c\
    \n\x02\x044\x12\x06\x84\x07\0\x8f\x07\x01\n\x0b\n\x03\x044\x01\x12\x04\
    \x84\x07\x08\x1b\n\x0b\n\x03\x044\x07\x12\x04\x85\x07\x02\x13\n\r\n\x05\
    \x044\x07\x8c\x08\x12\x04\x85\x07\x02\x13\n\x0b\n\x03\x044\x07\x12\x04\
    \x86\x07\x02\"\n\r\n\x05\x044\x07\x8d\x08\x12\x04\x86\x07\x02\"\n\x0b\n\
    \x03\x044\x07\x12\x04\x87\x07\x02\x20\n\r\n\x05\x044\x07\x8e\x08\x12\x04\
    \x87\x07\x02\x20\n\x0b\n\x03\x044\x07\x12\x04\x88\x07\x02\x1b\n\r\n\x05\
    \x044\x07\x90\x08\x12\x04\x88\x07\x02\x1b\n\x0c\n\x04\x044\x02\0\x12\x04\
    \x8a\x07\x02\x12\n\r\n\x05\x044\x02\0\x05\x12\x04\x8a\x07\x02\t\n\r\n\
    \x05\x044\x02\0\x01\x12\x04\x8a\x07\n\r\n\r\n\x05\x044\x02\0\x03\x12\x04\
    \x8a\x07\x10\x11\n\x0c\n\x04\x044\x02\x01\x12\x04\x8b\x07\x02\x12\n\r\n\
    \x05\x044\x02\x01\x05\x12\x04\x8b\x07\x02\x07\n\r\n\x05\x044\x02\x01\x01\
    \x12\x04\x8b\x07\x08\r\n\r\n\x05\x044\x02\x01\x03\x12\x04\x8b\x07\x10\
    \x11\n\x90\x01\n\x04\x044\x02\x02\x12\x04\x8e\x07\x02\x19\x1a\x81\x01\
    \x20If\x20the\x20number\x20does\x20not\x20have\x20a\x20valid\x20state\
    \x20yet.\n\x20Equivalent\x20to\x20`!obj->has_state()`\x20-\x20inverse\
    \x20logic\x20to\x20make\x20state\x20packets\x20smaller\n\n\r\n\x05\x044\
    \x02\x02\x05\x12\x04\x8e\x07\x02\x06\n\r\n\x05\x044\x02\x02\x01\x12\x04\
    \x8e\x07\x07\x14\n\r\n\x05\x044\x02\x02\x03\x12\x04\x8e\x07\x17\x18\n\
    \x0c\n\x02\x045\x12\x06\x90\x07\0\x98\x07\x01\n\x0b\n\x03\x045\x01\x12\
    \x04\x90\x07\x08\x1c\n\x0b\n\x03\x045\x07\x12\x04\x91\x07\x02\x13\n\r\n\
    \x05\x045\x07\x8c\x08\x12\x04\x91\x07\x02\x13\n\x0b\n\x03\x045\x07\x12\
    \x04\x92\x07\x02\"\n\r\n\x05\x045\x07\x8d\x08\x12\x04\x92\x07\x02\"\n\
    \x0b\n\x03\x045\x07\x12\x04\x93\x07\x02\x20\n\r\n\x05\x045\x07\x8e\x08\
    \x12\x04\x93\x07\x02\x20\n\x0b\n\x03\x045\x07\x12\x04\x94\x07\x02\x1b\n\
    \r\n\x05\x045\x07\x90\x08\x12\x04\x94\x07\x02\x1b\n\x0c\n\x04\x045\x02\0\
    \x12\x04\x96\x07\x02\x12\n\r\n\x05\x045\x02\0\x05\x12\x04\x96\x07\x02\t\
    \n\r\n\x05\x045\x02\0\x01\x12\x04\x96\x07\n\r\n\r\n\x05\x045\x02\0\x03\
    \x12\x04\x96\x07\x10\x11\n\x0c\n\x04\x045\x02\x01\x12\x04\x97\x07\x02\
    \x12\n\r\n\x05\x045\x02\x01\x05\x12\x04\x97\x07\x02\x07\n\r\n\x05\x045\
    \x02\x01\x01\x12\x04\x97\x07\x08\r\n\r\n\x05\x045\x02\x01\x03\x12\x04\
    \x97\x07\x10\x11\n@\n\x02\x046\x12\x06\x9b\x07\0\xa9\x07\x01\x1a2\x20===\
    =================\x20SELECT\x20====================\n\n\x0b\n\x03\x046\
    \x01\x12\x04\x9b\x07\x08\"\n\x0b\n\x03\x046\x07\x12\x04\x9c\x07\x02\x13\
    \n\r\n\x05\x046\x07\x8c\x08\x12\x04\x9c\x07\x02\x13\n\x0b\n\x03\x046\x07\
    \x12\x04\x9d\x07\x02\"\n\r\n\x05\x046\x07\x8d\x08\x12\x04\x9d\x07\x02\"\
    \n\x0b\n\x03\x046\x07\x12\x04\x9e\x07\x02\x20\n\r\n\x05\x046\x07\x8e\x08\
    \x12\x04\x9e\x07\x02\x20\n\x0c\n\x04\x046\x02\0\x12\x04\xa0\x07\x02\x17\
    \n\r\n\x05\x046\x02\0\x05\x12\x04\xa0\x07\x02\x08\n\r\n\x05\x046\x02\0\
    \x01\x12\x04\xa0\x07\t\x12\n\r\n\x05\x046\x02\0\x03\x12\x04\xa0\x07\x15\
    \x16\n\x0c\n\x04\x046\x02\x01\x12\x04\xa1\x07\x02\x12\n\r\n\x05\x046\x02\
    \x01\x05\x12\x04\xa1\x07\x02\t\n\r\n\x05\x046\x02\x01\x01\x12\x04\xa1\
    \x07\n\r\n\r\n\x05\x046\x02\x01\x03\x12\x04\xa1\x07\x10\x11\n\x0c\n\x04\
    \x046\x02\x02\x12\x04\xa2\x07\x02\x12\n\r\n\x05\x046\x02\x02\x05\x12\x04\
    \xa2\x07\x02\x08\n\r\n\x05\x046\x02\x02\x01\x12\x04\xa2\x07\t\r\n\r\n\
    \x05\x046\x02\x02\x03\x12\x04\xa2\x07\x10\x11\n\x0c\n\x04\x046\x02\x03\
    \x12\x04\xa3\x07\x02\x17\n\r\n\x05\x046\x02\x03\x05\x12\x04\xa3\x07\x02\
    \x08\n\r\n\x05\x046\x02\x03\x01\x12\x04\xa3\x07\t\x12\n\r\n\x05\x046\x02\
    \x03\x03\x12\x04\xa3\x07\x15\x16\n\x0c\n\x04\x046\x02\x04\x12\x04\xa5\
    \x07\x02\x12\n\r\n\x05\x046\x02\x04\x05\x12\x04\xa5\x07\x02\x08\n\r\n\
    \x05\x046\x02\x04\x01\x12\x04\xa5\x07\t\r\n\r\n\x05\x046\x02\x04\x03\x12\
    \x04\xa5\x07\x10\x11\n\x0c\n\x04\x046\x02\x05\x12\x04\xa6\x07\x02\x1e\n\
    \r\n\x05\x046\x02\x05\x04\x12\x04\xa6\x07\x02\n\n\r\n\x05\x046\x02\x05\
    \x05\x12\x04\xa6\x07\x0b\x11\n\r\n\x05\x046\x02\x05\x01\x12\x04\xa6\x07\
    \x12\x19\n\r\n\x05\x046\x02\x05\x03\x12\x04\xa6\x07\x1c\x1d\n\x0c\n\x04\
    \x046\x02\x06\x12\x04\xa7\x07\x02\x1f\n\r\n\x05\x046\x02\x06\x05\x12\x04\
    \xa7\x07\x02\x06\n\r\n\x05\x046\x02\x06\x01\x12\x04\xa7\x07\x07\x1a\n\r\
    \n\x05\x046\x02\x06\x03\x12\x04\xa7\x07\x1d\x1e\n\x0c\n\x04\x046\x02\x07\
    \x12\x04\xa8\x07\x02%\n\r\n\x05\x046\x02\x07\x06\x12\x04\xa8\x07\x02\x10\
    \n\r\n\x05\x046\x02\x07\x01\x12\x04\xa8\x07\x11\x20\n\r\n\x05\x046\x02\
    \x07\x03\x12\x04\xa8\x07#$\n\x0c\n\x02\x047\x12\x06\xaa\x07\0\xb5\x07\
    \x01\n\x0b\n\x03\x047\x01\x12\x04\xaa\x07\x08\x1b\n\x0b\n\x03\x047\x07\
    \x12\x04\xab\x07\x02\x13\n\r\n\x05\x047\x07\x8c\x08\x12\x04\xab\x07\x02\
    \x13\n\x0b\n\x03\x047\x07\x12\x04\xac\x07\x02\"\n\r\n\x05\x047\x07\x8d\
    \x08\x12\x04\xac\x07\x02\"\n\x0b\n\x03\x047\x07\x12\x04\xad\x07\x02\x20\
    \n\r\n\x05\x047\x07\x8e\x08\x12\x04\xad\x07\x02\x20\n\x0b\n\x03\x047\x07\
    \x12\x04\xae\x07\x02\x1b\n\r\n\x05\x047\x07\x90\x08\x12\x04\xae\x07\x02\
    \x1b\n\x0c\n\x04\x047\x02\0\x12\x04\xb0\x07\x02\x12\n\r\n\x05\x047\x02\0\
    \x05\x12\x04\xb0\x07\x02\t\n\r\n\x05\x047\x02\0\x01\x12\x04\xb0\x07\n\r\
    \n\r\n\x05\x047\x02\0\x03\x12\x04\xb0\x07\x10\x11\n\x0c\n\x04\x047\x02\
    \x01\x12\x04\xb1\x07\x02\x13\n\r\n\x05\x047\x02\x01\x05\x12\x04\xb1\x07\
    \x02\x08\n\r\n\x05\x047\x02\x01\x01\x12\x04\xb1\x07\t\x0e\n\r\n\x05\x047\
    \x02\x01\x03\x12\x04\xb1\x07\x11\x12\n\x90\x01\n\x04\x047\x02\x02\x12\
    \x04\xb4\x07\x02\x19\x1a\x81\x01\x20If\x20the\x20select\x20does\x20not\
    \x20have\x20a\x20valid\x20state\x20yet.\n\x20Equivalent\x20to\x20`!obj->\
    has_state()`\x20-\x20inverse\x20logic\x20to\x20make\x20state\x20packets\
    \x20smaller\n\n\r\n\x05\x047\x02\x02\x05\x12\x04\xb4\x07\x02\x06\n\r\n\
    \x05\x047\x02\x02\x01\x12\x04\xb4\x07\x07\x14\n\r\n\x05\x047\x02\x02\x03\
    \x12\x04\xb4\x07\x17\x18\n\x0c\n\x02\x048\x12\x06\xb6\x07\0\xbe\x07\x01\
    \n\x0b\n\x03\x048\x01\x12\x04\xb6\x07\x08\x1c\n\x0b\n\x03\x048\x07\x12\
    \x04\xb7\x07\x02\x13\n\r\n\x05\x048\x07\x8c\x08\x12\x04\xb7\x07\x02\x13\
    \n\x0b\n\x03\x048\x07\x12\x04\xb8\x07\x02\"\n\r\n\x05\x048\x07\x8d\x08\
    \x12\x04\xb8\x07\x02\"\n\x0b\n\x03\x048\x07\x12\x04\xb9\x07\x02\x20\n\r\
    \n\x05\x048\x07\x8e\x08\x12\x04\xb9\x07\x02\x20\n\x0b\n\x03\x048\x07\x12\
    \x04\xba\x07\x02\x1b\n\r\n\x05\x048\x07\x90\x08\x12\x04\xba\x07\x02\x1b\
    \n\x0c\n\x04\x048\x02\0\x12\x04\xbc\x07\x02\x12\n\r\n\x05\x048\x02\0\x05\
    \x12\x04\xbc\x07\x02\t\n\r\n\x05\x048\x02\0\x01\x12\x04\xbc\x07\n\r\n\r\
    \n\x05\x048\x02\0\x03\x12\x04\xbc\x07\x10\x11\n\x0c\n\x04\x048\x02\x01\
    \x12\x04\xbd\x07\x02\x13\n\r\n\x05\x048\x02\x01\x05\x12\x04\xbd\x07\x02\
    \x08\n\r\n\x05\x048\x02\x01\x01\x12\x04\xbd\x07\t\x0e\n\r\n\x05\x048\x02\
    \x01\x03\x12\x04\xbd\x07\x11\x12\n>\n\x02\x05\x11\x12\x06\xc2\x07\0\xc9\
    \x07\x01\x1a0\x20====================\x20LOCK\x20====================\n\
    \n\x0b\n\x03\x05\x11\x01\x12\x04\xc2\x07\x05\x0e\n\x0c\n\x04\x05\x11\x02\
    \0\x12\x04\xc3\x07\x02\x16\n\r\n\x05\x05\x11\x02\0\x01\x12\x04\xc3\x07\
    \x02\x11\n\r\n\x05\x05\x11\x02\0\x02\x12\x04\xc3\x07\x14\x15\n\x0c\n\x04\
    \x05\x11\x02\x01\x12\x04\xc4\x07\x02\x18\n\r\n\x05\x05\x11\x02\x01\x01\
    \x12\x04\xc4\x07\x02\x13\n\r\n\x05\x05\x11\x02\x01\x02\x12\x04\xc4\x07\
    \x16\x17\n\x0c\n\x04\x05\x11\x02\x02\x12\x04\xc5\x07\x02\x1a\n\r\n\x05\
    \x05\x11\x02\x02\x01\x12\x04\xc5\x07\x02\x15\n\r\n\x05\x05\x11\x02\x02\
    \x02\x12\x04\xc5\x07\x18\x19\n\x0c\n\x04\x05\x11\x02\x03\x12\x04\xc6\x07\
    \x02\x18\n\r\n\x05\x05\x11\x02\x03\x01\x12\x04\xc6\x07\x02\x13\n\r\n\x05\
    \x05\x11\x02\x03\x02\x12\x04\xc6\x07\x16\x17\n\x0c\n\x04\x05\x11\x02\x04\
    \x12\x04\xc7\x07\x02\x19\n\r\n\x05\x05\x11\x02\x04\x01\x12\x04\xc7\x07\
    \x02\x14\n\r\n\x05\x05\x11\x02\x04\x02\x12\x04\xc7\x07\x17\x18\n\x0c\n\
    \x04\x05\x11\x02\x05\x12\x04\xc8\x07\x02\x1b\n\r\n\x05\x05\x11\x02\x05\
    \x01\x12\x04\xc8\x07\x02\x16\n\r\n\x05\x05\x11\x02\x05\x02\x12\x04\xc8\
    \x07\x19\x1a\n\x0c\n\x02\x05\x12\x12\x06\xca\x07\0\xce\x07\x01\n\x0b\n\
    \x03\x05\x12\x01\x12\x04\xca\x07\x05\x10\n\x0c\n\x04\x05\x12\x02\0\x12\
    \x04\xcb\x07\x02\x12\n\r\n\x05\x05\x12\x02\0\x01\x12\x04\xcb\x07\x02\r\n\
    \r\n\x05\x05\x12\x02\0\x02\x12\x04\xcb\x07\x10\x11\n\x0c\n\x04\x05\x12\
    \x02\x01\x12\x04\xcc\x07\x02\x10\n\r\n\x05\x05\x12\x02\x01\x01\x12\x04\
    \xcc\x07\x02\x0b\n\r\n\x05\x05\x12\x02\x01\x02\x12\x04\xcc\x07\x0e\x0f\n\
    \x0c\n\x04\x05\x12\x02\x02\x12\x04\xcd\x07\x02\x10\n\r\n\x05\x05\x12\x02\
    \x02\x01\x12\x04\xcd\x07\x02\x0b\n\r\n\x05\x05\x12\x02\x02\x02\x12\x04\
    \xcd\x07\x0e\x0f\n\x0c\n\x02\x049\x12\x06\xcf\x07\0\xe3\x07\x01\n\x0b\n\
    \x03\x049\x01\x12\x04\xcf\x07\x08\x20\n\x0b\n\x03\x049\x07\x12\x04\xd0\
    \x07\x02\x13\n\r\n\x05\x049\x07\x8c\x08\x12\x04\xd0\x07\x02\x13\n\x0b\n\
    \x03\x049\x07\x12\x04\xd1\x07\x02\"\n\r\n\x05\x049\x07\x8d\x08\x12\x04\
    \xd1\x07\x02\"\n\x0b\n\x03\x049\x07\x12\x04\xd2\x07\x02\x1e\n\r\n\x05\
    \x049\x07\x8e\x08\x12\x04\xd2\x07\x02\x1e\n\x0c\n\x04\x049\x02\0\x12\x04\
    \xd4\x07\x02\x17\n\r\n\x05\x049\x02\0\x05\x12\x04\xd4\x07\x02\x08\n\r\n\
    \x05\x049\x02\0\x01\x12\x04\xd4\x07\t\x12\n\r\n\x05\x049\x02\0\x03\x12\
    \x04\xd4\x07\x15\x16\n\x0c\n\x04\x049\x02\x01\x12\x04\xd5\x07\x02\x12\n\
    \r\n\x05\x049\x02\x01\x05\x12\x04\xd5\x07\x02\t\n\r\n\x05\x049\x02\x01\
    \x01\x12\x04\xd5\x07\n\r\n\r\n\x05\x049\x02\x01\x03\x12\x04\xd5\x07\x10\
    \x11\n\x0c\n\x04\x049\x02\x02\x12\x04\xd6\x07\x02\x12\n\r\n\x05\x049\x02\
    \x02\x05\x12\x04\xd6\x07\x02\x08\n\r\n\x05\x049\x02\x02\x01\x12\x04\xd6\
    \x07\t\r\n\r\n\x05\x049\x02\x02\x03\x12\x04\xd6\x07\x10\x11\n\x0c\n\x04\
    \x049\x02\x03\x12\x04\xd7\x07\x02\x17\n\r\n\x05\x049\x02\x03\x05\x12\x04\
    \xd7\x07\x02\x08\n\r\n\x05\x049\x02\x03\x01\x12\x04\xd7\x07\t\x12\n\r\n\
    \x05\x049\x02\x03\x03\x12\x04\xd7\x07\x15\x16\n\x0c\n\x04\x049\x02\x04\
    \x12\x04\xd9\x07\x02\x12\n\r\n\x05\x049\x02\x04\x05\x12\x04\xd9\x07\x02\
    \x08\n\r\n\x05\x049\x02\x04\x01\x12\x04\xd9\x07\t\r\n\r\n\x05\x049\x02\
    \x04\x03\x12\x04\xd9\x07\x10\x11\n\x0c\n\x04\x049\x02\x05\x12\x04\xda\
    \x07\x02\x1f\n\r\n\x05\x049\x02\x05\x05\x12\x04\xda\x07\x02\x06\n\r\n\
    \x05\x049\x02\x05\x01\x12\x04\xda\x07\x07\x1a\n\r\n\x05\x049\x02\x05\x03\
    \x12\x04\xda\x07\x1d\x1e\n\x0c\n\x04\x049\x02\x06\x12\x04\xdb\x07\x02%\n\
    \r\n\x05\x049\x02\x06\x06\x12\x04\xdb\x07\x02\x10\n\r\n\x05\x049\x02\x06\
    \x01\x12\x04\xdb\x07\x11\x20\n\r\n\x05\x049\x02\x06\x03\x12\x04\xdb\x07#\
    $\n\x0c\n\x04\x049\x02\x07\x12\x04\xdc\x07\x02\x19\n\r\n\x05\x049\x02\
    \x07\x05\x12\x04\xdc\x07\x02\x06\n\r\n\x05\x049\x02\x07\x01\x12\x04\xdc\
    \x07\x07\x14\n\r\n\x05\x049\x02\x07\x03\x12\x04\xdc\x07\x17\x18\n\x0c\n\
    \x04\x049\x02\x08\x12\x04\xde\x07\x02\x19\n\r\n\x05\x049\x02\x08\x05\x12\
    \x04\xde\x07\x02\x06\n\r\n\x05\x049\x02\x08\x01\x12\x04\xde\x07\x07\x14\
    \n\r\n\x05\x049\x02\x08\x03\x12\x04\xde\x07\x17\x18\n\x0c\n\x04\x049\x02\
    \t\x12\x04\xdf\x07\x02\x1a\n\r\n\x05\x049\x02\t\x05\x12\x04\xdf\x07\x02\
    \x06\n\r\n\x05\x049\x02\t\x01\x12\x04\xdf\x07\x07\x14\n\r\n\x05\x049\x02\
    \t\x03\x12\x04\xdf\x07\x17\x19\n$\n\x04\x049\x02\n\x12\x04\xe2\x07\x02\
    \x1a\x1a\x16\x20Not\x20yet\x20implemented:\n\n\r\n\x05\x049\x02\n\x05\
    \x12\x04\xe2\x07\x02\x08\n\r\n\x05\x049\x02\n\x01\x12\x04\xe2\x07\t\x14\
    \n\r\n\x05\x049\x02\n\x03\x12\x04\xe2\x07\x17\x19\n\x0c\n\x02\x04:\x12\
    \x06\xe4\x07\0\xeb\x07\x01\n\x0b\n\x03\x04:\x01\x12\x04\xe4\x07\x08\x19\
    \n\x0b\n\x03\x04:\x07\x12\x04\xe5\x07\x02\x13\n\r\n\x05\x04:\x07\x8c\x08\
    \x12\x04\xe5\x07\x02\x13\n\x0b\n\x03\x04:\x07\x12\x04\xe6\x07\x02\"\n\r\
    \n\x05\x04:\x07\x8d\x08\x12\x04\xe6\x07\x02\"\n\x0b\n\x03\x04:\x07\x12\
    \x04\xe7\x07\x02\x1e\n\r\n\x05\x04:\x07\x8e\x08\x12\x04\xe7\x07\x02\x1e\
    \n\x0b\n\x03\x04:\x07\x12\x04\xe8\x07\x02\x1b\n\r\n\x05\x04:\x07\x90\x08\
    \x12\x04\xe8\x07\x02\x1b\n\x0c\n\x04\x04:\x02\0\x12\x04\xe9\x07\x02\x12\
    \n\r\n\x05\x04:\x02\0\x05\x12\x04\xe9\x07\x02\t\n\r\n\x05\x04:\x02\0\x01\
    \x12\x04\xe9\x07\n\r\n\r\n\x05\x04:\x02\0\x03\x12\x04\xe9\x07\x10\x11\n\
    \x0c\n\x04\x04:\x02\x01\x12\x04\xea\x07\x02\x16\n\r\n\x05\x04:\x02\x01\
    \x06\x12\x04\xea\x07\x02\x0b\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xea\x07\
    \x0c\x11\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xea\x07\x14\x15\n\x0c\n\x02\
    \x04;\x12\x06\xec\x07\0\xf7\x07\x01\n\x0b\n\x03\x04;\x01\x12\x04\xec\x07\
    \x08\x1a\n\x0b\n\x03\x04;\x07\x12\x04\xed\x07\x02\x13\n\r\n\x05\x04;\x07\
    \x8c\x08\x12\x04\xed\x07\x02\x13\n\x0b\n\x03\x04;\x07\x12\x04\xee\x07\
    \x02\"\n\r\n\x05\x04;\x07\x8d\x08\x12\x04\xee\x07\x02\"\n\x0b\n\x03\x04;\
    \x07\x12\x04\xef\x07\x02\x1e\n\r\n\x05\x04;\x07\x8e\x08\x12\x04\xef\x07\
    \x02\x1e\n\x0b\n\x03\x04;\x07\x12\x04\xf0\x07\x02\x1b\n\r\n\x05\x04;\x07\
    \x90\x08\x12\x04\xf0\x07\x02\x1b\n\x0c\n\x04\x04;\x02\0\x12\x04\xf1\x07\
    \x02\x12\n\r\n\x05\x04;\x02\0\x05\x12\x04\xf1\x07\x02\t\n\r\n\x05\x04;\
    \x02\0\x01\x12\x04\xf1\x07\n\r\n\r\n\x05\x04;\x02\0\x03\x12\x04\xf1\x07\
    \x10\x11\n\x0c\n\x04\x04;\x02\x01\x12\x04\xf2\x07\x02\x1a\n\r\n\x05\x04;\
    \x02\x01\x06\x12\x04\xf2\x07\x02\r\n\r\n\x05\x04;\x02\x01\x01\x12\x04\
    \xf2\x07\x0e\x15\n\r\n\x05\x04;\x02\x01\x03\x12\x04\xf2\x07\x18\x19\n$\n\
    \x04\x04;\x02\x02\x12\x04\xf5\x07\x02\x14\x1a\x16\x20Not\x20yet\x20imple\
    mented:\n\n\r\n\x05\x04;\x02\x02\x05\x12\x04\xf5\x07\x02\x06\n\r\n\x05\
    \x04;\x02\x02\x01\x12\x04\xf5\x07\x07\x0f\n\r\n\x05\x04;\x02\x02\x03\x12\
    \x04\xf5\x07\x12\x13\n\x0c\n\x04\x04;\x02\x03\x12\x04\xf6\x07\x02\x12\n\
    \r\n\x05\x04;\x02\x03\x05\x12\x04\xf6\x07\x02\x08\n\r\n\x05\x04;\x02\x03\
    \x01\x12\x04\xf6\x07\t\r\n\r\n\x05\x04;\x02\x03\x03\x12\x04\xf6\x07\x10\
    \x11\n@\n\x02\x04<\x12\x06\xfa\x07\0\x88\x08\x01\x1a2\x20===============\
    =====\x20BUTTON\x20====================\n\n\x0b\n\x03\x04<\x01\x12\x04\
    \xfa\x07\x08\"\n\x0b\n\x03\x04<\x07\x12\x04\xfb\x07\x02\x13\n\r\n\x05\
    \x04<\x07\x8c\x08\x12\x04\xfb\x07\x02\x13\n\x0b\n\x03\x04<\x07\x12\x04\
    \xfc\x07\x02\"\n\r\n\x05\x04<\x07\x8d\x08\x12\x04\xfc\x07\x02\"\n\x0b\n\
    \x03\x04<\x07\x12\x04\xfd\x07\x02\x20\n\r\n\x05\x04<\x07\x8e\x08\x12\x04\
    \xfd\x07\x02\x20\n\x0c\n\x04\x04<\x02\0\x12\x04\xff\x07\x02\x17\n\r\n\
    \x05\x04<\x02\0\x05\x12\x04\xff\x07\x02\x08\n\r\n\x05\x04<\x02\0\x01\x12\
    \x04\xff\x07\t\x12\n\r\n\x05\x04<\x02\0\x03\x12\x04\xff\x07\x15\x16\n\
    \x0c\n\x04\x04<\x02\x01\x12\x04\x80\x08\x02\x12\n\r\n\x05\x04<\x02\x01\
    \x05\x12\x04\x80\x08\x02\t\n\r\n\x05\x04<\x02\x01\x01\x12\x04\x80\x08\n\
    \r\n\r\n\x05\x04<\x02\x01\x03\x12\x04\x80\x08\x10\x11\n\x0c\n\x04\x04<\
    \x02\x02\x12\x04\x81\x08\x02\x12\n\r\n\x05\x04<\x02\x02\x05\x12\x04\x81\
    \x08\x02\x08\n\r\n\x05\x04<\x02\x02\x01\x12\x04\x81\x08\t\r\n\r\n\x05\
    \x04<\x02\x02\x03\x12\x04\x81\x08\x10\x11\n\x0c\n\x04\x04<\x02\x03\x12\
    \x04\x82\x08\x02\x17\n\r\n\x05\x04<\x02\x03\x05\x12\x04\x82\x08\x02\x08\
    \n\r\n\x05\x04<\x02\x03\x01\x12\x04\x82\x08\t\x12\n\r\n\x05\x04<\x02\x03\
    \x03\x12\x04\x82\x08\x15\x16\n\x0c\n\x04\x04<\x02\x04\x12\x04\x84\x08\
    \x02\x12\n\r\n\x05\x04<\x02\x04\x05\x12\x04\x84\x08\x02\x08\n\r\n\x05\
    \x04<\x02\x04\x01\x12\x04\x84\x08\t\r\n\r\n\x05\x04<\x02\x04\x03\x12\x04\
    \x84\x08\x10\x11\n\x0c\n\x04\x04<\x02\x05\x12\x04\x85\x08\x02\x1f\n\r\n\
    \x05\x04<\x02\x05\x05\x12\x04\x85\x08\x02\x06\n\r\n\x05\x04<\x02\x05\x01\
    \x12\x04\x85\x08\x07\x1a\n\r\n\x05\x04<\x02\x05\x03\x12\x04\x85\x08\x1d\
    \x1e\n\x0c\n\x04\x04<\x02\x06\x12\x04\x86\x08\x02%\n\r\n\x05\x04<\x02\
    \x06\x06\x12\x04\x86\x08\x02\x10\n\r\n\x05\x04<\x02\x06\x01\x12\x04\x86\
    \x08\x11\x20\n\r\n\x05\x04<\x02\x06\x03\x12\x04\x86\x08#$\n\x0c\n\x04\
    \x04<\x02\x07\x12\x04\x87\x08\x02\x1a\n\r\n\x05\x04<\x02\x07\x05\x12\x04\
    \x87\x08\x02\x08\n\r\n\x05\x04<\x02\x07\x01\x12\x04\x87\x08\t\x15\n\r\n\
    \x05\x04<\x02\x07\x03\x12\x04\x87\x08\x18\x19\n\x0c\n\x02\x04=\x12\x06\
    \x89\x08\0\x90\x08\x01\n\x0b\n\x03\x04=\x01\x12\x04\x89\x08\x08\x1c\n\
    \x0b\n\x03\x04=\x07\x12\x04\x8a\x08\x02\x13\n\r\n\x05\x04=\x07\x8c\x08\
    \x12\x04\x8a\x08\x02\x13\n\x0b\n\x03\x04=\x07\x12\x04\x8b\x08\x02\"\n\r\
    \n\x05\x04=\x07\x8d\x08\x12\x04\x8b\x08\x02\"\n\x0b\n\x03\x04=\x07\x12\
    \x04\x8c\x08\x02\x20\n\r\n\x05\x04=\x07\x8e\x08\x12\x04\x8c\x08\x02\x20\
    \n\x0b\n\x03\x04=\x07\x12\x04\x8d\x08\x02\x1b\n\r\n\x05\x04=\x07\x90\x08\
    \x12\x04\x8d\x08\x02\x1b\n\x0c\n\x04\x04=\x02\0\x12\x04\x8f\x08\x02\x12\
    \n\r\n\x05\x04=\x02\0\x05\x12\x04\x8f\x08\x02\t\n\r\n\x05\x04=\x02\0\x01\
    \x12\x04\x8f\x08\n\r\n\r\n\x05\x04=\x02\0\x03\x12\x04\x8f\x08\x10\x11b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
